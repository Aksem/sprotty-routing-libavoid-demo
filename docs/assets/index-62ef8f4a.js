(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$1(a);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({
  deps
}) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const {
    deps
  } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const {
    deps
  } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const {
    has: has2
  } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const {
          value,
          done
        } = innerIterator.next();
        return done ? {
          value,
          done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const {
      number,
      trim
    } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode: vnode2,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode2.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : {
        attrs,
        slots,
        emit: emit2
      }) : render2(
        props,
        null
        /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const {
      shapeFlag
    } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode2.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode2.dirs) : vnode2.dirs;
  }
  if (vnode2.transition) {
    root.transition = vnode2.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const {
    props: prevProps,
    children: prevChildren,
    component
  } = prevVNode;
  const {
    props: nextProps,
    children: nextChildren,
    patchFlag
  } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({
  vnode: vnode2,
  parent
}, el2) {
  while (parent && parent.subTree === vnode2) {
    (vnode2 = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [getter(), isMultiSource ? [] : void 0, onCleanup]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function withDirectives(vnode2, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode2;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode2.dirs || (vnode2.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode2;
}
function invokeDirectiveHook(vnode2, prevVNode, instance, name) {
  const bindings = vnode2.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [vnode2.el, binding, vnode2, prevVNode]);
      resetTracking();
    }
  }
}
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({
      name: options.name
    }, extraOptions, {
      setup: options
    }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode2) => vnode2.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks2 = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks2.unshift(wrappedHook);
    } else {
      hooks2.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve$1(instance[type] || Component[type], name) || // global registration
      resolve$1(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve$1(registry2, name) {
  return registry2 && (registry2[name] || registry2[camelize(name)] || registry2[capitalize(camelize(name))]);
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({
    _: instance
  }, key) {
    const {
      ctx,
      setupState,
      data,
      props,
      accessCache,
      type,
      appContext
    } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({
    _: instance
  }, key, value) {
    const {
      data,
      setupState,
      ctx
    } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: {
      data,
      setupState,
      accessCache,
      ctx,
      appContext,
      propsOptions
    }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce((normalized, p2) => (normalized[p2] = null, normalized), {}) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const {
    mixins,
    extends: extendsOptions
  } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: {
      optionMergeStrategies
    }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const {
    mixins,
    extends: extendsOptions
  } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode2 = createVNode(rootComponent, rootProps);
          vnode2.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode2, rootContainer);
          } else {
            render(vnode2, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode2.component) || vnode2.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps$1(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: {
      patchFlag
    }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const {
          propsDefaults
        } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? {
          type: opt
        } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const {
    vnode: vnode2,
    slots
  } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode2.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode2, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode2, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode2) && !isUnmount) {
    return;
  }
  const refValue = vnode2.shapeFlag & 4 ? getExposeProxy(vnode2.component) || vnode2.component.proxy : vnode2.el;
  const value = isUnmount ? null : refValue;
  const {
    i: owner,
    r: ref
  } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor2 = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor2 = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const {
      type,
      ref,
      shapeFlag
    } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor2);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor2);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor2, isSVG);
        }
        break;
      case Fragment$1:
        processFragment(n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor2) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor2);
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor2) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor2);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor2, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor2, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({
    el: el2,
    anchor: anchor2
  }, container, nextSibling2) => {
    let next;
    while (el2 && el2 !== anchor2) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling2);
      el2 = next;
    }
    hostInsert(anchor2, container, nextSibling2);
  };
  const removeStaticNode = ({
    el: el2,
    anchor: anchor2
  }) => {
    let next;
    while (el2 && el2 !== anchor2) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor2);
  };
  const processElement = (n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const {
      type,
      props,
      shapeFlag,
      transition,
      dirs
    } = vnode2;
    el2 = vnode2.el = hostCreateElement(vnode2.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode2.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode2.children, el2, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode2, null, parentComponent, "created");
    }
    setScopeId(el2, vnode2, vnode2.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el2, key, null, props[key], isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode2);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode2, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor2);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode2);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode2, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode2, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode2 === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el2, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let {
      patchFlag,
      dynamicChildren,
      dirs
    } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el2, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el2, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment$1 || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el2, vnode2, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el2, key, oldProps[key], null, isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, isSVG, vnode2.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let {
      patchFlag,
      dynamicChildren,
      slotScopeIds: fragmentSlotScopeIds
    } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor2);
      hostInsert(fragmentEndAnchor, container, anchor2);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor2, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor2, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor2, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor2);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor2, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor2, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const {
          el: el2,
          props
        } = initialVNode;
        const {
          bm,
          m,
          parent
        } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el2, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor2, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor2 = null;
      } else {
        let {
          next,
          bu,
          u,
          parent,
          vnode: vnode2
        } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode2.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode2;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode2);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode2), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps$1(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const {
      patchFlag,
      shapeFlag
    } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor2 = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move2(nextChild, container, anchor2, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move2 = (vnode2, container, anchor2, moveType, parentSuspense = null) => {
    const {
      el: el2,
      type,
      transition,
      children,
      shapeFlag
    } = vnode2;
    if (shapeFlag & 6) {
      move2(vnode2.component.subTree, container, anchor2, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode2.suspense.move(container, anchor2, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode2, container, anchor2, internals);
      return;
    }
    if (type === Fragment$1) {
      hostInsert(el2, container, anchor2);
      for (let i = 0; i < children.length; i++) {
        move2(children[i], container, anchor2, moveType);
      }
      hostInsert(vnode2.anchor, container, anchor2);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode2, container, anchor2);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor2);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const {
          leave,
          delayLeave,
          afterLeave
        } = transition;
        const remove22 = () => hostInsert(el2, container, anchor2);
        const performLeave = () => {
          leave(el2, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor2);
    }
  };
  const unmount = (vnode2, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode2;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode2, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode2);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode2);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode2);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode2.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode2.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode2, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode2.type.remove(vnode2, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode2);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode2);
        shouldInvokeDirs && invokeDirectiveHook(vnode2, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode2) => {
    const {
      type,
      el: el2,
      anchor: anchor2,
      transition
    } = vnode2;
    if (type === Fragment$1) {
      {
        removeFragment(el2, anchor2);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode2);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode2.shapeFlag & 1 && transition && !transition.persisted) {
      const {
        leave,
        delayLeave
      } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode2.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      update,
      subTree,
      um
    } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode2) => {
    if (vnode2.shapeFlag & 6) {
      return getNextHostNode(vnode2.component.subTree);
    }
    if (vnode2.shapeFlag & 128) {
      return vnode2.suspense.next();
    }
    return hostNextSibling(vnode2.anchor || vnode2.el);
  };
  const render = (vnode2, container, isSVG) => {
    if (vnode2 == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode2, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode2;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move2,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({
  effect,
  update
}, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment$1 = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode2) {
  vnode2.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode2);
  }
  return vnode2;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    true
    /* isBlock */
  ));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true
    /* isBlock: prevent a block from tracking itself */
  ));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({
  key
}) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? {
    i: currentRenderingInstance,
    r: ref,
    k: ref_key,
    f: !!ref_for
  } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode2 = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode2, children);
    if (shapeFlag & 128) {
      type.normalize(vnode2);
    }
  } else if (children) {
    vnode2.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode2.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode2.patchFlag !== 32) {
    currentBlock.push(vnode2);
  }
  return vnode2;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let {
      class: klass,
      style
    } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode2, extraProps, mergeRef = false) {
  const {
    props,
    ref,
    patchFlag,
    children
  } = vnode2;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode2.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode2.scopeId,
    slotScopeIds: vnode2.slotScopeIds,
    children,
    target: vnode2.target,
    targetAnchor: vnode2.targetAnchor,
    staticCount: vnode2.staticCount,
    shapeFlag: vnode2.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode2.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode2.dynamicProps,
    dynamicChildren: vnode2.dynamicChildren,
    appContext: vnode2.appContext,
    dirs: vnode2.dirs,
    transition: vnode2.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode2.component,
    suspense: vnode2.suspense,
    ssContent: vnode2.ssContent && cloneVNode(vnode2.ssContent),
    ssFallback: vnode2.ssFallback && cloneVNode(vnode2.ssFallback),
    el: vnode2.el,
    anchor: vnode2.anchor,
    ctx: vnode2.ctx,
    ce: vnode2.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment$1,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode2, children) {
  let type = 0;
  const {
    shapeFlag
  } = vnode2;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode2, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode2.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode2.children = children;
  vnode2.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode2, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [vnode2, prevVNode]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode2, parent, suspense) {
  const type = vnode2.type;
  const appContext = (parent ? parent.appContext : vnode2.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode: vnode2,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = {
      _: instance
    };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode2.ce) {
    vnode2.ce(instance);
  }
  return instance;
}
let currentInstance = null;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const {
    props,
    children
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const {
    setup
  } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const {
          isCustomElement,
          compilerOptions
        } = instance.appContext.config;
        const {
          delimiters,
          compilerOptions: componentCompilerOptions
        } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor2) => {
    parent.insertBefore(child, anchor2 || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is
    } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor2, isSVG, start, end) {
    const before = anchor2 ? anchor2.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor2);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor2);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor2 ? anchor2.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style = el2.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS$1 = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS$1, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS$1, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  const tag = el2.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el2._value = value;
    const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
  }
  needRemove && el2.removeAttribute(key);
}
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el2;
}
const getModelAssigner = (vnode2) => {
  const fn = vnode2.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el2, {
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode2) {
    el2._assign = getModelAssigner(vnode2);
    const castToNumber = number || vnode2.props && vnode2.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el2.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el2._assign(domValue);
    });
    if (trim) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el2, {
    value
  }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, {
    value,
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode2) {
    el2._assign = getModelAssigner(vnode2);
    if (el2.composing)
      return;
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el2.value.trim() === value) {
        return;
      }
      if ((number || el2.type === "number") && looseToNumber(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el2, _, vnode2) {
    el2._assign = getModelAssigner(vnode2);
    addEventListener(el2, "change", () => {
      const modelValue = el2._modelValue;
      const elementValue = getValue(el2);
      const checked = el2.checked;
      const assign = el2._assign;
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el2, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el2, binding, vnode2) {
    el2._assign = getModelAssigner(vnode2);
    setChecked(el2, binding, vnode2);
  }
};
function setChecked(el2, {
  value,
  oldValue
}, vnode2) {
  el2._modelValue = value;
  if (isArray(value)) {
    el2.checked = looseIndexOf(value, vnode2.props.value) > -1;
  } else if (isSet(value)) {
    el2.checked = value.has(vnode2.props.value);
  } else if (value !== oldValue) {
    el2.checked = looseEqual(value, getCheckboxValue(el2, true));
  }
}
function getValue(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
function getCheckboxValue(el2, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el2 ? el2[key] : checked;
}
const rendererOptions = /* @__PURE__ */ extend({
  patchProp
}, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const {
    mount
  } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const sprotty = "";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", {
    value: true
  });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(Reflect2) {
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect2);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect2;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, {
            configurable: true,
            writable: true,
            value
          });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = {
      __proto__: []
    } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({
          __proto__: null
        });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn2.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn2.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata2 = new _WeakMap();
    function decorate2(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate2);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata2.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata2.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata2.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata2.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        true
      );
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys2 = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys2;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys2;
      if (ownKeys2.length <= 0)
        return parentKeys;
      var set2 = new _Set();
      var keys2 = [];
      for (var _i = 0, ownKeys_1 = ownKeys2; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys2.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys2.push(key);
        }
      }
      return keys2;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys2 = [];
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return keys2;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys2.length = k;
          return keys2;
        }
        var nextValue = IteratorValue(next);
        try {
          keys2[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys2, values, selector) {
            this._index = 0;
            this._keys = keys2;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return {
                value: result,
                done: false
              };
            }
            return {
              value: void 0,
              done: true
            };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return {
              value,
              done: true
            };
          };
          return MapIterator2;
        }()
      );
      return (
        /** @class */
        function() {
          function Map2() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map2.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map2.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map2.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map2.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size2 = this._keys.length;
              for (var i = index + 1; i < size2; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map2.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map2.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map2.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue2);
          };
          Map2.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map2.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map2.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map2.prototype._find = function(key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map2;
        }()
      );
      function getKey(key, _) {
        return key;
      }
      function getValue2(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        function() {
          function Set2() {
            this._map = new _Map();
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set2.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set2.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set2.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set2.prototype.clear = function() {
            this._map.clear();
          };
          Set2.prototype.keys = function() {
            return this._map.keys();
          };
          Set2.prototype.values = function() {
            return this._map.values();
          };
          Set2.prototype.entries = function() {
            return this._map.entries();
          };
          Set2.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set2.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set2;
        }()
      );
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys2 = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys2, key));
        keys2[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create2) {
        if (!hasOwn2.call(target, rootKey)) {
          if (!create2)
            return void 0;
          Object.defineProperty(target, rootKey, {
            value: HashMap.create()
          });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size2) {
        for (var i = 0; i < size2; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size2) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size2));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size2));
          return FillRandomBytes(new Uint8Array(size2), size2);
        }
        return FillRandomBytes(new Array(size2), size2);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect$1 || (Reflect$1 = {}));
var lib$1 = {};
var action = {};
Object.defineProperty(action, "__esModule", {
  value: true
});
action.isLabeledAction = action.LabeledAction = void 0;
class LabeledAction {
  constructor(label, actions2, icon) {
    this.label = label;
    this.actions = actions2;
    this.icon = icon;
  }
}
action.LabeledAction = LabeledAction;
function isLabeledAction(element) {
  return element !== void 0 && element.label !== void 0 && element.actions !== void 0;
}
action.isLabeledAction = isLabeledAction;
var actionDispatcher = {};
var NAMED_TAG = "named";
var NAME_TAG = "name";
var UNMANAGED_TAG = "unmanaged";
var OPTIONAL_TAG = "optional";
var INJECT_TAG = "inject";
var MULTI_INJECT_TAG = "multi_inject";
var TAGGED = "inversify:tagged";
var TAGGED_PROP = "inversify:tagged_props";
var PARAM_TYPES = "inversify:paramtypes";
var DESIGN_PARAM_TYPES = "design:paramtypes";
var POST_CONSTRUCT = "post_construct";
var PRE_DESTROY = "pre_destroy";
function getNonCustomTagKeys() {
  return [INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, UNMANAGED_TAG, NAMED_TAG, OPTIONAL_TAG];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
const keys = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DESIGN_PARAM_TYPES,
  INJECT_TAG,
  MULTI_INJECT_TAG,
  NAMED_TAG,
  NAME_TAG,
  NON_CUSTOM_TAG_KEYS,
  OPTIONAL_TAG,
  PARAM_TYPES,
  POST_CONSTRUCT,
  PRE_DESTROY,
  TAGGED,
  TAGGED_PROP,
  UNMANAGED_TAG
}, Symbol.toStringTag, { value: "Module" }));
var BindingScopeEnum = {
  Request: "Request",
  Singleton: "Singleton",
  Transient: "Transient"
};
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};
var TargetTypeEnum = {
  ClassProperty: "ClassProperty",
  ConstructorArgument: "ConstructorArgument",
  Variable: "Variable"
};
var idCounter = 0;
function id() {
  return idCounter++;
}
var Binding = function() {
  function Binding2(serviceIdentifier, scope) {
    this.id = id();
    this.activated = false;
    this.serviceIdentifier = serviceIdentifier;
    this.scope = scope;
    this.type = BindingTypeEnum.Invalid;
    this.constraint = function(request) {
      return true;
    };
    this.implementationType = null;
    this.cache = null;
    this.factory = null;
    this.provider = null;
    this.onActivation = null;
    this.onDeactivation = null;
    this.dynamicValue = null;
  }
  Binding2.prototype.clone = function() {
    var clone = new Binding2(this.serviceIdentifier, this.scope);
    clone.activated = clone.scope === BindingScopeEnum.Singleton ? this.activated : false;
    clone.implementationType = this.implementationType;
    clone.dynamicValue = this.dynamicValue;
    clone.scope = this.scope;
    clone.type = this.type;
    clone.factory = this.factory;
    clone.provider = this.provider;
    clone.constraint = this.constraint;
    clone.onActivation = this.onActivation;
    clone.onDeactivation = this.onDeactivation;
    clone.cache = this.cache;
    return clone;
  };
  return Binding2;
}();
var DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
var DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
var NULL_ARGUMENT = "NULL argument";
var KEY_NOT_FOUND = "Key Not Found";
var AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
var CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
var NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
var MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
var MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
var UNDEFINED_INJECT_ANNOTATION = function(name) {
  return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation.";
};
var CIRCULAR_DEPENDENCY = "Circular dependency found:";
var INVALID_BINDING_TYPE = "Invalid binding type:";
var NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
var INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
var INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
var LAZY_IN_SYNC = function(key) {
  return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies.";
};
var INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
var INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
var ARGUMENTS_LENGTH_MISMATCH = function() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
};
var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must be a string ("singleton" or "transient").';
var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
var MULTIPLE_PRE_DESTROY_METHODS = "Cannot apply @preDestroy decorator multiple times in the same class";
var MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
var ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
var POST_CONSTRUCT_ERROR = function(clazz, errorMessage) {
  return "@postConstruct error in class " + clazz + ": " + errorMessage;
};
var PRE_DESTROY_ERROR = function(clazz, errorMessage) {
  return "@preDestroy error in class " + clazz + ": " + errorMessage;
};
var ON_DEACTIVATION_ERROR = function(clazz, errorMessage) {
  return "onDeactivation() error in class " + clazz + ": " + errorMessage;
};
var CIRCULAR_DEPENDENCY_IN_FACTORY = function(factoryType, serviceIdentifier) {
  return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with " + ("service identifier '" + serviceIdentifier + "'.");
};
var STACK_OVERFLOW = "Maximum call stack size exceeded";
var MetadataReader = function() {
  function MetadataReader2() {
  }
  MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
    var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc);
    var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc);
    return {
      compilerGeneratedMetadata,
      userGeneratedMetadata: userGeneratedMetadata || {}
    };
  };
  MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
    var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
    return userGeneratedMetadata;
  };
  return MetadataReader2;
}();
var BindingCount = {
  MultipleBindingsAvailable: 2,
  NoBindingsAvailable: 0,
  OnlyOneBindingAvailable: 1
};
function isStackOverflowExeption(error) {
  return error instanceof RangeError || error.message === STACK_OVERFLOW;
}
var tryAndThrowErrorIfStackOverflow = function(fn, errorCallback) {
  try {
    return fn();
  } catch (error) {
    if (isStackOverflowExeption(error)) {
      error = errorCallback();
    }
    throw error;
  }
};
function getServiceIdentifierAsString(serviceIdentifier) {
  if (typeof serviceIdentifier === "function") {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier.name;
  } else if (typeof serviceIdentifier === "symbol") {
    return serviceIdentifier.toString();
  } else {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier;
  }
}
function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings2) {
  var registeredBindingsList = "";
  var registeredBindings = getBindings2(container, serviceIdentifier);
  if (registeredBindings.length !== 0) {
    registeredBindingsList = "\nRegistered bindings:";
    registeredBindings.forEach(function(binding) {
      var name = "Object";
      if (binding.implementationType !== null) {
        name = getFunctionName(binding.implementationType);
      }
      registeredBindingsList = registeredBindingsList + "\n " + name;
      if (binding.constraint.metaData) {
        registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
      }
    });
  }
  return registeredBindingsList;
}
function alreadyDependencyChain(request, serviceIdentifier) {
  if (request.parentRequest === null) {
    return false;
  } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
    return true;
  } else {
    return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
  }
}
function dependencyChainToString(request) {
  function _createStringArr(req, result) {
    if (result === void 0) {
      result = [];
    }
    var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
    result.push(serviceIdentifier);
    if (req.parentRequest !== null) {
      return _createStringArr(req.parentRequest, result);
    }
    return result;
  }
  var stringArr = _createStringArr(request);
  return stringArr.reverse().join(" --> ");
}
function circularDependencyToException(request) {
  request.childRequests.forEach(function(childRequest) {
    if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = dependencyChainToString(childRequest);
      throw new Error(CIRCULAR_DEPENDENCY + " " + services);
    } else {
      circularDependencyToException(childRequest);
    }
  });
}
function listMetadataForTarget(serviceIdentifierString, target) {
  if (target.isTagged() || target.isNamed()) {
    var m_1 = "";
    var namedTag = target.getNamedTag();
    var otherTags = target.getCustomTags();
    if (namedTag !== null) {
      m_1 += namedTag.toString() + "\n";
    }
    if (otherTags !== null) {
      otherTags.forEach(function(tag) {
        m_1 += tag.toString() + "\n";
      });
    }
    return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
  } else {
    return " " + serviceIdentifierString;
  }
}
function getFunctionName(func) {
  if (func.name) {
    return func.name;
  } else {
    var name_1 = func.toString();
    var match = name_1.match(/^function\s*([^\s(]+)/);
    return match ? match[1] : "Anonymous function: " + name_1;
  }
}
function getSymbolDescription(symbol) {
  return symbol.toString().slice(7, -1);
}
var Context = function() {
  function Context2(container) {
    this.id = id();
    this.container = container;
  }
  Context2.prototype.addPlan = function(plan2) {
    this.plan = plan2;
  };
  Context2.prototype.setCurrentRequest = function(currentRequest) {
    this.currentRequest = currentRequest;
  };
  return Context2;
}();
var Metadata = function() {
  function Metadata2(key, value) {
    this.key = key;
    this.value = value;
  }
  Metadata2.prototype.toString = function() {
    if (this.key === NAMED_TAG) {
      return "named: " + String(this.value).toString() + " ";
    } else {
      return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
    }
  };
  return Metadata2;
}();
var Plan = function() {
  function Plan2(parentContext, rootRequest) {
    this.parentContext = parentContext;
    this.rootRequest = rootRequest;
  }
  return Plan2;
}();
var LazyServiceIdentifier = function() {
  function LazyServiceIdentifier2(cb) {
    this._cb = cb;
  }
  LazyServiceIdentifier2.prototype.unwrap = function() {
    return this._cb();
  };
  return LazyServiceIdentifier2;
}();
var QueryableString = function() {
  function QueryableString2(str) {
    this.str = str;
  }
  QueryableString2.prototype.startsWith = function(searchString) {
    return this.str.indexOf(searchString) === 0;
  };
  QueryableString2.prototype.endsWith = function(searchString) {
    var reverseString = "";
    var reverseSearchString = searchString.split("").reverse().join("");
    reverseString = this.str.split("").reverse().join("");
    return this.startsWith.call({
      str: reverseString
    }, reverseSearchString);
  };
  QueryableString2.prototype.contains = function(searchString) {
    return this.str.indexOf(searchString) !== -1;
  };
  QueryableString2.prototype.equals = function(compareString) {
    return this.str === compareString;
  };
  QueryableString2.prototype.value = function() {
    return this.str;
  };
  return QueryableString2;
}();
var Target = function() {
  function Target2(type, identifier, serviceIdentifier, namedOrTagged) {
    this.id = id();
    this.type = type;
    this.serviceIdentifier = serviceIdentifier;
    var queryableName = typeof identifier === "symbol" ? getSymbolDescription(identifier) : identifier;
    this.name = new QueryableString(queryableName || "");
    this.identifier = identifier;
    this.metadata = new Array();
    var metadataItem = null;
    if (typeof namedOrTagged === "string") {
      metadataItem = new Metadata(NAMED_TAG, namedOrTagged);
    } else if (namedOrTagged instanceof Metadata) {
      metadataItem = namedOrTagged;
    }
    if (metadataItem !== null) {
      this.metadata.push(metadataItem);
    }
  }
  Target2.prototype.hasTag = function(key) {
    for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
      var m = _a[_i];
      if (m.key === key) {
        return true;
      }
    }
    return false;
  };
  Target2.prototype.isArray = function() {
    return this.hasTag(MULTI_INJECT_TAG);
  };
  Target2.prototype.matchesArray = function(name) {
    return this.matchesTag(MULTI_INJECT_TAG)(name);
  };
  Target2.prototype.isNamed = function() {
    return this.hasTag(NAMED_TAG);
  };
  Target2.prototype.isTagged = function() {
    return this.metadata.some(function(metadata) {
      return NON_CUSTOM_TAG_KEYS.every(function(key) {
        return metadata.key !== key;
      });
    });
  };
  Target2.prototype.isOptional = function() {
    return this.matchesTag(OPTIONAL_TAG)(true);
  };
  Target2.prototype.getNamedTag = function() {
    if (this.isNamed()) {
      return this.metadata.filter(function(m) {
        return m.key === NAMED_TAG;
      })[0];
    }
    return null;
  };
  Target2.prototype.getCustomTags = function() {
    if (this.isTagged()) {
      return this.metadata.filter(function(metadata) {
        return NON_CUSTOM_TAG_KEYS.every(function(key) {
          return metadata.key !== key;
        });
      });
    } else {
      return null;
    }
  };
  Target2.prototype.matchesNamedTag = function(name) {
    return this.matchesTag(NAMED_TAG)(name);
  };
  Target2.prototype.matchesTag = function(key) {
    var _this = this;
    return function(value) {
      for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
        var m = _a[_i];
        if (m.key === key && m.value === value) {
          return true;
        }
      }
      return false;
    };
  };
  return Target2;
}();
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function getDependencies(metadataReader, func) {
  var constructorName = getFunctionName(func);
  return getTargets(metadataReader, constructorName, func, false);
}
function getTargets(metadataReader, constructorName, func, isBaseClass) {
  var metadata = metadataReader.getConstructorMetadata(func);
  var serviceIdentifiers = metadata.compilerGeneratedMetadata;
  if (serviceIdentifiers === void 0) {
    var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
    throw new Error(msg);
  }
  var constructorArgsMetadata = metadata.userGeneratedMetadata;
  var keys2 = Object.keys(constructorArgsMetadata);
  var hasUserDeclaredUnknownInjections = func.length === 0 && keys2.length > 0;
  var hasOptionalParameters = keys2.length > func.length;
  var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys2.length : func.length;
  var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
  var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
  var targets = __spreadArray$2(__spreadArray$2([], constructorTargets, true), propertyTargets, true);
  return targets;
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
  var targetMetadata = constructorArgsMetadata[index.toString()] || [];
  var metadata = formatTargetMetadata(targetMetadata);
  var isManaged = metadata.unmanaged !== true;
  var serviceIdentifier = serviceIdentifiers[index];
  var injectIdentifier = metadata.inject || metadata.multiInject;
  serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
  if (serviceIdentifier instanceof LazyServiceIdentifier) {
    serviceIdentifier = serviceIdentifier.unwrap();
  }
  if (isManaged) {
    var isObject2 = serviceIdentifier === Object;
    var isFunction2 = serviceIdentifier === Function;
    var isUndefined = serviceIdentifier === void 0;
    var isUnknownType = isObject2 || isFunction2 || isUndefined;
    if (!isBaseClass && isUnknownType) {
      var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
      throw new Error(msg);
    }
    var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
    target.metadata = targetMetadata;
    return target;
  }
  return null;
}
function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
  var targets = [];
  for (var i = 0; i < iterations; i++) {
    var index = i;
    var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
    if (target !== null) {
      targets.push(target);
    }
  }
  return targets;
}
function _getServiceIdentifierForProperty(inject2, multiInject2, propertyName, className) {
  var serviceIdentifier = inject2 || multiInject2;
  if (serviceIdentifier === void 0) {
    var msg = MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
    throw new Error(msg);
  }
  return serviceIdentifier;
}
function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
  var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
  var targets = [];
  var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
  var stringKeys = Object.keys(classPropsMetadata);
  var keys2 = stringKeys.concat(symbolKeys);
  for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    var targetMetadata = classPropsMetadata[key];
    var metadata = formatTargetMetadata(targetMetadata);
    var identifier = metadata.targetName || key;
    var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);
    var target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
    target.metadata = targetMetadata;
    targets.push(target);
  }
  var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
    targets = __spreadArray$2(__spreadArray$2([], targets, true), baseTargets, true);
  }
  return targets;
}
function getBaseClassDependencyCount(metadataReader, func) {
  var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseConstructorName = getFunctionName(baseConstructor);
    var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
    var metadata = targets.map(function(t) {
      return t.metadata.filter(function(m) {
        return m.key === UNMANAGED_TAG;
      });
    });
    var unmanagedCount = [].concat.apply([], metadata).length;
    var dependencyCount = targets.length - unmanagedCount;
    if (dependencyCount > 0) {
      return dependencyCount;
    } else {
      return getBaseClassDependencyCount(metadataReader, baseConstructor);
    }
  } else {
    return 0;
  }
}
function formatTargetMetadata(targetMetadata) {
  var targetMetadataMap = {};
  targetMetadata.forEach(function(m) {
    targetMetadataMap[m.key.toString()] = m.value;
  });
  return {
    inject: targetMetadataMap[INJECT_TAG],
    multiInject: targetMetadataMap[MULTI_INJECT_TAG],
    targetName: targetMetadataMap[NAME_TAG],
    unmanaged: targetMetadataMap[UNMANAGED_TAG]
  };
}
var Request = function() {
  function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
    this.id = id();
    this.serviceIdentifier = serviceIdentifier;
    this.parentContext = parentContext;
    this.parentRequest = parentRequest;
    this.target = target;
    this.childRequests = [];
    this.bindings = Array.isArray(bindings) ? bindings : [bindings];
    this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
  }
  Request2.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
    var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target);
    this.childRequests.push(child);
    return child;
  };
  return Request2;
}();
function getBindingDictionary(cntnr) {
  return cntnr._bindingDictionary;
}
function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
  var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG;
  var injectMetadata = new Metadata(metadataKey, serviceIdentifier);
  var target = new Target(targetType, name, serviceIdentifier, injectMetadata);
  if (key !== void 0) {
    var tagMetadata = new Metadata(key, value);
    target.metadata.push(tagMetadata);
  }
  return target;
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
  var bindings = getBindings(context.container, target.serviceIdentifier);
  var activeBindings = [];
  if (bindings.length === BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
    context.container.bind(target.serviceIdentifier).toSelf();
    bindings = getBindings(context.container, target.serviceIdentifier);
  }
  if (!avoidConstraints) {
    activeBindings = bindings.filter(function(binding) {
      var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
      return binding.constraint(request);
    });
  } else {
    activeBindings = bindings;
  }
  _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
  return activeBindings;
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
  switch (bindings.length) {
    case BindingCount.NoBindingsAvailable:
      if (target.isOptional()) {
        return bindings;
      } else {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
        var msg = NOT_REGISTERED;
        msg += listMetadataForTarget(serviceIdentifierString, target);
        msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
        throw new Error(msg);
      }
    case BindingCount.OnlyOneBindingAvailable:
      return bindings;
    case BindingCount.MultipleBindingsAvailable:
    default:
      if (!target.isArray()) {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
        var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
        msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
        throw new Error(msg);
      } else {
        return bindings;
      }
  }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
  var activeBindings;
  var childRequest;
  if (parentRequest === null) {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
    childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
    var thePlan = new Plan(context, childRequest);
    context.addPlan(thePlan);
  } else {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
  }
  activeBindings.forEach(function(binding) {
    var subChildRequest = null;
    if (target.isArray()) {
      subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
    } else {
      if (binding.cache) {
        return;
      }
      subChildRequest = childRequest;
    }
    if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
      var dependencies = getDependencies(metadataReader, binding.implementationType);
      if (!context.container.options.skipBaseClassChecks) {
        var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
        if (dependencies.length < baseClassDependencyCount) {
          var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
          throw new Error(error);
        }
      }
      dependencies.forEach(function(dependency) {
        _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
      });
    }
  });
}
function getBindings(container, serviceIdentifier) {
  var bindings = [];
  var bindingDictionary = getBindingDictionary(container);
  if (bindingDictionary.hasKey(serviceIdentifier)) {
    bindings = bindingDictionary.get(serviceIdentifier);
  } else if (container.parent !== null) {
    bindings = getBindings(container.parent, serviceIdentifier);
  }
  return bindings;
}
function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
  if (avoidConstraints === void 0) {
    avoidConstraints = false;
  }
  var context = new Context(container);
  var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
  try {
    _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
    return context;
  } catch (error) {
    if (isStackOverflowExeption(error)) {
      circularDependencyToException(context.plan.rootRequest);
    }
    throw error;
  }
}
function createMockRequest(container, serviceIdentifier, key, value) {
  var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value));
  var context = new Context(container);
  var request = new Request(serviceIdentifier, context, null, [], target);
  return request;
}
function isPromise(object2) {
  var isObjectOrFunction = typeof object2 === "object" && object2 !== null || typeof object2 === "function";
  return isObjectOrFunction && typeof object2.then === "function";
}
function isPromiseOrContainsPromise(object2) {
  if (isPromise(object2)) {
    return true;
  }
  return Array.isArray(object2) && object2.some(isPromise);
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var tryGetFromScope = function(requestScope, binding) {
  if (binding.scope === BindingScopeEnum.Singleton && binding.activated) {
    return binding.cache;
  }
  if (binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id)) {
    return requestScope.get(binding.id);
  }
  return null;
};
var saveToScope = function(requestScope, binding, result) {
  if (binding.scope === BindingScopeEnum.Singleton) {
    _saveToSingletonScope(binding, result);
  }
  if (binding.scope === BindingScopeEnum.Request) {
    _saveToRequestScope(requestScope, binding, result);
  }
};
var _saveToRequestScope = function(requestScope, binding, result) {
  if (!requestScope.has(binding.id)) {
    requestScope.set(binding.id, result);
  }
};
var _saveToSingletonScope = function(binding, result) {
  binding.cache = result;
  binding.activated = true;
  if (isPromise(result)) {
    void _saveAsyncResultToSingletonScope(binding, result);
  }
};
var _saveAsyncResultToSingletonScope = function(binding, asyncResult) {
  return __awaiter$4(void 0, void 0, void 0, function() {
    var result, ex_1;
    return __generator$3(this, function(_a) {
      switch (_a.label) {
        case 0:
          _a.trys.push([0, 2, , 3]);
          return [4, asyncResult];
        case 1:
          result = _a.sent();
          binding.cache = result;
          return [3, 3];
        case 2:
          ex_1 = _a.sent();
          binding.cache = null;
          binding.activated = false;
          throw ex_1;
        case 3:
          return [2];
      }
    });
  });
};
var FactoryType;
(function(FactoryType2) {
  FactoryType2["DynamicValue"] = "toDynamicValue";
  FactoryType2["Factory"] = "toFactory";
  FactoryType2["Provider"] = "toProvider";
})(FactoryType || (FactoryType = {}));
var multiBindToService = function(container) {
  return function(service) {
    return function() {
      var types2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        types2[_i] = arguments[_i];
      }
      return types2.forEach(function(t) {
        return container.bind(t).toService(service);
      });
    };
  };
};
var ensureFullyBound = function(binding) {
  var boundValue = null;
  switch (binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
      boundValue = binding.cache;
      break;
    case BindingTypeEnum.Constructor:
    case BindingTypeEnum.Instance:
      boundValue = binding.implementationType;
      break;
    case BindingTypeEnum.DynamicValue:
      boundValue = binding.dynamicValue;
      break;
    case BindingTypeEnum.Provider:
      boundValue = binding.provider;
      break;
    case BindingTypeEnum.Factory:
      boundValue = binding.factory;
      break;
  }
  if (boundValue === null) {
    var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier);
    throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
  }
};
var getFactoryDetails = function(binding) {
  switch (binding.type) {
    case BindingTypeEnum.Factory:
      return {
        factory: binding.factory,
        factoryType: FactoryType.Factory
      };
    case BindingTypeEnum.Provider:
      return {
        factory: binding.provider,
        factoryType: FactoryType.Provider
      };
    case BindingTypeEnum.DynamicValue:
      return {
        factory: binding.dynamicValue,
        factoryType: FactoryType.DynamicValue
      };
    default:
      throw new Error("Unexpected factory type " + binding.type);
  }
};
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function _resolveRequests(childRequests, resolveRequest) {
  return childRequests.reduce(function(resolvedRequests, childRequest) {
    var injection = resolveRequest(childRequest);
    var targetType = childRequest.target.type;
    if (targetType === TargetTypeEnum.ConstructorArgument) {
      resolvedRequests.constructorInjections.push(injection);
    } else {
      resolvedRequests.propertyRequests.push(childRequest);
      resolvedRequests.propertyInjections.push(injection);
    }
    if (!resolvedRequests.isAsync) {
      resolvedRequests.isAsync = isPromiseOrContainsPromise(injection);
    }
    return resolvedRequests;
  }, {
    constructorInjections: [],
    propertyInjections: [],
    propertyRequests: [],
    isAsync: false
  });
}
function _createInstance(constr, childRequests, resolveRequest) {
  var result;
  if (childRequests.length > 0) {
    var resolved = _resolveRequests(childRequests, resolveRequest);
    var createInstanceWithInjectionsArg = __assign$1(__assign$1({}, resolved), {
      constr
    });
    if (resolved.isAsync) {
      result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
    } else {
      result = createInstanceWithInjections(createInstanceWithInjectionsArg);
    }
  } else {
    result = new constr();
  }
  return result;
}
function createInstanceWithInjections(args) {
  var _a;
  var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray$1([void 0], args.constructorInjections, false)))();
  args.propertyRequests.forEach(function(r, index) {
    var property = r.target.identifier;
    var injection = args.propertyInjections[index];
    if (!r.target.isOptional() || injection !== void 0) {
      instance[property] = injection;
    }
  });
  return instance;
}
function createInstanceWithInjectionsAsync(args) {
  return __awaiter$3(this, void 0, void 0, function() {
    var constructorInjections, propertyInjections;
    return __generator$2(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, possiblyWaitInjections(args.constructorInjections)];
        case 1:
          constructorInjections = _a.sent();
          return [4, possiblyWaitInjections(args.propertyInjections)];
        case 2:
          propertyInjections = _a.sent();
          return [2, createInstanceWithInjections(__assign$1(__assign$1({}, args), {
            constructorInjections,
            propertyInjections
          }))];
      }
    });
  });
}
function possiblyWaitInjections(possiblePromiseinjections) {
  return __awaiter$3(this, void 0, void 0, function() {
    var injections, _i, possiblePromiseinjections_1, injection;
    return __generator$2(this, function(_a) {
      injections = [];
      for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {
        injection = possiblePromiseinjections_1[_i];
        if (Array.isArray(injection)) {
          injections.push(Promise.all(injection));
        } else {
          injections.push(injection);
        }
      }
      return [2, Promise.all(injections)];
    });
  });
}
function _getInstanceAfterPostConstruct(constr, result) {
  var postConstructResult = _postConstruct(constr, result);
  if (isPromise(postConstructResult)) {
    return postConstructResult.then(function() {
      return result;
    });
  } else {
    return result;
  }
}
function _postConstruct(constr, instance) {
  var _a, _b;
  if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
    var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
    try {
      return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
    } catch (e) {
      if (e instanceof Error) {
        throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message));
      }
    }
  }
}
function _validateInstanceResolution(binding, constr) {
  if (binding.scope !== BindingScopeEnum.Singleton) {
    _throwIfHandlingDeactivation(binding, constr);
  }
}
function _throwIfHandlingDeactivation(binding, constr) {
  var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === BindingScopeEnum.Request ? "request" : "transient") + " scope.";
  if (typeof binding.onDeactivation === "function") {
    throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage));
  }
  if (Reflect.hasMetadata(PRE_DESTROY, constr)) {
    throw new Error(PRE_DESTROY_ERROR(constr.name, scopeErrorMessage));
  }
}
function resolveInstance(binding, constr, childRequests, resolveRequest) {
  _validateInstanceResolution(binding, constr);
  var result = _createInstance(constr, childRequests, resolveRequest);
  if (isPromise(result)) {
    return result.then(function(resolvedResult) {
      return _getInstanceAfterPostConstruct(constr, resolvedResult);
    });
  } else {
    return _getInstanceAfterPostConstruct(constr, result);
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var _resolveRequest = function(requestScope) {
  return function(request) {
    request.parentContext.setCurrentRequest(request);
    var bindings = request.bindings;
    var childRequests = request.childRequests;
    var targetIsAnArray = request.target && request.target.isArray();
    var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
    if (targetIsAnArray && targetParentIsNotAnArray) {
      return childRequests.map(function(childRequest) {
        var _f = _resolveRequest(requestScope);
        return _f(childRequest);
      });
    } else {
      if (request.target.isOptional() && bindings.length === 0) {
        return void 0;
      }
      var binding = bindings[0];
      return _resolveBinding(requestScope, request, binding);
    }
  };
};
var _resolveFactoryFromBinding = function(binding, context) {
  var factoryDetails = getFactoryDetails(binding);
  return tryAndThrowErrorIfStackOverflow(function() {
    return factoryDetails.factory.bind(binding)(context);
  }, function() {
    return new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString()));
  });
};
var _getResolvedFromBinding = function(requestScope, request, binding) {
  var result;
  var childRequests = request.childRequests;
  ensureFullyBound(binding);
  switch (binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
      result = binding.cache;
      break;
    case BindingTypeEnum.Constructor:
      result = binding.implementationType;
      break;
    case BindingTypeEnum.Instance:
      result = resolveInstance(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
      break;
    default:
      result = _resolveFactoryFromBinding(binding, request.parentContext);
  }
  return result;
};
var _resolveInScope = function(requestScope, binding, resolveFromBinding) {
  var result = tryGetFromScope(requestScope, binding);
  if (result !== null) {
    return result;
  }
  result = resolveFromBinding();
  saveToScope(requestScope, binding, result);
  return result;
};
var _resolveBinding = function(requestScope, request, binding) {
  return _resolveInScope(requestScope, binding, function() {
    var result = _getResolvedFromBinding(requestScope, request, binding);
    if (isPromise(result)) {
      result = result.then(function(resolved) {
        return _onActivation(request, binding, resolved);
      });
    } else {
      result = _onActivation(request, binding, result);
    }
    return result;
  });
};
function _onActivation(request, binding, resolved) {
  var result = _bindingActivation(request.parentContext, binding, resolved);
  var containersIterator = _getContainersIterator(request.parentContext.container);
  var container;
  var containersIteratorResult = containersIterator.next();
  do {
    container = containersIteratorResult.value;
    var context_1 = request.parentContext;
    var serviceIdentifier = request.serviceIdentifier;
    var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
    if (isPromise(result)) {
      result = _activateContainerAsync(activationsIterator, context_1, result);
    } else {
      result = _activateContainer(activationsIterator, context_1, result);
    }
    containersIteratorResult = containersIterator.next();
  } while (containersIteratorResult.done !== true && !getBindingDictionary(container).hasKey(request.serviceIdentifier));
  return result;
}
var _bindingActivation = function(context, binding, previousResult) {
  var result;
  if (typeof binding.onActivation === "function") {
    result = binding.onActivation(context, previousResult);
  } else {
    result = previousResult;
  }
  return result;
};
var _activateContainer = function(activationsIterator, context, result) {
  var activation = activationsIterator.next();
  while (!activation.done) {
    result = activation.value(context, result);
    if (isPromise(result)) {
      return _activateContainerAsync(activationsIterator, context, result);
    }
    activation = activationsIterator.next();
  }
  return result;
};
var _activateContainerAsync = function(activationsIterator, context, resultPromise) {
  return __awaiter$2(void 0, void 0, void 0, function() {
    var result, activation;
    return __generator$1(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, resultPromise];
        case 1:
          result = _a.sent();
          activation = activationsIterator.next();
          _a.label = 2;
        case 2:
          if (!!activation.done)
            return [3, 4];
          return [4, activation.value(context, result)];
        case 3:
          result = _a.sent();
          activation = activationsIterator.next();
          return [3, 2];
        case 4:
          return [2, result];
      }
    });
  });
};
var _getContainerActivationsForService = function(container, serviceIdentifier) {
  var activations = container._activations;
  return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
};
var _getContainersIterator = function(container) {
  var containersStack = [container];
  var parent = container.parent;
  while (parent !== null) {
    containersStack.push(parent);
    parent = parent.parent;
  }
  var getNextContainer = function() {
    var nextContainer = containersStack.pop();
    if (nextContainer !== void 0) {
      return {
        done: false,
        value: nextContainer
      };
    } else {
      return {
        done: true,
        value: void 0
      };
    }
  };
  var containersIterator = {
    next: getNextContainer
  };
  return containersIterator;
};
function resolve(context) {
  var _f = _resolveRequest(context.plan.rootRequest.requestScope);
  return _f(context.plan.rootRequest);
}
var traverseAncerstors = function(request, constraint) {
  var parent = request.parentRequest;
  if (parent !== null) {
    return constraint(parent) ? true : traverseAncerstors(parent, constraint);
  } else {
    return false;
  }
};
var taggedConstraint = function(key) {
  return function(value) {
    var constraint = function(request) {
      return request !== null && request.target !== null && request.target.matchesTag(key)(value);
    };
    constraint.metaData = new Metadata(key, value);
    return constraint;
  };
};
var namedConstraint = taggedConstraint(NAMED_TAG);
var typeConstraint = function(type) {
  return function(request) {
    var binding = null;
    if (request !== null) {
      binding = request.bindings[0];
      if (typeof type === "string") {
        var serviceIdentifier = binding.serviceIdentifier;
        return serviceIdentifier === type;
      } else {
        var constructor = request.bindings[0].implementationType;
        return type === constructor;
      }
    }
    return false;
  };
};
var BindingWhenSyntax = function() {
  function BindingWhenSyntax2(binding) {
    this._binding = binding;
  }
  BindingWhenSyntax2.prototype.when = function(constraint) {
    this._binding.constraint = constraint;
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
    this._binding.constraint = namedConstraint(name);
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
    this._binding.constraint = function(request) {
      if (request === null) {
        return false;
      }
      var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
      return targetIsDefault;
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
    this._binding.constraint = taggedConstraint(tag)(value);
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
    this._binding.constraint = function(request) {
      return request !== null && typeConstraint(parent)(request.parentRequest);
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
    this._binding.constraint = function(request) {
      return request !== null && namedConstraint(name)(request.parentRequest);
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
    this._binding.constraint = function(request) {
      return request !== null && taggedConstraint(tag)(value)(request.parentRequest);
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
    this._binding.constraint = function(request) {
      return request !== null && traverseAncerstors(request, typeConstraint(ancestor));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
    this._binding.constraint = function(request) {
      return request !== null && !traverseAncerstors(request, typeConstraint(ancestor));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
    this._binding.constraint = function(request) {
      return request !== null && traverseAncerstors(request, namedConstraint(name));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
    this._binding.constraint = function(request) {
      return request !== null && !traverseAncerstors(request, namedConstraint(name));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
    this._binding.constraint = function(request) {
      return request !== null && traverseAncerstors(request, taggedConstraint(tag)(value));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
    this._binding.constraint = function(request) {
      return request !== null && !traverseAncerstors(request, taggedConstraint(tag)(value));
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
    this._binding.constraint = function(request) {
      return request !== null && traverseAncerstors(request, constraint);
    };
    return new BindingOnSyntax(this._binding);
  };
  BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
    this._binding.constraint = function(request) {
      return request !== null && !traverseAncerstors(request, constraint);
    };
    return new BindingOnSyntax(this._binding);
  };
  return BindingWhenSyntax2;
}();
var BindingOnSyntax = function() {
  function BindingOnSyntax2(binding) {
    this._binding = binding;
  }
  BindingOnSyntax2.prototype.onActivation = function(handler) {
    this._binding.onActivation = handler;
    return new BindingWhenSyntax(this._binding);
  };
  BindingOnSyntax2.prototype.onDeactivation = function(handler) {
    this._binding.onDeactivation = handler;
    return new BindingWhenSyntax(this._binding);
  };
  return BindingOnSyntax2;
}();
var BindingWhenOnSyntax = function() {
  function BindingWhenOnSyntax2(binding) {
    this._binding = binding;
    this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
    this._bindingOnSyntax = new BindingOnSyntax(this._binding);
  }
  BindingWhenOnSyntax2.prototype.when = function(constraint) {
    return this._bindingWhenSyntax.when(constraint);
  };
  BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
    return this._bindingWhenSyntax.whenTargetNamed(name);
  };
  BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  };
  BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value);
  };
  BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent);
  };
  BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
    return this._bindingWhenSyntax.whenParentNamed(name);
  };
  BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value);
  };
  BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
  };
  BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
  };
  BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
  };
  BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
  };
  BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name);
  };
  BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
  };
  BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
  };
  BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
  };
  BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
    return this._bindingOnSyntax.onActivation(handler);
  };
  BindingWhenOnSyntax2.prototype.onDeactivation = function(handler) {
    return this._bindingOnSyntax.onDeactivation(handler);
  };
  return BindingWhenOnSyntax2;
}();
var BindingInSyntax = function() {
  function BindingInSyntax2(binding) {
    this._binding = binding;
  }
  BindingInSyntax2.prototype.inRequestScope = function() {
    this._binding.scope = BindingScopeEnum.Request;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingInSyntax2.prototype.inSingletonScope = function() {
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingInSyntax2.prototype.inTransientScope = function() {
    this._binding.scope = BindingScopeEnum.Transient;
    return new BindingWhenOnSyntax(this._binding);
  };
  return BindingInSyntax2;
}();
var BindingInWhenOnSyntax = function() {
  function BindingInWhenOnSyntax2(binding) {
    this._binding = binding;
    this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
    this._bindingOnSyntax = new BindingOnSyntax(this._binding);
    this._bindingInSyntax = new BindingInSyntax(binding);
  }
  BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
    return this._bindingInSyntax.inRequestScope();
  };
  BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
    return this._bindingInSyntax.inSingletonScope();
  };
  BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
    return this._bindingInSyntax.inTransientScope();
  };
  BindingInWhenOnSyntax2.prototype.when = function(constraint) {
    return this._bindingWhenSyntax.when(constraint);
  };
  BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
    return this._bindingWhenSyntax.whenTargetNamed(name);
  };
  BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
    return this._bindingWhenSyntax.whenTargetIsDefault();
  };
  BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value);
  };
  BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent);
  };
  BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
    return this._bindingWhenSyntax.whenParentNamed(name);
  };
  BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value);
  };
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
  };
  BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
  };
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
  };
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
  };
  BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name);
  };
  BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
  };
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
  };
  BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
  };
  BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
    return this._bindingOnSyntax.onActivation(handler);
  };
  BindingInWhenOnSyntax2.prototype.onDeactivation = function(handler) {
    return this._bindingOnSyntax.onDeactivation(handler);
  };
  return BindingInWhenOnSyntax2;
}();
var BindingToSyntax = function() {
  function BindingToSyntax2(binding) {
    this._binding = binding;
  }
  BindingToSyntax2.prototype.to = function(constructor) {
    this._binding.type = BindingTypeEnum.Instance;
    this._binding.implementationType = constructor;
    return new BindingInWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toSelf = function() {
    if (typeof this._binding.serviceIdentifier !== "function") {
      throw new Error("" + INVALID_TO_SELF_VALUE);
    }
    var self2 = this._binding.serviceIdentifier;
    return this.to(self2);
  };
  BindingToSyntax2.prototype.toConstantValue = function(value) {
    this._binding.type = BindingTypeEnum.ConstantValue;
    this._binding.cache = value;
    this._binding.dynamicValue = null;
    this._binding.implementationType = null;
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toDynamicValue = function(func) {
    this._binding.type = BindingTypeEnum.DynamicValue;
    this._binding.cache = null;
    this._binding.dynamicValue = func;
    this._binding.implementationType = null;
    return new BindingInWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toConstructor = function(constructor) {
    this._binding.type = BindingTypeEnum.Constructor;
    this._binding.implementationType = constructor;
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toFactory = function(factory) {
    this._binding.type = BindingTypeEnum.Factory;
    this._binding.factory = factory;
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toFunction = function(func) {
    if (typeof func !== "function") {
      throw new Error(INVALID_FUNCTION_BINDING);
    }
    var bindingWhenOnSyntax = this.toConstantValue(func);
    this._binding.type = BindingTypeEnum.Function;
    this._binding.scope = BindingScopeEnum.Singleton;
    return bindingWhenOnSyntax;
  };
  BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
    this._binding.type = BindingTypeEnum.Factory;
    this._binding.factory = function(context) {
      var autofactory = function() {
        return context.container.get(serviceIdentifier);
      };
      return autofactory;
    };
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toAutoNamedFactory = function(serviceIdentifier) {
    this._binding.type = BindingTypeEnum.Factory;
    this._binding.factory = function(context) {
      return function(named2) {
        return context.container.getNamed(serviceIdentifier, named2);
      };
    };
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toProvider = function(provider) {
    this._binding.type = BindingTypeEnum.Provider;
    this._binding.provider = provider;
    this._binding.scope = BindingScopeEnum.Singleton;
    return new BindingWhenOnSyntax(this._binding);
  };
  BindingToSyntax2.prototype.toService = function(service) {
    this.toDynamicValue(function(context) {
      return context.container.get(service);
    });
  };
  return BindingToSyntax2;
}();
var ContainerSnapshot = function() {
  function ContainerSnapshot2() {
  }
  ContainerSnapshot2.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
    var snapshot = new ContainerSnapshot2();
    snapshot.bindings = bindings;
    snapshot.middleware = middleware;
    snapshot.deactivations = deactivations;
    snapshot.activations = activations;
    snapshot.moduleActivationStore = moduleActivationStore;
    return snapshot;
  };
  return ContainerSnapshot2;
}();
function isClonable(obj) {
  return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
}
var Lookup = function() {
  function Lookup2() {
    this._map = /* @__PURE__ */ new Map();
  }
  Lookup2.prototype.getMap = function() {
    return this._map;
  };
  Lookup2.prototype.add = function(serviceIdentifier, value) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT);
    }
    if (value === null || value === void 0) {
      throw new Error(NULL_ARGUMENT);
    }
    var entry = this._map.get(serviceIdentifier);
    if (entry !== void 0) {
      entry.push(value);
    } else {
      this._map.set(serviceIdentifier, [value]);
    }
  };
  Lookup2.prototype.get = function(serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT);
    }
    var entry = this._map.get(serviceIdentifier);
    if (entry !== void 0) {
      return entry;
    } else {
      throw new Error(KEY_NOT_FOUND);
    }
  };
  Lookup2.prototype.remove = function(serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT);
    }
    if (!this._map.delete(serviceIdentifier)) {
      throw new Error(KEY_NOT_FOUND);
    }
  };
  Lookup2.prototype.removeIntersection = function(lookup) {
    var _this = this;
    this.traverse(function(serviceIdentifier, value) {
      var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
      if (lookupActivations !== void 0) {
        var filteredValues = value.filter(function(lookupValue) {
          return !lookupActivations.some(function(moduleActivation) {
            return lookupValue === moduleActivation;
          });
        });
        _this._setValue(serviceIdentifier, filteredValues);
      }
    });
  };
  Lookup2.prototype.removeByCondition = function(condition) {
    var _this = this;
    var removals = [];
    this._map.forEach(function(entries, key) {
      var updatedEntries = [];
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        var remove2 = condition(entry);
        if (remove2) {
          removals.push(entry);
        } else {
          updatedEntries.push(entry);
        }
      }
      _this._setValue(key, updatedEntries);
    });
    return removals;
  };
  Lookup2.prototype.hasKey = function(serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT);
    }
    return this._map.has(serviceIdentifier);
  };
  Lookup2.prototype.clone = function() {
    var copy = new Lookup2();
    this._map.forEach(function(value, key) {
      value.forEach(function(b) {
        return copy.add(key, isClonable(b) ? b.clone() : b);
      });
    });
    return copy;
  };
  Lookup2.prototype.traverse = function(func) {
    this._map.forEach(function(value, key) {
      func(key, value);
    });
  };
  Lookup2.prototype._setValue = function(serviceIdentifier, value) {
    if (value.length > 0) {
      this._map.set(serviceIdentifier, value);
    } else {
      this._map.delete(serviceIdentifier);
    }
  };
  return Lookup2;
}();
var ModuleActivationStore = function() {
  function ModuleActivationStore2() {
    this._map = /* @__PURE__ */ new Map();
  }
  ModuleActivationStore2.prototype.remove = function(moduleId) {
    if (this._map.has(moduleId)) {
      var handlers = this._map.get(moduleId);
      this._map.delete(moduleId);
      return handlers;
    }
    return this._getEmptyHandlersStore();
  };
  ModuleActivationStore2.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
    this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
  };
  ModuleActivationStore2.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
    this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
  };
  ModuleActivationStore2.prototype.clone = function() {
    var clone = new ModuleActivationStore2();
    this._map.forEach(function(handlersStore, moduleId) {
      clone._map.set(moduleId, {
        onActivations: handlersStore.onActivations.clone(),
        onDeactivations: handlersStore.onDeactivations.clone()
      });
    });
    return clone;
  };
  ModuleActivationStore2.prototype._getModuleActivationHandlers = function(moduleId) {
    var moduleActivationHandlers = this._map.get(moduleId);
    if (moduleActivationHandlers === void 0) {
      moduleActivationHandlers = this._getEmptyHandlersStore();
      this._map.set(moduleId, moduleActivationHandlers);
    }
    return moduleActivationHandlers;
  };
  ModuleActivationStore2.prototype._getEmptyHandlersStore = function() {
    var handlersStore = {
      onActivations: new Lookup(),
      onDeactivations: new Lookup()
    };
    return handlersStore;
  };
  return ModuleActivationStore2;
}();
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Container = function() {
  function Container2(containerOptions) {
    var options = containerOptions || {};
    if (typeof options !== "object") {
      throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
    }
    if (options.defaultScope === void 0) {
      options.defaultScope = BindingScopeEnum.Transient;
    } else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
    }
    if (options.autoBindInjectable === void 0) {
      options.autoBindInjectable = false;
    } else if (typeof options.autoBindInjectable !== "boolean") {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
    }
    if (options.skipBaseClassChecks === void 0) {
      options.skipBaseClassChecks = false;
    } else if (typeof options.skipBaseClassChecks !== "boolean") {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
    }
    this.options = {
      autoBindInjectable: options.autoBindInjectable,
      defaultScope: options.defaultScope,
      skipBaseClassChecks: options.skipBaseClassChecks
    };
    this.id = id();
    this._bindingDictionary = new Lookup();
    this._snapshots = [];
    this._middleware = null;
    this._activations = new Lookup();
    this._deactivations = new Lookup();
    this.parent = null;
    this._metadataReader = new MetadataReader();
    this._moduleActivationStore = new ModuleActivationStore();
  }
  Container2.merge = function(container1, container2) {
    var containers = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      containers[_i - 2] = arguments[_i];
    }
    var container = new Container2();
    var targetContainers = __spreadArray([container1, container2], containers, true).map(function(targetContainer) {
      return getBindingDictionary(targetContainer);
    });
    var bindingDictionary = getBindingDictionary(container);
    function copyDictionary(origin, destination) {
      origin.traverse(function(_key, value) {
        value.forEach(function(binding) {
          destination.add(binding.serviceIdentifier, binding.clone());
        });
      });
    }
    targetContainers.forEach(function(targetBindingDictionary) {
      copyDictionary(targetBindingDictionary, bindingDictionary);
    });
    return container;
  };
  Container2.prototype.load = function() {
    var modules2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules2[_i] = arguments[_i];
    }
    var getHelpers = this._getContainerModuleHelpersFactory();
    for (var _a = 0, modules_1 = modules2; _a < modules_1.length; _a++) {
      var currentModule = modules_1[_a];
      var containerModuleHelpers = getHelpers(currentModule.id);
      currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
    }
  };
  Container2.prototype.loadAsync = function() {
    var modules2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules2[_i] = arguments[_i];
    }
    return __awaiter$1(this, void 0, void 0, function() {
      var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            getHelpers = this._getContainerModuleHelpersFactory();
            _a = 0, modules_2 = modules2;
            _b.label = 1;
          case 1:
            if (!(_a < modules_2.length))
              return [3, 4];
            currentModule = modules_2[_a];
            containerModuleHelpers = getHelpers(currentModule.id);
            return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
          case 2:
            _b.sent();
            _b.label = 3;
          case 3:
            _a++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  Container2.prototype.unload = function() {
    var _this = this;
    var modules2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules2[_i] = arguments[_i];
    }
    modules2.forEach(function(module) {
      var deactivations = _this._removeModuleBindings(module.id);
      _this._deactivateSingletons(deactivations);
      _this._removeModuleHandlers(module.id);
    });
  };
  Container2.prototype.unloadAsync = function() {
    var modules2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      modules2[_i] = arguments[_i];
    }
    return __awaiter$1(this, void 0, void 0, function() {
      var _a, modules_3, module_1, deactivations;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = 0, modules_3 = modules2;
            _b.label = 1;
          case 1:
            if (!(_a < modules_3.length))
              return [3, 4];
            module_1 = modules_3[_a];
            deactivations = this._removeModuleBindings(module_1.id);
            return [4, this._deactivateSingletonsAsync(deactivations)];
          case 2:
            _b.sent();
            this._removeModuleHandlers(module_1.id);
            _b.label = 3;
          case 3:
            _a++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  Container2.prototype.bind = function(serviceIdentifier) {
    var scope = this.options.defaultScope || BindingScopeEnum.Transient;
    var binding = new Binding(serviceIdentifier, scope);
    this._bindingDictionary.add(serviceIdentifier, binding);
    return new BindingToSyntax(binding);
  };
  Container2.prototype.rebind = function(serviceIdentifier) {
    this.unbind(serviceIdentifier);
    return this.bind(serviceIdentifier);
  };
  Container2.prototype.rebindAsync = function(serviceIdentifier) {
    return __awaiter$1(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.unbindAsync(serviceIdentifier)];
          case 1:
            _a.sent();
            return [2, this.bind(serviceIdentifier)];
        }
      });
    });
  };
  Container2.prototype.unbind = function(serviceIdentifier) {
    if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier);
      this._deactivateSingletons(bindings);
    }
    this._removeServiceFromDictionary(serviceIdentifier);
  };
  Container2.prototype.unbindAsync = function(serviceIdentifier) {
    return __awaiter$1(this, void 0, void 0, function() {
      var bindings;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this._bindingDictionary.hasKey(serviceIdentifier))
              return [3, 2];
            bindings = this._bindingDictionary.get(serviceIdentifier);
            return [4, this._deactivateSingletonsAsync(bindings)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            this._removeServiceFromDictionary(serviceIdentifier);
            return [2];
        }
      });
    });
  };
  Container2.prototype.unbindAll = function() {
    var _this = this;
    this._bindingDictionary.traverse(function(_key, value) {
      _this._deactivateSingletons(value);
    });
    this._bindingDictionary = new Lookup();
  };
  Container2.prototype.unbindAllAsync = function() {
    return __awaiter$1(this, void 0, void 0, function() {
      var promises;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            promises = [];
            this._bindingDictionary.traverse(function(_key, value) {
              promises.push(_this._deactivateSingletonsAsync(value));
            });
            return [4, Promise.all(promises)];
          case 1:
            _a.sent();
            this._bindingDictionary = new Lookup();
            return [2];
        }
      });
    });
  };
  Container2.prototype.onActivation = function(serviceIdentifier, onActivation) {
    this._activations.add(serviceIdentifier, onActivation);
  };
  Container2.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
    this._deactivations.add(serviceIdentifier, onDeactivation);
  };
  Container2.prototype.isBound = function(serviceIdentifier) {
    var bound = this._bindingDictionary.hasKey(serviceIdentifier);
    if (!bound && this.parent) {
      bound = this.parent.isBound(serviceIdentifier);
    }
    return bound;
  };
  Container2.prototype.isCurrentBound = function(serviceIdentifier) {
    return this._bindingDictionary.hasKey(serviceIdentifier);
  };
  Container2.prototype.isBoundNamed = function(serviceIdentifier, named2) {
    return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named2);
  };
  Container2.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
    var bound = false;
    if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier);
      var request_1 = createMockRequest(this, serviceIdentifier, key, value);
      bound = bindings.some(function(b) {
        return b.constraint(request_1);
      });
    }
    if (!bound && this.parent) {
      bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
    }
    return bound;
  };
  Container2.prototype.snapshot = function() {
    this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
  };
  Container2.prototype.restore = function() {
    var snapshot = this._snapshots.pop();
    if (snapshot === void 0) {
      throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);
    }
    this._bindingDictionary = snapshot.bindings;
    this._activations = snapshot.activations;
    this._deactivations = snapshot.deactivations;
    this._middleware = snapshot.middleware;
    this._moduleActivationStore = snapshot.moduleActivationStore;
  };
  Container2.prototype.createChild = function(containerOptions) {
    var child = new Container2(containerOptions || this.options);
    child.parent = this;
    return child;
  };
  Container2.prototype.applyMiddleware = function() {
    var middlewares = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      middlewares[_i] = arguments[_i];
    }
    var initial = this._middleware ? this._middleware : this._planAndResolve();
    this._middleware = middlewares.reduce(function(prev, curr) {
      return curr(prev);
    }, initial);
  };
  Container2.prototype.applyCustomMetadataReader = function(metadataReader) {
    this._metadataReader = metadataReader;
  };
  Container2.prototype.get = function(serviceIdentifier) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, false);
    return this._getButThrowIfAsync(getArgs);
  };
  Container2.prototype.getAsync = function(serviceIdentifier) {
    return __awaiter$1(this, void 0, void 0, function() {
      var getArgs;
      return __generator(this, function(_a) {
        getArgs = this._getNotAllArgs(serviceIdentifier, false);
        return [2, this._get(getArgs)];
      });
    });
  };
  Container2.prototype.getTagged = function(serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
    return this._getButThrowIfAsync(getArgs);
  };
  Container2.prototype.getTaggedAsync = function(serviceIdentifier, key, value) {
    return __awaiter$1(this, void 0, void 0, function() {
      var getArgs;
      return __generator(this, function(_a) {
        getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
        return [2, this._get(getArgs)];
      });
    });
  };
  Container2.prototype.getNamed = function(serviceIdentifier, named2) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named2);
  };
  Container2.prototype.getNamedAsync = function(serviceIdentifier, named2) {
    return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named2);
  };
  Container2.prototype.getAll = function(serviceIdentifier) {
    var getArgs = this._getAllArgs(serviceIdentifier);
    return this._getButThrowIfAsync(getArgs);
  };
  Container2.prototype.getAllAsync = function(serviceIdentifier) {
    var getArgs = this._getAllArgs(serviceIdentifier);
    return this._getAll(getArgs);
  };
  Container2.prototype.getAllTagged = function(serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
    return this._getButThrowIfAsync(getArgs);
  };
  Container2.prototype.getAllTaggedAsync = function(serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
    return this._getAll(getArgs);
  };
  Container2.prototype.getAllNamed = function(serviceIdentifier, named2) {
    return this.getAllTagged(serviceIdentifier, NAMED_TAG, named2);
  };
  Container2.prototype.getAllNamedAsync = function(serviceIdentifier, named2) {
    return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named2);
  };
  Container2.prototype.resolve = function(constructorFunction) {
    var isBound = this.isBound(constructorFunction);
    if (!isBound) {
      this.bind(constructorFunction).toSelf();
    }
    var resolved = this.get(constructorFunction);
    if (!isBound) {
      this.unbind(constructorFunction);
    }
    return resolved;
  };
  Container2.prototype._preDestroy = function(constructor, instance) {
    var _a, _b;
    if (Reflect.hasMetadata(PRE_DESTROY, constructor)) {
      var data = Reflect.getMetadata(PRE_DESTROY, constructor);
      return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  };
  Container2.prototype._removeModuleHandlers = function(moduleId) {
    var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
    this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
    this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
  };
  Container2.prototype._removeModuleBindings = function(moduleId) {
    return this._bindingDictionary.removeByCondition(function(binding) {
      return binding.moduleId === moduleId;
    });
  };
  Container2.prototype._deactivate = function(binding, instance) {
    var _this = this;
    var constructor = Object.getPrototypeOf(instance).constructor;
    try {
      if (this._deactivations.hasKey(binding.serviceIdentifier)) {
        var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
        if (isPromise(result)) {
          return this._handleDeactivationError(result.then(function() {
            return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
          }), constructor);
        }
      }
      var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
      if (isPromise(propagateDeactivationResult)) {
        return this._handleDeactivationError(propagateDeactivationResult, constructor);
      }
    } catch (ex) {
      if (ex instanceof Error) {
        throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message));
      }
    }
  };
  Container2.prototype._handleDeactivationError = function(asyncResult, constructor) {
    return __awaiter$1(this, void 0, void 0, function() {
      var ex_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, asyncResult];
          case 1:
            _a.sent();
            return [3, 3];
          case 2:
            ex_1 = _a.sent();
            if (ex_1 instanceof Error) {
              throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
            }
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  };
  Container2.prototype._deactivateContainer = function(instance, deactivationsIterator) {
    var _this = this;
    var deactivation = deactivationsIterator.next();
    while (deactivation.value) {
      var result = deactivation.value(instance);
      if (isPromise(result)) {
        return result.then(function() {
          return _this._deactivateContainerAsync(instance, deactivationsIterator);
        });
      }
      deactivation = deactivationsIterator.next();
    }
  };
  Container2.prototype._deactivateContainerAsync = function(instance, deactivationsIterator) {
    return __awaiter$1(this, void 0, void 0, function() {
      var deactivation;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            deactivation = deactivationsIterator.next();
            _a.label = 1;
          case 1:
            if (!deactivation.value)
              return [3, 3];
            return [4, deactivation.value(instance)];
          case 2:
            _a.sent();
            deactivation = deactivationsIterator.next();
            return [3, 1];
          case 3:
            return [2];
        }
      });
    });
  };
  Container2.prototype._getContainerModuleHelpersFactory = function() {
    var _this = this;
    var setModuleId = function(bindingToSyntax, moduleId) {
      bindingToSyntax._binding.moduleId = moduleId;
    };
    var getBindFunction = function(moduleId) {
      return function(serviceIdentifier) {
        var bindingToSyntax = _this.bind(serviceIdentifier);
        setModuleId(bindingToSyntax, moduleId);
        return bindingToSyntax;
      };
    };
    var getUnbindFunction = function() {
      return function(serviceIdentifier) {
        return _this.unbind(serviceIdentifier);
      };
    };
    var getUnbindAsyncFunction = function() {
      return function(serviceIdentifier) {
        return _this.unbindAsync(serviceIdentifier);
      };
    };
    var getIsboundFunction = function() {
      return function(serviceIdentifier) {
        return _this.isBound(serviceIdentifier);
      };
    };
    var getRebindFunction = function(moduleId) {
      return function(serviceIdentifier) {
        var bindingToSyntax = _this.rebind(serviceIdentifier);
        setModuleId(bindingToSyntax, moduleId);
        return bindingToSyntax;
      };
    };
    var getOnActivationFunction = function(moduleId) {
      return function(serviceIdentifier, onActivation) {
        _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
        _this.onActivation(serviceIdentifier, onActivation);
      };
    };
    var getOnDeactivationFunction = function(moduleId) {
      return function(serviceIdentifier, onDeactivation) {
        _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
        _this.onDeactivation(serviceIdentifier, onDeactivation);
      };
    };
    return function(mId) {
      return {
        bindFunction: getBindFunction(mId),
        isboundFunction: getIsboundFunction(),
        onActivationFunction: getOnActivationFunction(mId),
        onDeactivationFunction: getOnDeactivationFunction(mId),
        rebindFunction: getRebindFunction(mId),
        unbindFunction: getUnbindFunction(),
        unbindAsyncFunction: getUnbindAsyncFunction()
      };
    };
  };
  Container2.prototype._getAll = function(getArgs) {
    return Promise.all(this._get(getArgs));
  };
  Container2.prototype._get = function(getArgs) {
    var planAndResolveArgs = __assign(__assign({}, getArgs), {
      contextInterceptor: function(context) {
        return context;
      },
      targetType: TargetTypeEnum.Variable
    });
    if (this._middleware) {
      var middlewareResult = this._middleware(planAndResolveArgs);
      if (middlewareResult === void 0 || middlewareResult === null) {
        throw new Error(INVALID_MIDDLEWARE_RETURN);
      }
      return middlewareResult;
    }
    return this._planAndResolve()(planAndResolveArgs);
  };
  Container2.prototype._getButThrowIfAsync = function(getArgs) {
    var result = this._get(getArgs);
    if (isPromiseOrContainsPromise(result)) {
      throw new Error(LAZY_IN_SYNC(getArgs.serviceIdentifier));
    }
    return result;
  };
  Container2.prototype._getAllArgs = function(serviceIdentifier) {
    var getAllArgs = {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier
    };
    return getAllArgs;
  };
  Container2.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key, value) {
    var getNotAllArgs = {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value
    };
    return getNotAllArgs;
  };
  Container2.prototype._planAndResolve = function() {
    var _this = this;
    return function(args) {
      var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
      context = args.contextInterceptor(context);
      var result = resolve(context);
      return result;
    };
  };
  Container2.prototype._deactivateIfSingleton = function(binding) {
    var _this = this;
    if (!binding.activated) {
      return;
    }
    if (isPromise(binding.cache)) {
      return binding.cache.then(function(resolved) {
        return _this._deactivate(binding, resolved);
      });
    }
    return this._deactivate(binding, binding.cache);
  };
  Container2.prototype._deactivateSingletons = function(bindings) {
    for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
      var binding = bindings_1[_i];
      var result = this._deactivateIfSingleton(binding);
      if (isPromise(result)) {
        throw new Error(ASYNC_UNBIND_REQUIRED);
      }
    }
  };
  Container2.prototype._deactivateSingletonsAsync = function(bindings) {
    return __awaiter$1(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, Promise.all(bindings.map(function(b) {
              return _this._deactivateIfSingleton(b);
            }))];
          case 1:
            _a.sent();
            return [2];
        }
      });
    });
  };
  Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance, constructor) {
    if (this.parent) {
      return this._deactivate.bind(this.parent)(binding, instance);
    } else {
      return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
    }
  };
  Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance, constructor) {
    return __awaiter$1(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.parent)
              return [3, 2];
            return [4, this._deactivate.bind(this.parent)(binding, instance)];
          case 1:
            _a.sent();
            return [3, 4];
          case 2:
            return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];
          case 3:
            _a.sent();
            _a.label = 4;
          case 4:
            return [2];
        }
      });
    });
  };
  Container2.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
    try {
      this._bindingDictionary.remove(serviceIdentifier);
    } catch (e) {
      throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier));
    }
  };
  Container2.prototype._bindingDeactivationAndPreDestroy = function(binding, instance, constructor) {
    var _this = this;
    if (typeof binding.onDeactivation === "function") {
      var result = binding.onDeactivation(instance);
      if (isPromise(result)) {
        return result.then(function() {
          return _this._preDestroy(constructor, instance);
        });
      }
    }
    return this._preDestroy(constructor, instance);
  };
  Container2.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance, constructor) {
    return __awaiter$1(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!(typeof binding.onDeactivation === "function"))
              return [3, 2];
            return [4, binding.onDeactivation(instance)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            return [4, this._preDestroy(constructor, instance)];
          case 3:
            _a.sent();
            return [2];
        }
      });
    });
  };
  return Container2;
}();
var ContainerModule = function() {
  function ContainerModule2(registry2) {
    this.id = id();
    this.registry = registry2;
  }
  return ContainerModule2;
}();
var AsyncContainerModule = function() {
  function AsyncContainerModule2(registry2) {
    this.id = id();
    this.registry = registry2;
  }
  return AsyncContainerModule2;
}();
function getFirstArrayDuplicate(array2) {
  var seenValues = /* @__PURE__ */ new Set();
  for (var _i = 0, array_1 = array2; _i < array_1.length; _i++) {
    var entry = array_1[_i];
    if (seenValues.has(entry)) {
      return entry;
    } else {
      seenValues.add(entry);
    }
  }
  return void 0;
}
function targetIsConstructorFunction(target) {
  return target.prototype !== void 0;
}
function _throwIfMethodParameter(parameterName) {
  if (parameterName !== void 0) {
    throw new Error(INVALID_DECORATOR_OPERATION);
  }
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _throwIfMethodParameter(parameterName);
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function tagProperty(annotationTarget, propertyName, metadata) {
  if (targetIsConstructorFunction(annotationTarget)) {
    throw new Error(INVALID_DECORATOR_OPERATION);
  }
  _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
}
function _ensureNoMetadataKeyDuplicates(metadata) {
  var metadatas = [];
  if (Array.isArray(metadata)) {
    metadatas = metadata;
    var duplicate = getFirstArrayDuplicate(metadatas.map(function(md) {
      return md.key;
    }));
    if (duplicate !== void 0) {
      throw new Error(DUPLICATED_METADATA + " " + duplicate.toString());
    }
  } else {
    metadatas = [metadata];
  }
  return metadatas;
}
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
  var paramsOrPropertiesMetadata = {};
  if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
    paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
  }
  var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  if (paramOrPropertyMetadata === void 0) {
    paramOrPropertyMetadata = [];
  } else {
    var _loop_1 = function(m2) {
      if (metadatas.some(function(md) {
        return md.key === m2.key;
      })) {
        throw new Error(DUPLICATED_METADATA + " " + m2.key.toString());
      }
    };
    for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
      var m = paramOrPropertyMetadata_1[_i];
      _loop_1(m);
    }
  }
  paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
  paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
  Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function createTaggedDecorator(metadata) {
  return function(target, targetKey, indexOrPropertyDescriptor) {
    if (typeof indexOrPropertyDescriptor === "number") {
      tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
    } else {
      tagProperty(target, targetKey, metadata);
    }
  };
}
function _decorate(decorators, target) {
  Reflect.decorate(decorators, target);
}
function _param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function decorate(decorator, target, parameterIndexOrProperty) {
  if (typeof parameterIndexOrProperty === "number") {
    _decorate([_param(parameterIndexOrProperty, decorator)], target);
  } else if (typeof parameterIndexOrProperty === "string") {
    Reflect.decorate([decorator], target, parameterIndexOrProperty);
  } else {
    _decorate([decorator], target);
  }
}
function injectable() {
  return function(target) {
    if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
      throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
    }
    var types2 = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
    Reflect.defineMetadata(PARAM_TYPES, types2, target);
    return target;
  };
}
function tagged(metadataKey, metadataValue) {
  return createTaggedDecorator(new Metadata(metadataKey, metadataValue));
}
function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}
function injectBase(metadataKey) {
  return function(serviceIdentifier) {
    return function(target, targetKey, indexOrPropertyDescriptor) {
      if (serviceIdentifier === void 0) {
        var className = typeof target === "function" ? target.name : target.constructor.name;
        throw new Error(UNDEFINED_INJECT_ANNOTATION(className));
      }
      return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
    };
  };
}
var inject = injectBase(INJECT_TAG);
function optional() {
  return createTaggedDecorator(new Metadata(OPTIONAL_TAG, true));
}
function unmanaged() {
  return function(target, targetKey, index) {
    var metadata = new Metadata(UNMANAGED_TAG, true);
    tagParameter(target, targetKey, index, metadata);
  };
}
var multiInject = injectBase(MULTI_INJECT_TAG);
function targetName(name) {
  return function(target, targetKey, index) {
    var metadata = new Metadata(NAME_TAG, name);
    tagParameter(target, targetKey, index, metadata);
  };
}
function propertyEventDecorator(eventKey, errorMessage) {
  return function() {
    return function(target, propertyKey) {
      var metadata = new Metadata(eventKey, propertyKey);
      if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
        throw new Error(errorMessage);
      }
      Reflect.defineMetadata(eventKey, metadata, target.constructor);
    };
  };
}
var postConstruct = propertyEventDecorator(POST_CONSTRUCT, MULTIPLE_POST_CONSTRUCT_METHODS);
var preDestroy = propertyEventDecorator(PRE_DESTROY, MULTIPLE_PRE_DESTROY_METHODS);
var interfaces;
(function(interfaces2) {
})(interfaces || (interfaces = {}));
var METADATA_KEY = keys;
const inversify$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AsyncContainerModule,
  BindingScopeEnum,
  BindingTypeEnum,
  Container,
  ContainerModule,
  LazyServiceIdentifer: LazyServiceIdentifier,
  LazyServiceIdentifier,
  METADATA_KEY,
  MetadataReader,
  TargetTypeEnum,
  createTaggedDecorator,
  decorate,
  getServiceIdentifierAsString,
  id,
  inject,
  injectable,
  get interfaces() {
    return interfaces;
  },
  multiBindToService,
  multiInject,
  named,
  namedConstraint,
  optional,
  postConstruct,
  preDestroy,
  tagged,
  taggedConstraint,
  targetName,
  traverseAncerstors,
  typeConstraint,
  unmanaged
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(inversify$1);
var actions = {};
var object = {};
Object.defineProperty(object, "__esModule", {
  value: true
});
object.safeAssign = object.hasOwnProperty = object.isObject = void 0;
function isObject(data) {
  return typeof data === "object" && data !== null;
}
object.isObject = isObject;
function hasOwnProperty(arg, key, type) {
  if (!isObject(arg)) {
    return false;
  }
  if (Array.isArray(key)) {
    for (const k of key) {
      if (!Object.prototype.hasOwnProperty.call(arg, k)) {
        return false;
      }
      if (typeof type === "string" && typeof arg[k] !== type) {
        return false;
      } else if (typeof type === "function" && !type(arg[k])) {
        return false;
      }
    }
  } else {
    if (!Object.prototype.hasOwnProperty.call(arg, key)) {
      return false;
    }
    if (typeof type === "string") {
      return typeof arg[key] === type;
    }
    if (typeof type === "function") {
      return type(arg[key]);
    }
  }
  return true;
}
object.hasOwnProperty = hasOwnProperty;
function safeAssign(target, partial) {
  return Object.assign(target, partial);
}
object.safeAssign = safeAssign;
Object.defineProperty(actions, "__esModule", {
  value: true
});
actions.ReconnectAction = actions.ApplyLabelEditAction = actions.DeleteElementAction = actions.CreateElementAction = actions.HoverFeedbackAction = actions.MoveAction = actions.RedoAction = actions.UndoAction = actions.BringToFrontAction = actions.ViewportResult = actions.GetViewportAction = actions.SetViewportAction = actions.FitToScreenAction = actions.CenterAction = actions.LayoutAction = actions.OpenAction = actions.CollapseExpandAllAction = actions.CollapseExpandAction = actions.SelectionResult = actions.GetSelectionAction = actions.SelectAllAction = actions.SelectAction = actions.LoggingAction = actions.ComputedBoundsAction = actions.RequestBoundsAction = actions.SetBoundsAction = actions.SetPopupModelAction = actions.RequestPopupModelAction = actions.UpdateModelAction = actions.SetModelAction = actions.RequestModelAction = actions.RejectAction = actions.isResponseAction = actions.setRequestContext = actions.generateRequestId = actions.isRequestAction = actions.isAction = actions.isActionMessage = void 0;
const object_1$3 = object;
function isActionMessage(object2) {
  return (0, object_1$3.hasOwnProperty)(object2, "action");
}
actions.isActionMessage = isActionMessage;
function isAction(object2) {
  return (0, object_1$3.hasOwnProperty)(object2, "kind", "string");
}
actions.isAction = isAction;
function isRequestAction(object2) {
  return (0, object_1$3.hasOwnProperty)(object2, "requestId", "string");
}
actions.isRequestAction = isRequestAction;
let requestContext = "";
let nextRequestId = 1;
function generateRequestId() {
  return `${requestContext}_${nextRequestId++}`;
}
actions.generateRequestId = generateRequestId;
function setRequestContext(context) {
  requestContext = context;
}
actions.setRequestContext = setRequestContext;
function isResponseAction(object2) {
  return (0, object_1$3.hasOwnProperty)(object2, "responseId", "string") && object2.responseId !== "";
}
actions.isResponseAction = isResponseAction;
var RejectAction;
(function(RejectAction2) {
  RejectAction2.KIND = "rejectRequest";
  function create2(options) {
    return {
      kind: RejectAction2.KIND,
      message: options.message,
      detail: options.detail,
      responseId: options.requestId
    };
  }
  RejectAction2.create = create2;
})(RejectAction || (actions.RejectAction = RejectAction = {}));
var RequestModelAction;
(function(RequestModelAction2) {
  RequestModelAction2.KIND = "requestModel";
  function create2(options) {
    return {
      kind: RequestModelAction2.KIND,
      options,
      requestId: generateRequestId()
    };
  }
  RequestModelAction2.create = create2;
})(RequestModelAction || (actions.RequestModelAction = RequestModelAction = {}));
var SetModelAction;
(function(SetModelAction2) {
  SetModelAction2.KIND = "setModel";
  function create2(newRoot, requestId = "") {
    return {
      kind: SetModelAction2.KIND,
      newRoot,
      responseId: requestId
    };
  }
  SetModelAction2.create = create2;
})(SetModelAction || (actions.SetModelAction = SetModelAction = {}));
var UpdateModelAction;
(function(UpdateModelAction2) {
  UpdateModelAction2.KIND = "updateModel";
  function create2(input, options = {}) {
    if (Array.isArray(input)) {
      return {
        kind: UpdateModelAction2.KIND,
        matches: input,
        animate: options.animate,
        cause: options.cause
      };
    } else {
      return {
        kind: UpdateModelAction2.KIND,
        newRoot: input,
        animate: options.animate,
        cause: options.cause
      };
    }
  }
  UpdateModelAction2.create = create2;
})(UpdateModelAction || (actions.UpdateModelAction = UpdateModelAction = {}));
var RequestPopupModelAction;
(function(RequestPopupModelAction2) {
  RequestPopupModelAction2.KIND = "requestPopupModel";
  function create2(options) {
    return {
      kind: RequestPopupModelAction2.KIND,
      elementId: options.elementId,
      bounds: options.bounds,
      requestId: generateRequestId()
    };
  }
  RequestPopupModelAction2.create = create2;
})(RequestPopupModelAction || (actions.RequestPopupModelAction = RequestPopupModelAction = {}));
var SetPopupModelAction;
(function(SetPopupModelAction2) {
  SetPopupModelAction2.KIND = "setPopupModel";
  function create2(newRoot, requestId = "") {
    return {
      kind: SetPopupModelAction2.KIND,
      newRoot,
      responseId: requestId
    };
  }
  SetPopupModelAction2.create = create2;
})(SetPopupModelAction || (actions.SetPopupModelAction = SetPopupModelAction = {}));
var SetBoundsAction;
(function(SetBoundsAction2) {
  SetBoundsAction2.KIND = "setBounds";
  function create2(bounds) {
    return {
      kind: SetBoundsAction2.KIND,
      bounds
    };
  }
  SetBoundsAction2.create = create2;
})(SetBoundsAction || (actions.SetBoundsAction = SetBoundsAction = {}));
var RequestBoundsAction;
(function(RequestBoundsAction2) {
  RequestBoundsAction2.KIND = "requestBounds";
  function create2(newRoot) {
    return {
      kind: RequestBoundsAction2.KIND,
      newRoot,
      requestId: generateRequestId()
    };
  }
  RequestBoundsAction2.create = create2;
})(RequestBoundsAction || (actions.RequestBoundsAction = RequestBoundsAction = {}));
var ComputedBoundsAction;
(function(ComputedBoundsAction2) {
  ComputedBoundsAction2.KIND = "computedBounds";
  function create2(bounds, options = {}) {
    var _a;
    return {
      kind: ComputedBoundsAction2.KIND,
      bounds,
      revision: options.revision,
      alignments: options.alignments,
      responseId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ""
    };
  }
  ComputedBoundsAction2.create = create2;
})(ComputedBoundsAction || (actions.ComputedBoundsAction = ComputedBoundsAction = {}));
var LoggingAction;
(function(LoggingAction2) {
  LoggingAction2.KIND = "logging";
  function create2(options) {
    return Object.assign({
      kind: LoggingAction2.KIND
    }, options);
  }
  LoggingAction2.create = create2;
})(LoggingAction || (actions.LoggingAction = LoggingAction = {}));
var SelectAction;
(function(SelectAction2) {
  SelectAction2.KIND = "elementSelected";
  function create2(options) {
    var _a, _b;
    return {
      kind: SelectAction2.KIND,
      selectedElementsIDs: (_a = options.selectedElementsIDs) !== null && _a !== void 0 ? _a : [],
      deselectedElementsIDs: (_b = options.deselectedElementsIDs) !== null && _b !== void 0 ? _b : []
    };
  }
  SelectAction2.create = create2;
})(SelectAction || (actions.SelectAction = SelectAction = {}));
var SelectAllAction;
(function(SelectAllAction2) {
  SelectAllAction2.KIND = "allSelected";
  function create2(options = {}) {
    var _a;
    return {
      kind: SelectAllAction2.KIND,
      select: (_a = options.select) !== null && _a !== void 0 ? _a : true
    };
  }
  SelectAllAction2.create = create2;
})(SelectAllAction || (actions.SelectAllAction = SelectAllAction = {}));
var GetSelectionAction;
(function(GetSelectionAction2) {
  GetSelectionAction2.KIND = "getSelection";
  function create2() {
    return {
      kind: GetSelectionAction2.KIND,
      requestId: generateRequestId()
    };
  }
  GetSelectionAction2.create = create2;
})(GetSelectionAction || (actions.GetSelectionAction = GetSelectionAction = {}));
var SelectionResult;
(function(SelectionResult2) {
  SelectionResult2.KIND = "selectionResult";
  function create2(selectedElementsIDs, requestId) {
    return {
      kind: SelectionResult2.KIND,
      selectedElementsIDs,
      responseId: requestId
    };
  }
  SelectionResult2.create = create2;
})(SelectionResult || (actions.SelectionResult = SelectionResult = {}));
var CollapseExpandAction;
(function(CollapseExpandAction2) {
  CollapseExpandAction2.KIND = "collapseExpand";
  function create2(options) {
    var _a, _b;
    return {
      kind: CollapseExpandAction2.KIND,
      expandIds: (_a = options.expandIds) !== null && _a !== void 0 ? _a : [],
      collapseIds: (_b = options.collapseIds) !== null && _b !== void 0 ? _b : []
    };
  }
  CollapseExpandAction2.create = create2;
})(CollapseExpandAction || (actions.CollapseExpandAction = CollapseExpandAction = {}));
var CollapseExpandAllAction;
(function(CollapseExpandAllAction2) {
  CollapseExpandAllAction2.KIND = "collapseExpandAll";
  function create2(options = {}) {
    var _a;
    return {
      kind: CollapseExpandAllAction2.KIND,
      expand: (_a = options.expand) !== null && _a !== void 0 ? _a : true
    };
  }
  CollapseExpandAllAction2.create = create2;
})(CollapseExpandAllAction || (actions.CollapseExpandAllAction = CollapseExpandAllAction = {}));
var OpenAction;
(function(OpenAction2) {
  OpenAction2.KIND = "open";
  function create2(elementId) {
    return {
      kind: OpenAction2.KIND,
      elementId
    };
  }
  OpenAction2.create = create2;
})(OpenAction || (actions.OpenAction = OpenAction = {}));
var LayoutAction;
(function(LayoutAction2) {
  LayoutAction2.KIND = "layout";
  function create2(options = {}) {
    return {
      kind: LayoutAction2.KIND,
      layoutType: options.layoutType,
      elementIds: options.elementIds
    };
  }
  LayoutAction2.create = create2;
})(LayoutAction || (actions.LayoutAction = LayoutAction = {}));
var CenterAction;
(function(CenterAction2) {
  CenterAction2.KIND = "center";
  function create2(elementIds, options = {}) {
    var _a, _b;
    return {
      kind: CenterAction2.KIND,
      elementIds,
      animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
      retainZoom: (_b = options.retainZoom) !== null && _b !== void 0 ? _b : false,
      zoomScale: options.zoomScale
    };
  }
  CenterAction2.create = create2;
})(CenterAction || (actions.CenterAction = CenterAction = {}));
var FitToScreenAction;
(function(FitToScreenAction2) {
  FitToScreenAction2.KIND = "fit";
  function create2(elementIds, options = {}) {
    var _a;
    return {
      kind: FitToScreenAction2.KIND,
      elementIds,
      padding: options.padding,
      maxZoom: options.maxZoom,
      animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
    };
  }
  FitToScreenAction2.create = create2;
})(FitToScreenAction || (actions.FitToScreenAction = FitToScreenAction = {}));
var SetViewportAction;
(function(SetViewportAction2) {
  SetViewportAction2.KIND = "viewport";
  function create2(elementId, newViewport, options = {}) {
    var _a;
    return {
      kind: SetViewportAction2.KIND,
      elementId,
      newViewport,
      animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
    };
  }
  SetViewportAction2.create = create2;
})(SetViewportAction || (actions.SetViewportAction = SetViewportAction = {}));
var GetViewportAction;
(function(GetViewportAction2) {
  GetViewportAction2.KIND = "getViewport";
  function create2() {
    return {
      kind: GetViewportAction2.KIND,
      requestId: generateRequestId()
    };
  }
  GetViewportAction2.create = create2;
})(GetViewportAction || (actions.GetViewportAction = GetViewportAction = {}));
var ViewportResult;
(function(ViewportResult2) {
  ViewportResult2.KIND = "viewportResult";
  function create2(viewport2, canvasBounds, requestId) {
    return {
      kind: ViewportResult2.KIND,
      viewport: viewport2,
      canvasBounds,
      responseId: requestId
    };
  }
  ViewportResult2.create = create2;
})(ViewportResult || (actions.ViewportResult = ViewportResult = {}));
var BringToFrontAction;
(function(BringToFrontAction2) {
  BringToFrontAction2.KIND = "bringToFront";
  function create2(elementIDs) {
    return {
      kind: BringToFrontAction2.KIND,
      elementIDs
    };
  }
  BringToFrontAction2.create = create2;
})(BringToFrontAction || (actions.BringToFrontAction = BringToFrontAction = {}));
var UndoAction;
(function(UndoAction2) {
  UndoAction2.KIND = "undo";
  function create2() {
    return {
      kind: UndoAction2.KIND
    };
  }
  UndoAction2.create = create2;
})(UndoAction || (actions.UndoAction = UndoAction = {}));
var RedoAction;
(function(RedoAction2) {
  RedoAction2.KIND = "redo";
  function create2() {
    return {
      kind: RedoAction2.KIND
    };
  }
  RedoAction2.create = create2;
})(RedoAction || (actions.RedoAction = RedoAction = {}));
var MoveAction;
(function(MoveAction2) {
  MoveAction2.KIND = "move";
  function create2(moves, options = {}) {
    var _a, _b, _c;
    return {
      kind: MoveAction2.KIND,
      moves,
      animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
      finished: (_b = options.finished) !== null && _b !== void 0 ? _b : false,
      stoppable: (_c = options.stoppable) !== null && _c !== void 0 ? _c : false
    };
  }
  MoveAction2.create = create2;
})(MoveAction || (actions.MoveAction = MoveAction = {}));
var HoverFeedbackAction;
(function(HoverFeedbackAction2) {
  HoverFeedbackAction2.KIND = "hoverFeedback";
  function create2(options) {
    return {
      kind: HoverFeedbackAction2.KIND,
      mouseoverElement: options.mouseoverElement,
      mouseIsOver: options.mouseIsOver
    };
  }
  HoverFeedbackAction2.create = create2;
})(HoverFeedbackAction || (actions.HoverFeedbackAction = HoverFeedbackAction = {}));
var CreateElementAction;
(function(CreateElementAction2) {
  CreateElementAction2.KIND = "createElement";
  function create2(elementSchema, options) {
    return {
      kind: CreateElementAction2.KIND,
      elementSchema,
      containerId: options.containerId
    };
  }
  CreateElementAction2.create = create2;
})(CreateElementAction || (actions.CreateElementAction = CreateElementAction = {}));
var DeleteElementAction;
(function(DeleteElementAction2) {
  DeleteElementAction2.KIND = "delete";
  function create2(elementIds) {
    return {
      kind: DeleteElementAction2.KIND,
      elementIds
    };
  }
  DeleteElementAction2.create = create2;
})(DeleteElementAction || (actions.DeleteElementAction = DeleteElementAction = {}));
var ApplyLabelEditAction;
(function(ApplyLabelEditAction2) {
  ApplyLabelEditAction2.KIND = "applyLabelEdit";
  function create2(labelId, text) {
    return {
      kind: ApplyLabelEditAction2.KIND,
      labelId,
      text
    };
  }
  ApplyLabelEditAction2.create = create2;
})(ApplyLabelEditAction || (actions.ApplyLabelEditAction = ApplyLabelEditAction = {}));
var ReconnectAction;
(function(ReconnectAction2) {
  ReconnectAction2.KIND = "reconnect";
  function create2(options) {
    return {
      kind: ReconnectAction2.KIND,
      routableId: options.routableId,
      newSourceId: options.newSourceId,
      newTargetId: options.newTargetId
    };
  }
  ReconnectAction2.create = create2;
})(ReconnectAction || (actions.ReconnectAction = ReconnectAction = {}));
var async = {};
Object.defineProperty(async, "__esModule", {
  value: true
});
async.Deferred = void 0;
class Deferred {
  constructor() {
    this._state = "unresolved";
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      this.reject = reject;
    });
    this.promise.then((res) => this._state = "resolved", (rej) => this._state = "rejected");
  }
  set state(state) {
    if (this._state === "unresolved") {
      this._state = state;
    }
  }
  get state() {
    return this._state;
  }
}
async.Deferred = Deferred;
var types = {};
Object.defineProperty(types, "__esModule", {
  value: true
});
types.TYPES = void 0;
types.TYPES = {
  Action: Symbol("Action"),
  IActionDispatcher: Symbol("IActionDispatcher"),
  IActionDispatcherProvider: Symbol("IActionDispatcherProvider"),
  IActionHandlerInitializer: Symbol("IActionHandlerInitializer"),
  ActionHandlerRegistration: Symbol("ActionHandlerRegistration"),
  ActionHandlerRegistryProvider: Symbol("ActionHandlerRegistryProvider"),
  IAnchorComputer: Symbol("IAnchor"),
  AnimationFrameSyncer: Symbol("AnimationFrameSyncer"),
  IButtonHandlerRegistration: Symbol("IButtonHandlerRegistration"),
  ICommandPaletteActionProvider: Symbol("ICommandPaletteActionProvider"),
  ICommandPaletteActionProviderRegistry: Symbol("ICommandPaletteActionProviderRegistry"),
  CommandRegistration: Symbol("CommandRegistration"),
  ICommandStack: Symbol("ICommandStack"),
  CommandStackOptions: Symbol("CommandStackOptions"),
  ICommandStackProvider: Symbol("ICommandStackProvider"),
  IContextMenuItemProvider: Symbol.for("IContextMenuProvider"),
  IContextMenuProviderRegistry: Symbol.for("IContextMenuProviderRegistry"),
  IContextMenuService: Symbol.for("IContextMenuService"),
  IContextMenuServiceProvider: Symbol.for("IContextMenuServiceProvider"),
  DOMHelper: Symbol("DOMHelper"),
  IDiagramLocker: Symbol("IDiagramLocker"),
  IEdgeRouter: Symbol("IEdgeRouter"),
  IEdgeRoutePostprocessor: Symbol("IEdgeRoutePostprocessor"),
  IEditLabelValidationDecorator: Symbol("IEditLabelValidationDecorator"),
  IEditLabelValidator: Symbol("IEditLabelValidator"),
  HiddenModelViewer: Symbol("HiddenModelViewer"),
  HiddenVNodePostprocessor: Symbol("HiddenVNodeDecorator"),
  HoverState: Symbol("HoverState"),
  KeyListener: Symbol("KeyListener"),
  LayoutRegistration: Symbol("LayoutRegistration"),
  LayoutRegistry: Symbol("LayoutRegistry"),
  Layouter: Symbol("Layouter"),
  LogLevel: Symbol("LogLevel"),
  ILogger: Symbol("ILogger"),
  IModelFactory: Symbol("IModelFactory"),
  IModelLayoutEngine: Symbol("IModelLayoutEngine"),
  ModelRendererFactory: Symbol("ModelRendererFactory"),
  ModelSource: Symbol("ModelSource"),
  ModelSourceProvider: Symbol("ModelSourceProvider"),
  ModelViewer: Symbol("ModelViewer"),
  MouseListener: Symbol("MouseListener"),
  PatcherProvider: Symbol("PatcherProvider"),
  IPopupModelProvider: Symbol("IPopupModelProvider"),
  PopupModelViewer: Symbol("PopupModelViewer"),
  PopupMouseListener: Symbol("PopupMouseListener"),
  PopupVNodePostprocessor: Symbol("PopupVNodeDecorator"),
  SModelElementRegistration: Symbol("SModelElementRegistration"),
  SModelRegistry: Symbol("SModelRegistry"),
  ISnapper: Symbol("ISnapper"),
  SvgExporter: Symbol("SvgExporter"),
  IUIExtension: Symbol("IUIExtension"),
  UIExtensionRegistry: Symbol("UIExtensionRegistry"),
  IVNodePostprocessor: Symbol("IVNodePostprocessor"),
  ViewRegistration: Symbol("ViewRegistration"),
  ViewRegistry: Symbol("ViewRegistry"),
  IViewer: Symbol("IViewer"),
  ViewerOptions: Symbol("ViewerOptions"),
  IViewerProvider: Symbol("IViewerProvider")
};
var smodelFactory = {};
var registry = {};
var __decorate$1i = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(registry, "__esModule", {
  value: true
});
registry.MultiInstanceRegistry = registry.InstanceRegistry = registry.FactoryRegistry = registry.ProviderRegistry = void 0;
const inversify_1$1F = require$$0$1;
let ProviderRegistry = class ProviderRegistry2 {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  register(key, cstr) {
    if (key === void 0)
      throw new Error("Key is undefined");
    if (this.hasKey(key))
      throw new Error("Key is already registered: " + key);
    this.elements.set(key, cstr);
  }
  deregister(key) {
    if (key === void 0)
      throw new Error("Key is undefined");
    this.elements.delete(key);
  }
  hasKey(key) {
    return this.elements.has(key);
  }
  get(key, arg) {
    const existingCstr = this.elements.get(key);
    if (existingCstr)
      return new existingCstr(arg);
    else
      return this.missing(key, arg);
  }
  missing(key, arg) {
    throw new Error("Unknown registry key: " + key);
  }
};
registry.ProviderRegistry = ProviderRegistry;
registry.ProviderRegistry = ProviderRegistry = __decorate$1i([(0, inversify_1$1F.injectable)()], ProviderRegistry);
let FactoryRegistry = class FactoryRegistry2 {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  register(key, factory) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    if (this.hasKey(key)) {
      throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
    }
    this.elements.set(key, factory);
  }
  override(key, factory) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    } else if (!this.hasKey(key)) {
      throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
    }
    this.elements.set(key, factory);
  }
  deregister(key) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    this.elements.delete(key);
  }
  hasKey(key) {
    return this.elements.has(key);
  }
  get(key, arg) {
    const existingFactory = this.elements.get(key);
    if (existingFactory) {
      return existingFactory(arg);
    } else {
      return this.missing(key, arg);
    }
  }
  missing(key, arg) {
    throw new Error("Unknown registry key: " + key);
  }
};
registry.FactoryRegistry = FactoryRegistry;
registry.FactoryRegistry = FactoryRegistry = __decorate$1i([(0, inversify_1$1F.injectable)()], FactoryRegistry);
let InstanceRegistry = class InstanceRegistry2 {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  register(key, instance) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    if (this.hasKey(key)) {
      throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
    }
    this.elements.set(key, instance);
  }
  override(key, instance) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    } else if (!this.hasKey(key)) {
      throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
    }
    this.elements.set(key, instance);
  }
  deregister(key) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    this.elements.delete(key);
  }
  hasKey(key) {
    return this.elements.has(key);
  }
  get(key) {
    const existingInstance = this.elements.get(key);
    if (existingInstance) {
      return existingInstance;
    } else {
      return this.missing(key);
    }
  }
  missing(key) {
    throw new Error("Unknown registry key: " + key);
  }
};
registry.InstanceRegistry = InstanceRegistry;
registry.InstanceRegistry = InstanceRegistry = __decorate$1i([(0, inversify_1$1F.injectable)()], InstanceRegistry);
let MultiInstanceRegistry = class MultiInstanceRegistry2 {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  register(key, instance) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    const instances = this.elements.get(key);
    if (instances !== void 0) {
      instances.push(instance);
    } else {
      this.elements.set(key, [instance]);
    }
  }
  deregisterAll(key) {
    if (key === void 0) {
      throw new Error("Key is undefined");
    }
    this.elements.delete(key);
  }
  get(key) {
    const existingInstances = this.elements.get(key);
    if (existingInstances !== void 0) {
      return existingInstances;
    } else {
      return [];
    }
  }
};
registry.MultiInstanceRegistry = MultiInstanceRegistry;
registry.MultiInstanceRegistry = MultiInstanceRegistry = __decorate$1i([(0, inversify_1$1F.injectable)()], MultiInstanceRegistry);
var smodel = {};
var geometry$1 = {};
Object.defineProperty(geometry$1, "__esModule", {
  value: true
});
geometry$1.almostEquals = geometry$1.toRadians = geometry$1.toDegrees = geometry$1.Bounds = geometry$1.isBounds = geometry$1.Dimension = geometry$1.centerOfLine = geometry$1.angleBetweenPoints = geometry$1.angleOfPoint = geometry$1.Point = void 0;
const object_1$2 = object;
var Point;
(function(Point2) {
  Point2.ORIGIN = Object.freeze({
    x: 0,
    y: 0
  });
  function add2(p1, p2) {
    return {
      x: p1.x + p2.x,
      y: p1.y + p2.y
    };
  }
  Point2.add = add2;
  function subtract(p1, p2) {
    return {
      x: p1.x - p2.x,
      y: p1.y - p2.y
    };
  }
  Point2.subtract = subtract;
  function equals(point1, point2) {
    return point1.x === point2.x && point1.y === point2.y;
  }
  Point2.equals = equals;
  function shiftTowards(point, refPoint, distance) {
    const diff = subtract(refPoint, point);
    const normalized = normalize(diff);
    const shift = {
      x: normalized.x * distance,
      y: normalized.y * distance
    };
    return add2(point, shift);
  }
  Point2.shiftTowards = shiftTowards;
  function normalize(point) {
    const mag = magnitude(point);
    if (mag === 0 || mag === 1) {
      return Point2.ORIGIN;
    }
    return {
      x: point.x / mag,
      y: point.y / mag
    };
  }
  Point2.normalize = normalize;
  function magnitude(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }
  Point2.magnitude = magnitude;
  function linear(p0, p1, lambda) {
    return {
      x: (1 - lambda) * p0.x + lambda * p1.x,
      y: (1 - lambda) * p0.y + lambda * p1.y
    };
  }
  Point2.linear = linear;
  function euclideanDistance(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  Point2.euclideanDistance = euclideanDistance;
  function manhattanDistance(a, b) {
    return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
  }
  Point2.manhattanDistance = manhattanDistance;
  function maxDistance(a, b) {
    return Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
  }
  Point2.maxDistance = maxDistance;
  function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y;
  }
  Point2.dotProduct = dotProduct;
})(Point || (geometry$1.Point = Point = {}));
function angleOfPoint(p2) {
  return Math.atan2(p2.y, p2.x);
}
geometry$1.angleOfPoint = angleOfPoint;
function angleBetweenPoints(a, b) {
  const lengthProduct = Math.sqrt((a.x * a.x + a.y * a.y) * (b.x * b.x + b.y * b.y));
  if (isNaN(lengthProduct) || lengthProduct === 0)
    return NaN;
  const dotProduct = a.x * b.x + a.y * b.y;
  return Math.acos(dotProduct / lengthProduct);
}
geometry$1.angleBetweenPoints = angleBetweenPoints;
function centerOfLine(s, e) {
  const b = {
    x: s.x > e.x ? e.x : s.x,
    y: s.y > e.y ? e.y : s.y,
    width: Math.abs(e.x - s.x),
    height: Math.abs(e.y - s.y)
  };
  return Bounds.center(b);
}
geometry$1.centerOfLine = centerOfLine;
var Dimension;
(function(Dimension2) {
  Dimension2.EMPTY = Object.freeze({
    width: -1,
    height: -1
  });
  function isValid(d) {
    return d.width >= 0 && d.height >= 0;
  }
  Dimension2.isValid = isValid;
})(Dimension || (geometry$1.Dimension = Dimension = {}));
function isBounds(element) {
  return (0, object_1$2.hasOwnProperty)(element, ["x", "y", "width", "height"]);
}
geometry$1.isBounds = isBounds;
var Bounds;
(function(Bounds2) {
  Bounds2.EMPTY = Object.freeze({
    x: 0,
    y: 0,
    width: -1,
    height: -1
  });
  function combine(b0, b1) {
    if (!Dimension.isValid(b0))
      return Dimension.isValid(b1) ? b1 : Bounds2.EMPTY;
    if (!Dimension.isValid(b1))
      return b0;
    const minX = Math.min(b0.x, b1.x);
    const minY = Math.min(b0.y, b1.y);
    const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
    const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  Bounds2.combine = combine;
  function translate(b, p2) {
    return {
      x: b.x + p2.x,
      y: b.y + p2.y,
      width: b.width,
      height: b.height
    };
  }
  Bounds2.translate = translate;
  function center(b) {
    return {
      x: b.x + (b.width >= 0 ? 0.5 * b.width : 0),
      y: b.y + (b.height >= 0 ? 0.5 * b.height : 0)
    };
  }
  Bounds2.center = center;
  function includes(b, p2) {
    return p2.x >= b.x && p2.x <= b.x + b.width && p2.y >= b.y && p2.y <= b.y + b.height;
  }
  Bounds2.includes = includes;
})(Bounds || (geometry$1.Bounds = Bounds = {}));
function toDegrees(a) {
  return a * 180 / Math.PI;
}
geometry$1.toDegrees = toDegrees;
function toRadians(a) {
  return a * Math.PI / 180;
}
geometry$1.toRadians = toRadians;
function almostEquals(a, b) {
  return Math.abs(a - b) < 1e-3;
}
geometry$1.almostEquals = almostEquals;
var iterable = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapIterable = exports.filterIterable = exports.DONE_RESULT = exports.toArray = exports.FluentIterableImpl = void 0;
  class FluentIterableImpl {
    constructor(startFn, nextFn) {
      this.startFn = startFn;
      this.nextFn = nextFn;
    }
    [Symbol.iterator]() {
      const iterator = {
        state: this.startFn(),
        next: () => this.nextFn(iterator.state),
        [Symbol.iterator]: () => iterator
      };
      return iterator;
    }
    filter(callback) {
      return filterIterable(this, callback);
    }
    map(callback) {
      return mapIterable(this, callback);
    }
    forEach(callback) {
      const iterator = this[Symbol.iterator]();
      let index = 0;
      let result;
      do {
        result = iterator.next();
        if (result.value !== void 0)
          callback(result.value, index);
        index++;
      } while (!result.done);
    }
    indexOf(element) {
      const iterator = this[Symbol.iterator]();
      let index = 0;
      let result;
      do {
        result = iterator.next();
        if (result.value === element)
          return index;
        index++;
      } while (!result.done);
      return -1;
    }
  }
  exports.FluentIterableImpl = FluentIterableImpl;
  function toArray(input) {
    if (input.constructor === Array) {
      return input;
    }
    const result = [];
    input.forEach((element) => result.push(element));
    return result;
  }
  exports.toArray = toArray;
  exports.DONE_RESULT = Object.freeze({
    done: true,
    value: void 0
  });
  function filterIterable(input, callback) {
    return new FluentIterableImpl(() => createIterator(input), (iterator) => {
      let result;
      do {
        result = iterator.next();
      } while (!result.done && !callback(result.value));
      return result;
    });
  }
  exports.filterIterable = filterIterable;
  function mapIterable(input, callback) {
    return new FluentIterableImpl(() => createIterator(input), (iterator) => {
      const {
        done,
        value
      } = iterator.next();
      if (done)
        return exports.DONE_RESULT;
      else
        return {
          done: false,
          value: callback(value)
        };
    });
  }
  exports.mapIterable = mapIterable;
  function createIterator(collection) {
    const method = collection[Symbol.iterator];
    if (typeof method === "function") {
      return method.call(collection);
    }
    const length = collection.length;
    if (typeof length === "number" && length >= 0) {
      return new ArrayIterator(collection);
    }
    return {
      next: () => exports.DONE_RESULT
    };
  }
  class ArrayIterator {
    constructor(array2) {
      this.array = array2;
      this.index = 0;
    }
    next() {
      if (this.index < this.array.length)
        return {
          done: false,
          value: this.array[this.index++]
        };
      else
        return exports.DONE_RESULT;
    }
    [Symbol.iterator]() {
      return this;
    }
  }
})(iterable);
Object.defineProperty(smodel, "__esModule", {
  value: true
});
smodel.ModelIndexImpl = smodel.createRandomId = smodel.SModelRootImpl = smodel.SChildElementImpl = smodel.SParentElementImpl = smodel.isParent = smodel.SModelElementImpl = void 0;
const geometry_1$t = geometry$1;
const iterable_1$5 = iterable;
class SModelElementImpl {
  get root() {
    let current = this;
    while (current) {
      if (current instanceof SModelRootImpl)
        return current;
      else if (current instanceof SChildElementImpl)
        current = current.parent;
      else
        current = void 0;
    }
    throw new Error("Element has no root");
  }
  get index() {
    return this.root.index;
  }
  /**
   * A feature is a symbol identifying some functionality that can be enabled or disabled for
   * a model element. The set of supported features is determined by the `features` property.
   */
  hasFeature(feature) {
    return this.features !== void 0 && this.features.has(feature);
  }
}
smodel.SModelElementImpl = SModelElementImpl;
function isParent(element) {
  const children = element.children;
  return children !== void 0 && children.constructor === Array;
}
smodel.isParent = isParent;
class SParentElementImpl extends SModelElementImpl {
  constructor() {
    super(...arguments);
    this.children = [];
  }
  add(child, index) {
    const children = this.children;
    if (index === void 0) {
      children.push(child);
    } else {
      if (index < 0 || index > this.children.length) {
        throw new Error(`Child index ${index} out of bounds (0..${children.length})`);
      }
      children.splice(index, 0, child);
    }
    child.parent = this;
    this.index.add(child);
  }
  remove(child) {
    const children = this.children;
    const i = children.indexOf(child);
    if (i < 0) {
      throw new Error(`No such child ${child.id}`);
    }
    children.splice(i, 1);
    this.index.remove(child);
  }
  removeAll(filter) {
    const children = this.children;
    if (filter !== void 0) {
      for (let i = children.length - 1; i >= 0; i--) {
        if (filter(children[i])) {
          const child = children.splice(i, 1)[0];
          this.index.remove(child);
        }
      }
    } else {
      children.forEach((child) => {
        this.index.remove(child);
      });
      children.splice(0, children.length);
    }
  }
  move(child, newIndex) {
    const children = this.children;
    const i = children.indexOf(child);
    if (i === -1) {
      throw new Error(`No such child ${child.id}`);
    } else {
      if (newIndex < 0 || newIndex > children.length - 1) {
        throw new Error(`Child index ${newIndex} out of bounds (0..${children.length})`);
      }
      children.splice(i, 1);
      children.splice(newIndex, 0, child);
    }
  }
  /**
   * Transform the given bounds from the local coordinate system of this element to the coordinate
   * system of its parent. This function should consider any transformation that is applied to the
   * view of this element and its contents.
   * The base implementation assumes that this element does not define a local coordinate system,
   * so it leaves the bounds unchanged.
   */
  localToParent(point) {
    return (0, geometry_1$t.isBounds)(point) ? point : {
      x: point.x,
      y: point.y,
      width: -1,
      height: -1
    };
  }
  /**
   * Transform the given bounds from the coordinate system of this element's parent to its local
   * coordinate system. This function should consider any transformation that is applied to the
   * view of this element and its contents.
   * The base implementation assumes that this element does not define a local coordinate system,
   * so it leaves the bounds unchanged.
   */
  parentToLocal(point) {
    return (0, geometry_1$t.isBounds)(point) ? point : {
      x: point.x,
      y: point.y,
      width: -1,
      height: -1
    };
  }
}
smodel.SParentElementImpl = SParentElementImpl;
class SChildElementImpl extends SParentElementImpl {
}
smodel.SChildElementImpl = SChildElementImpl;
class SModelRootImpl extends SParentElementImpl {
  constructor(index = new ModelIndexImpl()) {
    super();
    this.canvasBounds = geometry_1$t.Bounds.EMPTY;
    Object.defineProperty(this, "index", {
      value: index,
      writable: false
    });
  }
}
smodel.SModelRootImpl = SModelRootImpl;
const ID_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";
function createRandomId(length = 8) {
  let id2 = "";
  for (let i = 0; i < length; i++) {
    id2 += ID_CHARS.charAt(Math.floor(Math.random() * ID_CHARS.length));
  }
  return id2;
}
smodel.createRandomId = createRandomId;
class ModelIndexImpl {
  constructor() {
    this.id2element = /* @__PURE__ */ new Map();
  }
  add(element) {
    if (!element.id) {
      do {
        element.id = createRandomId();
      } while (this.contains(element));
    } else if (this.contains(element)) {
      throw new Error("Duplicate ID in model: " + element.id);
    }
    this.id2element.set(element.id, element);
    if (element instanceof SParentElementImpl) {
      for (const child of element.children) {
        this.add(child);
      }
    }
  }
  remove(element) {
    this.id2element.delete(element.id);
    if (element instanceof SParentElementImpl) {
      for (const child of element.children) {
        this.remove(child);
      }
    }
  }
  contains(element) {
    return this.id2element.has(element.id);
  }
  getById(id2) {
    return this.id2element.get(id2);
  }
  getAttachedElements(element) {
    return [];
  }
  all() {
    return (0, iterable_1$5.mapIterable)(this.id2element, ([key, value]) => value);
  }
}
smodel.ModelIndexImpl = ModelIndexImpl;
var __decorate$1h = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$S = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$u = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(smodelFactory, "__esModule", {
  value: true
});
smodelFactory.createFeatureSet = smodelFactory.EMPTY_ROOT = smodelFactory.SModelFactory = smodelFactory.SModelRegistry = void 0;
const inversify_1$1E = require$$0$1;
const types_1$16 = types;
const registry_1$6 = registry;
const smodel_1$o = smodel;
let SModelRegistry = class SModelRegistry2 extends registry_1$6.FactoryRegistry {
  constructor(registrations) {
    super();
    registrations.forEach((registration) => {
      let defaultFeatures = this.getDefaultFeatures(registration.constr);
      if (!defaultFeatures && registration.features && registration.features.enable)
        defaultFeatures = [];
      if (defaultFeatures) {
        const featureSet = createFeatureSet(defaultFeatures, registration.features);
        if (registration.isOverride) {
          this.override(registration.type, () => {
            const element = new registration.constr();
            element.features = featureSet;
            return element;
          });
        } else {
          this.register(registration.type, () => {
            const element = new registration.constr();
            element.features = featureSet;
            return element;
          });
        }
      } else {
        if (registration.isOverride) {
          this.override(registration.type, () => new registration.constr());
        } else {
          this.register(registration.type, () => new registration.constr());
        }
      }
    });
  }
  getDefaultFeatures(constr) {
    let obj = constr;
    do {
      const defaultFeatures = obj.DEFAULT_FEATURES;
      if (defaultFeatures)
        return defaultFeatures;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return void 0;
  }
};
smodelFactory.SModelRegistry = SModelRegistry;
smodelFactory.SModelRegistry = SModelRegistry = __decorate$1h([(0, inversify_1$1E.injectable)(), __param$u(0, (0, inversify_1$1E.multiInject)(types_1$16.TYPES.SModelElementRegistration)), __param$u(0, (0, inversify_1$1E.optional)()), __metadata$S("design:paramtypes", [Array])], SModelRegistry);
let SModelFactory = class SModelFactory2 {
  createElement(schema, parent) {
    let child;
    if (this.registry.hasKey(schema.type)) {
      const regElement = this.registry.get(schema.type, void 0);
      if (!(regElement instanceof smodel_1$o.SChildElementImpl))
        throw new Error(`Element with type ${schema.type} was expected to be an SChildElement.`);
      child = regElement;
    } else {
      child = new smodel_1$o.SChildElementImpl();
    }
    return this.initializeChild(child, schema, parent);
  }
  createRoot(schema) {
    let root;
    if (this.registry.hasKey(schema.type)) {
      const regElement = this.registry.get(schema.type, void 0);
      if (!(regElement instanceof smodel_1$o.SModelRootImpl))
        throw new Error(`Element with type ${schema.type} was expected to be an SModelRoot.`);
      root = regElement;
    } else {
      root = new smodel_1$o.SModelRootImpl();
    }
    return this.initializeRoot(root, schema);
  }
  createSchema(element) {
    const schema = {};
    for (const key in element) {
      if (!this.isReserved(element, key)) {
        const value = element[key];
        if (typeof value !== "function")
          schema[key] = value;
      }
    }
    if (element instanceof smodel_1$o.SParentElementImpl)
      schema["children"] = element.children.map((child) => this.createSchema(child));
    return schema;
  }
  initializeElement(element, schema) {
    for (const key in schema) {
      if (!this.isReserved(element, key)) {
        const value = schema[key];
        if (typeof value !== "function")
          element[key] = value;
      }
    }
    return element;
  }
  isReserved(element, propertyName) {
    if (["children", "parent", "index"].indexOf(propertyName) >= 0)
      return true;
    let obj = element;
    do {
      const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
      if (descriptor !== void 0)
        return descriptor.get !== void 0;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return false;
  }
  initializeParent(parent, schema) {
    this.initializeElement(parent, schema);
    if ((0, smodel_1$o.isParent)(schema)) {
      parent.children = schema.children.map((childSchema) => this.createElement(childSchema, parent));
    }
    return parent;
  }
  initializeChild(child, schema, parent) {
    this.initializeParent(child, schema);
    if (parent !== void 0) {
      child.parent = parent;
    }
    return child;
  }
  initializeRoot(root, schema) {
    this.initializeParent(root, schema);
    root.index.add(root);
    return root;
  }
};
smodelFactory.SModelFactory = SModelFactory;
__decorate$1h([(0, inversify_1$1E.inject)(types_1$16.TYPES.SModelRegistry), __metadata$S("design:type", SModelRegistry)], SModelFactory.prototype, "registry", void 0);
smodelFactory.SModelFactory = SModelFactory = __decorate$1h([(0, inversify_1$1E.injectable)()], SModelFactory);
smodelFactory.EMPTY_ROOT = Object.freeze({
  type: "NONE",
  id: "EMPTY"
});
function createFeatureSet(defaults, custom) {
  const featureSet = new Set(defaults);
  if (custom && custom.enable) {
    for (const f of custom.enable) {
      featureSet.add(f);
    }
  }
  if (custom && custom.disable) {
    for (const f of custom.disable) {
      featureSet.delete(f);
    }
  }
  return featureSet;
}
smodelFactory.createFeatureSet = createFeatureSet;
var animationFrameSyncer = {};
var __decorate$1g = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(animationFrameSyncer, "__esModule", {
  value: true
});
animationFrameSyncer.AnimationFrameSyncer = void 0;
const inversify_1$1D = require$$0$1;
let AnimationFrameSyncer = class AnimationFrameSyncer2 {
  constructor() {
    this.tasks = [];
    this.endTasks = [];
    this.triggered = false;
  }
  isAvailable() {
    return typeof requestAnimationFrame === "function";
  }
  onNextFrame(task) {
    this.tasks.push(task);
    this.trigger();
  }
  onEndOfNextFrame(task) {
    this.endTasks.push(task);
    this.trigger();
  }
  trigger() {
    if (!this.triggered) {
      this.triggered = true;
      if (this.isAvailable())
        requestAnimationFrame((time) => this.run(time));
      else
        setTimeout((time) => this.run(time));
    }
  }
  run(time) {
    const tasks = this.tasks;
    const endTasks = this.endTasks;
    this.triggered = false;
    this.tasks = [];
    this.endTasks = [];
    tasks.forEach((task) => task.call(void 0, time));
    endTasks.forEach((task) => task.call(void 0, time));
  }
};
animationFrameSyncer.AnimationFrameSyncer = AnimationFrameSyncer;
animationFrameSyncer.AnimationFrameSyncer = AnimationFrameSyncer = __decorate$1g([(0, inversify_1$1D.injectable)()], AnimationFrameSyncer);
var __decorate$1f = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$R = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(actionDispatcher, "__esModule", {
  value: true
});
actionDispatcher.ActionDispatcher = void 0;
const inversify_1$1C = require$$0$1;
const actions_1$s = actions;
const async_1$1 = async;
const types_1$15 = types;
const smodel_factory_1$6 = smodelFactory;
const animation_frame_syncer_1$3 = animationFrameSyncer;
(0, actions_1$s.setRequestContext)("client");
let ActionDispatcher = class ActionDispatcher2 {
  constructor() {
    this.postponedActions = [];
    this.requests = /* @__PURE__ */ new Map();
  }
  initialize() {
    if (!this.initialized) {
      this.initialized = this.actionHandlerRegistryProvider().then((registry2) => {
        this.actionHandlerRegistry = registry2;
        this.handleAction(actions_1$s.SetModelAction.create(smodel_factory_1$6.EMPTY_ROOT)).catch(() => {
        });
      });
    }
    return this.initialized;
  }
  /**
   * Dispatch an action by querying all handlers that are registered for its kind.
   * The returned promise is resolved when all handler results (commands or actions)
   * have been processed.
   */
  dispatch(action2) {
    return this.initialize().then(() => {
      if (this.blockUntil !== void 0) {
        return this.handleBlocked(action2, this.blockUntil);
      } else if (this.diagramLocker.isAllowed(action2)) {
        return this.handleAction(action2);
      }
      return void 0;
    });
  }
  /**
   * Calls `dispatch` on every action in the given array. The returned promise
   * is resolved when the promises of all `dispatch` calls have been resolved.
   */
  dispatchAll(actions2) {
    return Promise.all(actions2.map((action2) => this.dispatch(action2)));
  }
  /**
   * Dispatch a request. The returned promise is resolved when a response with matching
   * identifier is dispatched. That response is _not_ passed to the registered action
   * handlers. Instead, it is the responsibility of the caller of this method to handle
   * the response properly. For example, it can be sent to the registered handlers by
   * passing it again to the `dispatch` method.
   */
  request(action2) {
    if (!action2.requestId) {
      return Promise.reject(new Error("Request without requestId"));
    }
    const deferred = new async_1$1.Deferred();
    this.requests.set(action2.requestId, deferred);
    this.dispatch(action2).catch(() => {
    });
    return deferred.promise;
  }
  handleAction(action2) {
    if (action2.kind === actions_1$s.UndoAction.KIND) {
      return this.commandStack.undo().then(() => {
      });
    }
    if (action2.kind === actions_1$s.RedoAction.KIND) {
      return this.commandStack.redo().then(() => {
      });
    }
    if ((0, actions_1$s.isResponseAction)(action2)) {
      const deferred = this.requests.get(action2.responseId);
      if (deferred !== void 0) {
        this.requests.delete(action2.responseId);
        if (action2.kind === actions_1$s.RejectAction.KIND) {
          const rejectAction = action2;
          deferred.reject(new Error(rejectAction.message));
          this.logger.warn(this, `Request with id ${action2.responseId} failed.`, rejectAction.message, rejectAction.detail);
        } else {
          deferred.resolve(action2);
        }
        return Promise.resolve();
      }
      this.logger.log(this, "No matching request for response", action2);
    }
    const handlers = this.actionHandlerRegistry.get(action2.kind);
    if (handlers.length === 0) {
      this.logger.warn(this, "Missing handler for action", action2);
      const error = new Error(`Missing handler for action '${action2.kind}'`);
      if ((0, actions_1$s.isRequestAction)(action2)) {
        const deferred = this.requests.get(action2.requestId);
        if (deferred !== void 0) {
          this.requests.delete(action2.requestId);
          deferred.reject(error);
        }
      }
      return Promise.reject(error);
    }
    this.logger.log(this, "Handle", action2);
    const promises = [];
    for (const handler of handlers) {
      const result = handler.handle(action2);
      if ((0, actions_1$s.isAction)(result)) {
        promises.push(this.dispatch(result));
      } else if (result !== void 0) {
        promises.push(this.commandStack.execute(result));
        this.blockUntil = result.blockUntil;
      }
    }
    return Promise.all(promises);
  }
  handleBlocked(action2, predicate) {
    if (predicate(action2)) {
      this.blockUntil = void 0;
      const result = this.handleAction(action2);
      const actions2 = this.postponedActions;
      this.postponedActions = [];
      for (const a of actions2) {
        this.dispatch(a.action).then(a.resolve, a.reject);
      }
      return result;
    } else {
      this.logger.log(this, "Action is postponed due to block condition", action2);
      return new Promise((resolve2, reject) => {
        this.postponedActions.push({
          action: action2,
          resolve: resolve2,
          reject
        });
      });
    }
  }
};
actionDispatcher.ActionDispatcher = ActionDispatcher;
__decorate$1f([(0, inversify_1$1C.inject)(types_1$15.TYPES.ActionHandlerRegistryProvider), __metadata$R("design:type", Function)], ActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
__decorate$1f([(0, inversify_1$1C.inject)(types_1$15.TYPES.ICommandStack), __metadata$R("design:type", Object)], ActionDispatcher.prototype, "commandStack", void 0);
__decorate$1f([(0, inversify_1$1C.inject)(types_1$15.TYPES.ILogger), __metadata$R("design:type", Object)], ActionDispatcher.prototype, "logger", void 0);
__decorate$1f([(0, inversify_1$1C.inject)(types_1$15.TYPES.AnimationFrameSyncer), __metadata$R("design:type", animation_frame_syncer_1$3.AnimationFrameSyncer)], ActionDispatcher.prototype, "syncer", void 0);
__decorate$1f([(0, inversify_1$1C.inject)(types_1$15.TYPES.IDiagramLocker), __metadata$R("design:type", Object)], ActionDispatcher.prototype, "diagramLocker", void 0);
actionDispatcher.ActionDispatcher = ActionDispatcher = __decorate$1f([(0, inversify_1$1C.injectable)()], ActionDispatcher);
var actionHandler$1 = {};
var inversify = {};
Object.defineProperty(inversify, "__esModule", {
  value: true
});
inversify.isInjectable = void 0;
function isInjectable(constr) {
  return Reflect.getMetadata("inversify:paramtypes", constr) !== void 0;
}
inversify.isInjectable = isInjectable;
var __decorate$1e = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$Q = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$t = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(actionHandler$1, "__esModule", {
  value: true
});
actionHandler$1.onAction = actionHandler$1.configureActionHandler = actionHandler$1.ActionHandlerRegistry = void 0;
const inversify_1$1B = require$$0$1;
const types_1$14 = types;
const registry_1$5 = registry;
const inversify_2$4 = inversify;
let ActionHandlerRegistry = class ActionHandlerRegistry2 extends registry_1$5.MultiInstanceRegistry {
  constructor(registrations, initializers) {
    super();
    registrations.forEach((registration) => this.register(registration.actionKind, registration.factory()));
    initializers.forEach((initializer) => this.initializeActionHandler(initializer));
  }
  initializeActionHandler(initializer) {
    initializer.initialize(this);
  }
};
actionHandler$1.ActionHandlerRegistry = ActionHandlerRegistry;
actionHandler$1.ActionHandlerRegistry = ActionHandlerRegistry = __decorate$1e([(0, inversify_1$1B.injectable)(), __param$t(0, (0, inversify_1$1B.multiInject)(types_1$14.TYPES.ActionHandlerRegistration)), __param$t(0, (0, inversify_1$1B.optional)()), __param$t(1, (0, inversify_1$1B.multiInject)(types_1$14.TYPES.IActionHandlerInitializer)), __param$t(1, (0, inversify_1$1B.optional)()), __metadata$Q("design:paramtypes", [Array, Array])], ActionHandlerRegistry);
function configureActionHandler(context, kind, constr) {
  if (typeof constr === "function") {
    if (!(0, inversify_2$4.isInjectable)(constr)) {
      throw new Error(`Action handlers should be @injectable: ${constr.name}`);
    }
    if (!context.isBound(constr)) {
      context.bind(constr).toSelf();
    }
  }
  context.bind(types_1$14.TYPES.ActionHandlerRegistration).toDynamicValue((ctx) => ({
    actionKind: kind,
    factory: () => ctx.container.get(constr)
  }));
}
actionHandler$1.configureActionHandler = configureActionHandler;
function onAction(context, kind, handle) {
  context.bind(types_1$14.TYPES.ActionHandlerRegistration).toConstantValue({
    actionKind: kind,
    factory: () => ({
      handle
    })
  });
}
actionHandler$1.onAction = onAction;
var diagramLocker = {};
var __decorate$1d = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(diagramLocker, "__esModule", {
  value: true
});
diagramLocker.DefaultDiagramLocker = void 0;
const inversify_1$1A = require$$0$1;
let DefaultDiagramLocker = class DefaultDiagramLocker2 {
  isAllowed(action2) {
    return true;
  }
};
diagramLocker.DefaultDiagramLocker = DefaultDiagramLocker;
diagramLocker.DefaultDiagramLocker = DefaultDiagramLocker = __decorate$1d([(0, inversify_1$1A.injectable)()], DefaultDiagramLocker);
var animation = {};
var easing = {};
Object.defineProperty(easing, "__esModule", {
  value: true
});
easing.easeInOut = void 0;
function easeInOut(x) {
  if (x < 0.5)
    return x * x * 2;
  else
    return 1 - (1 - x) * (1 - x) * 2;
}
easing.easeInOut = easeInOut;
Object.defineProperty(animation, "__esModule", {
  value: true
});
animation.CompoundAnimation = animation.Animation = void 0;
const easing_1 = easing;
class Animation {
  constructor(context, ease = easing_1.easeInOut) {
    this.context = context;
    this.ease = ease;
    this.stopped = false;
  }
  start() {
    this.stopped = false;
    return new Promise((resolve2, reject) => {
      let start = void 0;
      let frames = 0;
      const lambda = (time) => {
        frames++;
        let dtime;
        if (start === void 0) {
          start = time;
          dtime = 0;
        } else {
          dtime = time - start;
        }
        const t = Math.min(1, dtime / this.context.duration);
        const current = this.tween(this.ease(t), this.context);
        this.context.modelChanged.update(current);
        if (t === 1) {
          this.context.logger.log(this, frames * 1e3 / this.context.duration + " fps");
          resolve2(current);
        } else if (this.stopped) {
          this.context.logger.log(this, "Animation stopped at " + t * 100 + "%");
          resolve2(current);
        } else {
          this.context.syncer.onNextFrame(lambda);
        }
      };
      if (this.context.syncer.isAvailable()) {
        this.context.syncer.onNextFrame(lambda);
      } else {
        const finalModel = this.tween(1, this.context);
        resolve2(finalModel);
      }
    });
  }
  /**
   * Stop the animation at the current state.
   * The promise returned by start() will be resolved with the current state after the next tweening step.
   */
  stop() {
    this.stopped = true;
  }
}
animation.Animation = Animation;
class CompoundAnimation extends Animation {
  constructor(model2, context, components = [], ease = easing_1.easeInOut) {
    super(context, ease);
    this.model = model2;
    this.context = context;
    this.components = components;
    this.ease = ease;
  }
  include(animation2) {
    this.components.push(animation2);
    return this;
  }
  tween(t, context) {
    for (const a of this.components) {
      a.tween(t, context);
    }
    return this.model;
  }
}
animation.CompoundAnimation = CompoundAnimation;
var command = {};
var lib = {};
var actionHandler = {};
Object.defineProperty(actionHandler, "__esModule", {
  value: true
});
actionHandler.ServerActionHandlerRegistry = void 0;
class ServerActionHandlerRegistry {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
  }
  /**
   * Returns the action handlers for the given action kind, or `undefined` if there are none.
   */
  getHandler(kind) {
    return this.handlers.get(kind);
  }
  /**
   * Add an action handler to be called when an action of the specified kind is received.
   */
  onAction(kind, handler) {
    if (this.handlers.has(kind)) {
      this.handlers.get(kind).push(handler);
    } else {
      this.handlers.set(kind, [handler]);
    }
  }
  /**
   * Remove an action handler that was previously added with `onAction`.
   */
  removeActionHandler(kind, handler) {
    const list = this.handlers.get(kind);
    if (list) {
      const index = list.indexOf(handler);
      if (index >= 0) {
        list.splice(index, 1);
      }
    }
  }
}
actionHandler.ServerActionHandlerRegistry = ServerActionHandlerRegistry;
var diagramServer$1 = {};
var modelUtils = {};
Object.defineProperty(modelUtils, "__esModule", {
  value: true
});
modelUtils.SModelIndex = modelUtils.findElement = modelUtils.getSubType = modelUtils.getBasicType = modelUtils.applyBounds = modelUtils.cloneModel = void 0;
function cloneModel(model2) {
  return JSON.parse(JSON.stringify(model2));
}
modelUtils.cloneModel = cloneModel;
function applyBounds(root, action2) {
  const index = new SModelIndex();
  index.add(root);
  for (const b of action2.bounds) {
    const element = index.getById(b.elementId);
    if (element) {
      const bae = element;
      if (b.newPosition) {
        bae.position = {
          x: b.newPosition.x,
          y: b.newPosition.y
        };
      }
      if (b.newSize) {
        bae.size = {
          width: b.newSize.width,
          height: b.newSize.height
        };
      }
    }
  }
  if (action2.alignments) {
    for (const a of action2.alignments) {
      const element = index.getById(a.elementId);
      if (element) {
        const alignable = element;
        alignable.alignment = {
          x: a.newAlignment.x,
          y: a.newAlignment.y
        };
      }
    }
  }
}
modelUtils.applyBounds = applyBounds;
function getBasicType(element) {
  if (!element.type) {
    return "";
  }
  const colonIndex = element.type.indexOf(":");
  return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
}
modelUtils.getBasicType = getBasicType;
function getSubType(schema) {
  if (!schema.type) {
    return "";
  }
  const colonIndex = schema.type.indexOf(":");
  return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
}
modelUtils.getSubType = getSubType;
function findElement(parent, elementId) {
  if (parent.id === elementId) {
    return parent;
  }
  if (parent.children) {
    for (const child of parent.children) {
      const result = findElement(child, elementId);
      if (result !== void 0) {
        return result;
      }
    }
  }
  return void 0;
}
modelUtils.findElement = findElement;
class SModelIndex {
  constructor() {
    this.id2element = /* @__PURE__ */ new Map();
    this.id2parent = /* @__PURE__ */ new Map();
  }
  add(element) {
    if (!element.id) {
      throw new Error("Model element has no ID.");
    } else if (this.contains(element)) {
      throw new Error("Duplicate ID in model: " + element.id);
    }
    this.id2element.set(element.id, element);
    if (Array.isArray(element.children)) {
      for (const child of element.children) {
        this.add(child);
        this.id2parent.set(child.id, element);
      }
    }
    return this;
  }
  remove(element) {
    this.id2element.delete(element.id);
    if (Array.isArray(element.children)) {
      for (const child of element.children) {
        this.id2parent.delete(child.id);
        this.remove(child);
      }
    }
    return this;
  }
  contains(element) {
    return this.id2element.has(element.id);
  }
  getById(id2) {
    return this.id2element.get(id2);
  }
  getParent(id2) {
    return this.id2parent.get(id2);
  }
  getRoot(element) {
    let current = element;
    while (current) {
      const parent = this.id2parent.get(current.id);
      if (parent === void 0) {
        return current;
      }
      current = parent;
    }
    throw new Error("Element has no root");
  }
}
modelUtils.SModelIndex = SModelIndex;
Object.defineProperty(diagramServer$1, "__esModule", {
  value: true
});
diagramServer$1.DiagramServer = void 0;
const actions_1$r = actions;
const async_1 = async;
const model_utils_1$4 = modelUtils;
class DiagramServer {
  constructor(dispatch, services) {
    this.state = {
      currentRoot: {
        type: "NONE",
        id: "ROOT"
      },
      revision: 0
    };
    this.requests = /* @__PURE__ */ new Map();
    this.dispatch = dispatch;
    this.diagramGenerator = services.DiagramGenerator;
    this.layoutEngine = services.ModelLayoutEngine;
    this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
  }
  /**
   * Set the model and submit it to the client.
   */
  setModel(newRoot) {
    newRoot.revision = ++this.state.revision;
    this.state.currentRoot = newRoot;
    return this.submitModel(newRoot, false);
  }
  /**
   * Update the model to a new state and submit it to the client.
   */
  updateModel(newRoot) {
    newRoot.revision = ++this.state.revision;
    this.state.currentRoot = newRoot;
    return this.submitModel(newRoot, true);
  }
  /**
   * Whether the client needs to compute the layout of parts of the model. This affects the behavior
   * of `submitModel`.
   *
   * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
   * from the client. If the client does not specify whether it needs client layout, the default value
   * is `true`.
   */
  get needsClientLayout() {
    if (this.state.options && this.state.options.needsClientLayout !== void 0) {
      return !!this.state.options.needsClientLayout;
    }
    return true;
  }
  /**
   * Whether the server needs to compute the layout of parts of the model. This affects the behavior
   * of `submitModel`.
   *
   * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
   * from the client. If the client does not specify whether it needs server layout, the default value
   * is `false`.
   */
  get needsServerLayout() {
    if (this.state.options && this.state.options.needsServerLayout !== void 0) {
      return !!this.state.options.needsServerLayout;
    }
    return false;
  }
  /**
   * Called when an action is received from the client.
   */
  accept(action2) {
    if ((0, actions_1$r.isResponseAction)(action2)) {
      const id2 = action2.responseId;
      const future = this.requests.get(id2);
      if (future) {
        this.requests.delete(id2);
        if (action2.kind === actions_1$r.RejectAction.KIND) {
          const rejectAction = action2;
          future.reject(new Error(rejectAction.message));
          console.warn(`Request with id ${action2.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
        } else {
          future.resolve(action2);
        }
        return Promise.resolve();
      }
      console.info("No matching request for response:", action2);
    }
    return this.handleAction(action2);
  }
  /**
   * Send a request action to the client. The resulting promise is resolved when a matching
   * response is received and rejected when a `RejectAction` is received.
   */
  request(action2) {
    if (!action2.requestId) {
      action2.requestId = "server_" + (0, actions_1$r.generateRequestId)();
    }
    const future = new async_1.Deferred();
    this.requests.set(action2.requestId, future);
    this.dispatch(action2).catch((err) => {
      this.requests.delete(action2.requestId);
      future.reject(err);
    });
    return future.promise;
  }
  /**
   * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
   */
  rejectRemoteRequest(action2, error) {
    if (action2 && (0, actions_1$r.isRequestAction)(action2)) {
      this.dispatch({
        kind: actions_1$r.RejectAction.KIND,
        responseId: action2.requestId,
        message: error.message,
        detail: error.stack
      });
    }
  }
  handleAction(action2) {
    var _a, _b;
    const handlers = (_a = this.actionHandlerRegistry) === null || _a === void 0 ? void 0 : _a.getHandler(action2.kind);
    if (handlers && handlers.length === 1) {
      return (_b = handlers[0](action2, this.state, this)) !== null && _b !== void 0 ? _b : Promise.resolve();
    } else if (handlers && handlers.length > 1) {
      return Promise.all(handlers.map((h2) => {
        var _a2;
        return (_a2 = h2(action2, this.state, this)) !== null && _a2 !== void 0 ? _a2 : Promise.resolve();
      }));
    }
    switch (action2.kind) {
      case actions_1$r.RequestModelAction.KIND:
        return this.handleRequestModel(action2);
      case actions_1$r.ComputedBoundsAction.KIND:
        return this.handleComputedBounds(action2);
      case actions_1$r.LayoutAction.KIND:
        return this.handleLayout(action2);
    }
    console.warn(`Unhandled action from client: ${action2.kind}`);
    return Promise.resolve();
  }
  async handleRequestModel(action2) {
    var _a;
    this.state.options = action2.options;
    try {
      const newRoot = await this.diagramGenerator.generate({
        options: (_a = this.state.options) !== null && _a !== void 0 ? _a : {},
        state: this.state
      });
      newRoot.revision = ++this.state.revision;
      this.state.currentRoot = newRoot;
      await this.submitModel(this.state.currentRoot, false, action2);
    } catch (err) {
      this.rejectRemoteRequest(action2, err);
      console.error("Failed to generate diagram:", err);
    }
  }
  /**
   * Submit a model to the client after it has been updated in the server state.
   */
  async submitModel(newRoot, update, cause) {
    if (this.needsClientLayout) {
      if (!this.needsServerLayout) {
        this.dispatch({
          kind: actions_1$r.RequestBoundsAction.KIND,
          newRoot
        });
      } else {
        const request = actions_1$r.RequestBoundsAction.create(newRoot);
        const response = await this.request(request);
        const currentRoot = this.state.currentRoot;
        if (response.revision === currentRoot.revision) {
          (0, model_utils_1$4.applyBounds)(currentRoot, response);
          await this.doSubmitModel(currentRoot, update, cause);
        } else {
          this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
        }
      }
    } else {
      await this.doSubmitModel(newRoot, update, cause);
    }
  }
  async doSubmitModel(newRoot, update, cause) {
    if (newRoot.revision !== this.state.revision) {
      return;
    }
    if (this.needsServerLayout && this.layoutEngine) {
      newRoot = await this.layoutEngine.layout(newRoot);
    }
    const modelType = newRoot.type;
    if (cause && cause.kind === actions_1$r.RequestModelAction.KIND) {
      const requestId = cause.requestId;
      const response = actions_1$r.SetModelAction.create(newRoot, requestId);
      await this.dispatch(response);
    } else if (update && modelType === this.state.lastSubmittedModelType) {
      await this.dispatch({
        kind: actions_1$r.UpdateModelAction.KIND,
        newRoot,
        cause
      });
    } else {
      await this.dispatch({
        kind: actions_1$r.SetModelAction.KIND,
        newRoot
      });
    }
    this.state.lastSubmittedModelType = modelType;
  }
  handleComputedBounds(action2) {
    if (action2.revision !== this.state.currentRoot.revision) {
      return Promise.reject();
    }
    (0, model_utils_1$4.applyBounds)(this.state.currentRoot, action2);
    return Promise.resolve();
  }
  async handleLayout(action2) {
    if (!this.layoutEngine) {
      return;
    }
    if (!this.needsServerLayout) {
      let newRoot = (0, model_utils_1$4.cloneModel)(this.state.currentRoot);
      newRoot = await this.layoutEngine.layout(newRoot);
      newRoot.revision = ++this.state.revision;
      this.state.currentRoot = newRoot;
    }
    await this.doSubmitModel(this.state.currentRoot, true, action2);
  }
}
diagramServer$1.DiagramServer = DiagramServer;
var diagramServices = {};
Object.defineProperty(diagramServices, "__esModule", {
  value: true
});
var model$h = {};
Object.defineProperty(model$h, "__esModule", {
  value: true
});
model$h.isZoomable = model$h.isScrollable = void 0;
const object_1$1 = object;
function isScrollable(element) {
  return (0, object_1$1.hasOwnProperty)(element, "scroll");
}
model$h.isScrollable = isScrollable;
function isZoomable(element) {
  return (0, object_1$1.hasOwnProperty)(element, "zoom");
}
model$h.isZoomable = isZoomable;
var json = {};
Object.defineProperty(json, "__esModule", {
  value: true
});
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m, p2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(actionHandler, exports);
  __exportStar(actions, exports);
  __exportStar(diagramServer$1, exports);
  __exportStar(diagramServices, exports);
  __exportStar(model$h, exports);
  __exportStar(async, exports);
  __exportStar(geometry$1, exports);
  __exportStar(json, exports);
  __exportStar(modelUtils, exports);
  __exportStar(object, exports);
})(lib);
var __decorate$1c = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(command, "__esModule", {
  value: true
});
command.ResetCommand = command.SystemCommand = command.PopupCommand = command.HiddenCommand = command.MergeableCommand = command.Command = command.isStoppableCommand = void 0;
const inversify_1$1z = require$$0$1;
const sprotty_protocol_1$8 = lib;
function isStoppableCommand(command2) {
  return command2 && (0, sprotty_protocol_1$8.hasOwnProperty)(command2, "stoppableCommandKey") && "stopExecution" in command2 && typeof command2.stopExecution === "function";
}
command.isStoppableCommand = isStoppableCommand;
let Command = class Command2 {
};
command.Command = Command;
command.Command = Command = __decorate$1c([(0, inversify_1$1z.injectable)()], Command);
let MergeableCommand = class MergeableCommand2 extends Command {
  /**
   * Tries to merge the given command with this.
   *
   * @param command
   * @param context
   */
  merge(command2, context) {
    return false;
  }
};
command.MergeableCommand = MergeableCommand;
command.MergeableCommand = MergeableCommand = __decorate$1c([(0, inversify_1$1z.injectable)()], MergeableCommand);
let HiddenCommand = class HiddenCommand2 extends Command {
  undo(context) {
    context.logger.error(this, "Cannot undo a hidden command");
    return context.root;
  }
  redo(context) {
    context.logger.error(this, "Cannot redo a hidden command");
    return context.root;
  }
};
command.HiddenCommand = HiddenCommand;
command.HiddenCommand = HiddenCommand = __decorate$1c([(0, inversify_1$1z.injectable)()], HiddenCommand);
let PopupCommand = class PopupCommand2 extends Command {
};
command.PopupCommand = PopupCommand;
command.PopupCommand = PopupCommand = __decorate$1c([(0, inversify_1$1z.injectable)()], PopupCommand);
let SystemCommand = class SystemCommand2 extends Command {
};
command.SystemCommand = SystemCommand;
command.SystemCommand = SystemCommand = __decorate$1c([(0, inversify_1$1z.injectable)()], SystemCommand);
let ResetCommand = class ResetCommand2 extends Command {
};
command.ResetCommand = ResetCommand;
command.ResetCommand = ResetCommand = __decorate$1c([(0, inversify_1$1z.injectable)()], ResetCommand);
var commandRegistration = {};
var __decorate$1b = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$P = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$s = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(commandRegistration, "__esModule", {
  value: true
});
commandRegistration.configureCommand = commandRegistration.CommandActionHandlerInitializer = commandRegistration.CommandActionHandler = void 0;
const inversify_1$1y = require$$0$1;
const inversify_2$3 = inversify;
const types_1$13 = types;
class CommandActionHandler {
  constructor(commandRegistration2) {
    this.commandRegistration = commandRegistration2;
  }
  handle(action2) {
    return this.commandRegistration.factory(action2);
  }
}
commandRegistration.CommandActionHandler = CommandActionHandler;
let CommandActionHandlerInitializer = class CommandActionHandlerInitializer2 {
  constructor(registrations) {
    this.registrations = registrations;
  }
  initialize(registry2) {
    this.registrations.forEach((registration) => registry2.register(registration.kind, new CommandActionHandler(registration)));
  }
};
commandRegistration.CommandActionHandlerInitializer = CommandActionHandlerInitializer;
commandRegistration.CommandActionHandlerInitializer = CommandActionHandlerInitializer = __decorate$1b([(0, inversify_1$1y.injectable)(), __param$s(0, (0, inversify_1$1y.multiInject)(types_1$13.TYPES.CommandRegistration)), __param$s(0, (0, inversify_1$1y.optional)()), __metadata$P("design:paramtypes", [Array])], CommandActionHandlerInitializer);
function configureCommand(context, constr) {
  if (!(0, inversify_2$3.isInjectable)(constr)) {
    throw new Error(`Commands should be @injectable: ${constr.name}`);
  }
  if (!context.isBound(constr)) {
    context.bind(constr).toSelf();
  }
  context.bind(types_1$13.TYPES.CommandRegistration).toDynamicValue((ctx) => ({
    kind: constr.KIND,
    factory: (action2) => {
      const childContainer = new inversify_1$1y.Container();
      childContainer.parent = ctx.container;
      childContainer.bind(types_1$13.TYPES.Action).toConstantValue(action2);
      return childContainer.get(constr);
    }
  }));
}
commandRegistration.configureCommand = configureCommand;
var commandStackOptions = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.overrideCommandStackOptions = exports.configureCommandStackOptions = exports.defaultCommandStackOptions = void 0;
  const object_12 = object;
  const types_12 = types;
  const defaultCommandStackOptions = () => ({
    defaultDuration: 250,
    undoHistoryLimit: 50
  });
  exports.defaultCommandStackOptions = defaultCommandStackOptions;
  function configureCommandStackOptions(context, options) {
    const opt = Object.assign(Object.assign({}, (0, exports.defaultCommandStackOptions)()), options);
    if (context.isBound(types_12.TYPES.CommandStackOptions)) {
      context.rebind(types_12.TYPES.CommandStackOptions).toConstantValue(opt);
    } else {
      context.bind(types_12.TYPES.CommandStackOptions).toConstantValue(opt);
    }
  }
  exports.configureCommandStackOptions = configureCommandStackOptions;
  function overrideCommandStackOptions(container, options) {
    const defaultOptions = container.get(types_12.TYPES.CommandStackOptions);
    (0, object_12.safeAssign)(defaultOptions, options);
    return defaultOptions;
  }
  exports.overrideCommandStackOptions = overrideCommandStackOptions;
})(commandStackOptions);
var commandStack = {};
var __decorate$1a = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$O = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(commandStack, "__esModule", {
  value: true
});
commandStack.CommandStack = void 0;
const inversify_1$1x = require$$0$1;
const types_1$12 = types;
const smodel_factory_1$5 = smodelFactory;
const smodel_1$n = smodel;
const animation_frame_syncer_1$2 = animationFrameSyncer;
const command_1$j = command;
let CommandStack = class CommandStack2 {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
    this.stoppableCommands = /* @__PURE__ */ new Map();
    this.offStack = [];
  }
  initialize() {
    this.currentPromise = Promise.resolve({
      main: {
        model: this.modelFactory.createRoot(smodel_factory_1$5.EMPTY_ROOT),
        modelChanged: false
      },
      hidden: {
        model: this.modelFactory.createRoot(smodel_factory_1$5.EMPTY_ROOT),
        modelChanged: false
      },
      popup: {
        model: this.modelFactory.createRoot(smodel_factory_1$5.EMPTY_ROOT),
        modelChanged: false
      }
    });
  }
  get currentModel() {
    return this.currentPromise.then((state) => state.main.model);
  }
  executeAll(commands) {
    commands.forEach((command2) => {
      this.logger.log(this, "Executing", command2);
      this.handleCommand(command2, command2.execute, this.mergeOrPush);
    });
    return this.thenUpdate();
  }
  execute(command2) {
    this.logger.log(this, "Executing", command2);
    this.handleCommand(command2, command2.execute, this.mergeOrPush);
    return this.thenUpdate();
  }
  undo() {
    this.undoOffStackSystemCommands();
    this.undoPreceedingSystemCommands();
    const command2 = this.undoStack[this.undoStack.length - 1];
    if (command2 !== void 0 && !this.isBlockUndo(command2)) {
      this.undoStack.pop();
      this.logger.log(this, "Undoing", command2);
      this.handleCommand(command2, command2.undo, (c, context) => {
        this.redoStack.push(c);
      });
    }
    return this.thenUpdate();
  }
  redo() {
    this.undoOffStackSystemCommands();
    const command2 = this.redoStack.pop();
    if (command2 !== void 0) {
      this.logger.log(this, "Redoing", command2);
      this.handleCommand(command2, command2.redo, (c, context) => {
        this.pushToUndoStack(c);
      });
    }
    this.redoFollowingSystemCommands();
    return this.thenUpdate();
  }
  /**
   * Chains the current promise with another Promise that performs the
   * given operation on the given command.
   *
   * @param beforeResolve a function that is called directly before
   *      resolving the Promise to return the new model. Usually puts the
   *      command on the appropriate stack.
   */
  handleCommand(command2, operation, beforeResolve) {
    if ((0, command_1$j.isStoppableCommand)(command2)) {
      const stoppableCommand = this.stoppableCommands.get(command2.stoppableCommandKey);
      if (stoppableCommand) {
        stoppableCommand.stopExecution();
      }
      this.stoppableCommands.set(command2.stoppableCommandKey, command2);
    }
    this.currentPromise = this.currentPromise.then((state) => new Promise((resolve2) => {
      let target;
      if (command2 instanceof command_1$j.HiddenCommand)
        target = "hidden";
      else if (command2 instanceof command_1$j.PopupCommand)
        target = "popup";
      else
        target = "main";
      const context = this.createContext(state.main.model);
      let commandResult;
      try {
        commandResult = operation.call(command2, context);
      } catch (error) {
        this.logger.error(this, "Failed to execute command:", error);
        commandResult = state[target].model;
      }
      const newState = copyState(state);
      if (commandResult instanceof Promise) {
        commandResult.then((newModel) => {
          if (target === "main")
            beforeResolve.call(this, command2, context);
          newState[target] = {
            model: newModel,
            modelChanged: true
          };
          resolve2(newState);
        });
      } else if (commandResult instanceof smodel_1$n.SModelRootImpl) {
        if (target === "main")
          beforeResolve.call(this, command2, context);
        newState[target] = {
          model: commandResult,
          modelChanged: true
        };
        resolve2(newState);
      } else {
        if (target === "main")
          beforeResolve.call(this, command2, context);
        newState[target] = {
          model: commandResult.model,
          modelChanged: state[target].modelChanged || commandResult.modelChanged,
          cause: commandResult.cause
        };
        resolve2(newState);
      }
    }));
  }
  pushToUndoStack(command2) {
    this.undoStack.push(command2);
    if (this.options.undoHistoryLimit >= 0 && this.undoStack.length > this.options.undoHistoryLimit)
      this.undoStack.splice(0, this.undoStack.length - this.options.undoHistoryLimit);
  }
  /**
   * Notifies the Viewer to render the new model and/or the new hidden model
   * and returns a Promise for the new model.
   */
  thenUpdate() {
    this.currentPromise = this.currentPromise.then((state) => {
      const newState = copyState(state);
      if (state.hidden.modelChanged) {
        this.updateHidden(state.hidden.model, state.hidden.cause);
        newState.hidden.modelChanged = false;
        newState.hidden.cause = void 0;
      }
      if (state.main.modelChanged) {
        this.update(state.main.model, state.main.cause);
        newState.main.modelChanged = false;
        newState.main.cause = void 0;
      }
      if (state.popup.modelChanged) {
        this.updatePopup(state.popup.model, state.popup.cause);
        newState.popup.modelChanged = false;
        newState.popup.cause = void 0;
      }
      return newState;
    });
    return this.currentModel;
  }
  /**
   * Notify the `ModelViewer` that the model has changed.
   */
  update(model2, cause) {
    if (this.modelViewer === void 0) {
      this.modelViewer = this.viewerProvider.modelViewer;
    }
    this.modelViewer.update(model2, cause);
  }
  /**
   * Notify the `HiddenModelViewer` that the hidden model has changed.
   */
  updateHidden(model2, cause) {
    if (this.hiddenModelViewer === void 0) {
      this.hiddenModelViewer = this.viewerProvider.hiddenModelViewer;
    }
    this.hiddenModelViewer.update(model2, cause);
  }
  /**
   * Notify the `PopupModelViewer` that the popup model has changed.
   */
  updatePopup(model2, cause) {
    if (this.popupModelViewer === void 0) {
      this.popupModelViewer = this.viewerProvider.popupModelViewer;
    }
    this.popupModelViewer.update(model2, cause);
  }
  /**
   * Handling of commands after their execution.
   *
   * Hidden commands are not pushed to any stack.
   *
   * System commands are pushed to the <code>offStack</code> when the redo
   * stack is not empty, allowing to undo the before a redo to keep the chain
   * of commands consistent.
   *
   * Mergable commands are merged if possible.
   */
  mergeOrPush(command2, context) {
    if (this.isBlockUndo(command2)) {
      this.undoStack = [];
      this.redoStack = [];
      this.offStack = [];
      this.pushToUndoStack(command2);
      return;
    }
    if (this.isPushToOffStack(command2) && this.redoStack.length > 0) {
      if (this.offStack.length > 0) {
        const lastCommand = this.offStack[this.offStack.length - 1];
        if (lastCommand instanceof command_1$j.MergeableCommand && lastCommand.merge(command2, context))
          return;
      }
      this.offStack.push(command2);
      return;
    }
    if (this.isPushToUndoStack(command2)) {
      this.offStack.forEach((c) => this.undoStack.push(c));
      this.offStack = [];
      this.redoStack = [];
      if (this.undoStack.length > 0) {
        const lastCommand = this.undoStack[this.undoStack.length - 1];
        if (lastCommand instanceof command_1$j.MergeableCommand && lastCommand.merge(command2, context))
          return;
      }
      this.pushToUndoStack(command2);
    }
  }
  /**
   * Reverts all system commands on the offStack.
   */
  undoOffStackSystemCommands() {
    let command2 = this.offStack.pop();
    while (command2 !== void 0) {
      this.logger.log(this, "Undoing off-stack", command2);
      this.handleCommand(command2, command2.undo, () => {
      });
      command2 = this.offStack.pop();
    }
  }
  /**
   * System commands should be transparent to the user, so this method
   * is called from <code>undo()</code> to revert all system commands
   * at the top of the undoStack.
   */
  undoPreceedingSystemCommands() {
    let command2 = this.undoStack[this.undoStack.length - 1];
    while (command2 !== void 0 && this.isPushToOffStack(command2)) {
      this.undoStack.pop();
      this.logger.log(this, "Undoing", command2);
      this.handleCommand(command2, command2.undo, (c, context) => {
        this.redoStack.push(c);
      });
      command2 = this.undoStack[this.undoStack.length - 1];
    }
  }
  /**
   * System commands should be transparent to the user, so this method
   * is called from <code>redo()</code> to re-execute all system commands
   * at the top of the redoStack.
   */
  redoFollowingSystemCommands() {
    let command2 = this.redoStack[this.redoStack.length - 1];
    while (command2 !== void 0 && this.isPushToOffStack(command2)) {
      this.redoStack.pop();
      this.logger.log(this, "Redoing ", command2);
      this.handleCommand(command2, command2.redo, (c, context) => {
        this.pushToUndoStack(c);
      });
      command2 = this.redoStack[this.redoStack.length - 1];
    }
  }
  /**
   * Assembles the context object that is passed to the commands execution method.
   */
  createContext(currentModel) {
    return {
      root: currentModel,
      modelChanged: this,
      modelFactory: this.modelFactory,
      duration: this.options.defaultDuration,
      logger: this.logger,
      syncer: this.syncer
    };
  }
  isPushToOffStack(command2) {
    return command2 instanceof command_1$j.SystemCommand;
  }
  isPushToUndoStack(command2) {
    return !(command2 instanceof command_1$j.HiddenCommand);
  }
  isBlockUndo(command2) {
    return command2 instanceof command_1$j.ResetCommand;
  }
};
commandStack.CommandStack = CommandStack;
__decorate$1a([(0, inversify_1$1x.inject)(types_1$12.TYPES.IModelFactory), __metadata$O("design:type", Object)], CommandStack.prototype, "modelFactory", void 0);
__decorate$1a([(0, inversify_1$1x.inject)(types_1$12.TYPES.IViewerProvider), __metadata$O("design:type", Object)], CommandStack.prototype, "viewerProvider", void 0);
__decorate$1a([(0, inversify_1$1x.inject)(types_1$12.TYPES.ILogger), __metadata$O("design:type", Object)], CommandStack.prototype, "logger", void 0);
__decorate$1a([(0, inversify_1$1x.inject)(types_1$12.TYPES.AnimationFrameSyncer), __metadata$O("design:type", animation_frame_syncer_1$2.AnimationFrameSyncer)], CommandStack.prototype, "syncer", void 0);
__decorate$1a([(0, inversify_1$1x.inject)(types_1$12.TYPES.CommandStackOptions), __metadata$O("design:type", Object)], CommandStack.prototype, "options", void 0);
__decorate$1a([(0, inversify_1$1x.postConstruct)(), __metadata$O("design:type", Function), __metadata$O("design:paramtypes", []), __metadata$O("design:returntype", void 0)], CommandStack.prototype, "initialize", null);
commandStack.CommandStack = CommandStack = __decorate$1a([(0, inversify_1$1x.injectable)()], CommandStack);
function copyState(state) {
  return {
    main: Object.assign({}, state.main),
    hidden: Object.assign({}, state.hidden),
    popup: Object.assign({}, state.popup)
  };
}
var initializeCanvas = {};
var browser = {};
Object.defineProperty(browser, "__esModule", {
  value: true
});
browser.isSVGGraphicsElement = browser.hitsMouseEvent = browser.getWindowScroll = browser.isCrossSite = browser.isMac = browser.isCtrlOrCmd = void 0;
const sprotty_protocol_1$7 = lib;
function isCtrlOrCmd(event) {
  if (isMac())
    return event.metaKey;
  else
    return event.ctrlKey;
}
browser.isCtrlOrCmd = isCtrlOrCmd;
function isMac() {
  return window.navigator.userAgent.indexOf("Mac") !== -1;
}
browser.isMac = isMac;
function isCrossSite(url) {
  if (url && typeof window !== "undefined" && window.location) {
    let baseURL = "";
    if (window.location.protocol)
      baseURL += window.location.protocol + "//";
    if (window.location.host)
      baseURL += window.location.host;
    return baseURL.length > 0 && !url.startsWith(baseURL);
  }
  return false;
}
browser.isCrossSite = isCrossSite;
function getWindowScroll() {
  if (typeof window === "undefined") {
    return sprotty_protocol_1$7.Point.ORIGIN;
  }
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
}
browser.getWindowScroll = getWindowScroll;
function hitsMouseEvent(child, event) {
  const clientRect = child.getBoundingClientRect();
  return event.clientX >= clientRect.left && event.clientX <= clientRect.right && event.clientY >= clientRect.top && event.clientY <= clientRect.bottom;
}
browser.hitsMouseEvent = hitsMouseEvent;
function isSVGGraphicsElement(node) {
  return typeof node.getBBox === "function";
}
browser.isSVGGraphicsElement = isSVGGraphicsElement;
var __decorate$19 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$N = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$r = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(initializeCanvas, "__esModule", {
  value: true
});
initializeCanvas.InitializeCanvasBoundsCommand = initializeCanvas.InitializeCanvasBoundsAction = initializeCanvas.CanvasBoundsInitializer = void 0;
const inversify_1$1w = require$$0$1;
const geometry_1$s = geometry$1;
const types_1$11 = types;
const smodel_1$m = smodel;
const command_1$i = command;
const browser_1$6 = browser;
let CanvasBoundsInitializer = class CanvasBoundsInitializer2 {
  decorate(vnode2, element) {
    if (element instanceof smodel_1$m.SModelRootImpl && !geometry_1$s.Dimension.isValid(element.canvasBounds)) {
      this.rootAndVnode = [element, vnode2];
    }
    return vnode2;
  }
  postUpdate() {
    if (this.rootAndVnode !== void 0) {
      const domElement = this.rootAndVnode[1].elm;
      const oldBounds = this.rootAndVnode[0].canvasBounds;
      if (domElement !== void 0) {
        const newBounds = this.getBoundsInPage(domElement);
        if (!((0, geometry_1$s.almostEquals)(newBounds.x, oldBounds.x) && (0, geometry_1$s.almostEquals)(newBounds.y, oldBounds.y) && (0, geometry_1$s.almostEquals)(newBounds.width, oldBounds.width) && (0, geometry_1$s.almostEquals)(newBounds.height, oldBounds.width)))
          this.actionDispatcher.dispatch(InitializeCanvasBoundsAction.create(newBounds));
      }
      this.rootAndVnode = void 0;
    }
  }
  getBoundsInPage(element) {
    const bounds = element.getBoundingClientRect();
    const scroll2 = (0, browser_1$6.getWindowScroll)();
    return {
      x: bounds.left + scroll2.x,
      y: bounds.top + scroll2.y,
      width: bounds.width,
      height: bounds.height
    };
  }
};
initializeCanvas.CanvasBoundsInitializer = CanvasBoundsInitializer;
__decorate$19([(0, inversify_1$1w.inject)(types_1$11.TYPES.IActionDispatcher), __metadata$N("design:type", Object)], CanvasBoundsInitializer.prototype, "actionDispatcher", void 0);
initializeCanvas.CanvasBoundsInitializer = CanvasBoundsInitializer = __decorate$19([(0, inversify_1$1w.injectable)()], CanvasBoundsInitializer);
var InitializeCanvasBoundsAction;
(function(InitializeCanvasBoundsAction2) {
  InitializeCanvasBoundsAction2.KIND = "initializeCanvasBounds";
  function create2(newCanvasBounds) {
    return {
      kind: InitializeCanvasBoundsAction2.KIND,
      newCanvasBounds
    };
  }
  InitializeCanvasBoundsAction2.create = create2;
})(InitializeCanvasBoundsAction || (initializeCanvas.InitializeCanvasBoundsAction = InitializeCanvasBoundsAction = {}));
let InitializeCanvasBoundsCommand = class InitializeCanvasBoundsCommand2 extends command_1$i.SystemCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    this.newCanvasBounds = this.action.newCanvasBounds;
    context.root.canvasBounds = this.newCanvasBounds;
    return context.root;
  }
  undo(context) {
    return context.root;
  }
  redo(context) {
    return context.root;
  }
};
initializeCanvas.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand;
InitializeCanvasBoundsCommand.KIND = InitializeCanvasBoundsAction.KIND;
initializeCanvas.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand = __decorate$19([(0, inversify_1$1w.injectable)(), __param$r(0, (0, inversify_1$1w.inject)(types_1$11.TYPES.Action)), __metadata$N("design:paramtypes", [Object])], InitializeCanvasBoundsCommand);
var setModel = {};
var __decorate$18 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$M = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$q = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(setModel, "__esModule", {
  value: true
});
setModel.SetModelCommand = void 0;
const inversify_1$1v = require$$0$1;
const actions_1$q = actions;
const command_1$h = command;
const types_1$10 = types;
const initialize_canvas_1$2 = initializeCanvas;
let SetModelCommand = class SetModelCommand2 extends command_1$h.ResetCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    this.oldRoot = context.modelFactory.createRoot(context.root);
    this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
    return this.newRoot;
  }
  undo(context) {
    return this.oldRoot;
  }
  redo(context) {
    return this.newRoot;
  }
  get blockUntil() {
    return (action2) => action2.kind === initialize_canvas_1$2.InitializeCanvasBoundsCommand.KIND;
  }
};
setModel.SetModelCommand = SetModelCommand;
SetModelCommand.KIND = actions_1$q.SetModelAction.KIND;
setModel.SetModelCommand = SetModelCommand = __decorate$18([(0, inversify_1$1v.injectable)(), __param$q(0, (0, inversify_1$1v.inject)(types_1$10.TYPES.Action)), __metadata$M("design:paramtypes", [Object])], SetModelCommand);
var smodelUtils = {};
Object.defineProperty(smodelUtils, "__esModule", {
  value: true
});
smodelUtils.transformToRootBounds = smodelUtils.containsSome = smodelUtils.translateBounds = smodelUtils.translatePoint = smodelUtils.findParentByFeature = smodelUtils.findParent = smodelUtils.registerModelElement = void 0;
const types_1$$ = types;
const smodel_1$l = smodel;
function registerModelElement(context, type, constr, features, isOverride) {
  context.bind(types_1$$.TYPES.SModelElementRegistration).toConstantValue({
    type,
    constr,
    features,
    isOverride
  });
}
smodelUtils.registerModelElement = registerModelElement;
function findParent(element, predicate) {
  let current = element;
  while (current !== void 0) {
    if (predicate(current))
      return current;
    else if (current instanceof smodel_1$l.SChildElementImpl)
      current = current.parent;
    else
      current = void 0;
  }
  return current;
}
smodelUtils.findParent = findParent;
function findParentByFeature(element, predicate) {
  let current = element;
  while (current !== void 0) {
    if (predicate(current))
      return current;
    else if (current instanceof smodel_1$l.SChildElementImpl)
      current = current.parent;
    else
      current = void 0;
  }
  return current;
}
smodelUtils.findParentByFeature = findParentByFeature;
function translatePoint(point, source, target) {
  if (source !== target) {
    while (source instanceof smodel_1$l.SChildElementImpl) {
      point = source.localToParent(point);
      source = source.parent;
      if (source === target)
        return point;
    }
    const targetTrace = [];
    while (target instanceof smodel_1$l.SChildElementImpl) {
      targetTrace.push(target);
      target = target.parent;
    }
    if (source !== target)
      throw new Error("Incompatible source and target: " + source.id + ", " + target.id);
    for (let i = targetTrace.length - 1; i >= 0; i--) {
      point = targetTrace[i].parentToLocal(point);
    }
  }
  return point;
}
smodelUtils.translatePoint = translatePoint;
function translateBounds(bounds, source, target) {
  const upperLeft = translatePoint(bounds, source, target);
  const lowerRight = translatePoint({
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  }, source, target);
  return {
    x: upperLeft.x,
    y: upperLeft.y,
    width: lowerRight.x - upperLeft.x,
    height: lowerRight.y - upperLeft.y
  };
}
smodelUtils.translateBounds = translateBounds;
function containsSome(root, element) {
  const test = (el2) => root.index.getById(el2.id) !== void 0;
  const find = (elements) => elements.some((el2) => test(el2) || find(el2.children));
  return find([element]);
}
smodelUtils.containsSome = containsSome;
function transformToRootBounds(parent, bounds) {
  while (parent instanceof smodel_1$l.SChildElementImpl) {
    bounds = parent.localToParent(bounds);
    parent = parent.parent;
  }
  return bounds;
}
smodelUtils.transformToRootBounds = transformToRootBounds;
var uiExtensionRegistry = {};
var __decorate$17 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$L = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$p = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(uiExtensionRegistry, "__esModule", {
  value: true
});
uiExtensionRegistry.SetUIExtensionVisibilityCommand = uiExtensionRegistry.SetUIExtensionVisibilityAction = uiExtensionRegistry.UIExtensionRegistry = void 0;
const inversify_1$1u = require$$0$1;
const registry_1$4 = registry;
const command_1$g = command;
const types_1$_ = types;
let UIExtensionRegistry = class UIExtensionRegistry2 extends registry_1$4.InstanceRegistry {
  constructor(extensions = []) {
    super();
    extensions.forEach((extension) => this.register(extension.id(), extension));
  }
};
uiExtensionRegistry.UIExtensionRegistry = UIExtensionRegistry;
uiExtensionRegistry.UIExtensionRegistry = UIExtensionRegistry = __decorate$17([(0, inversify_1$1u.injectable)(), __param$p(0, (0, inversify_1$1u.multiInject)(types_1$_.TYPES.IUIExtension)), __param$p(0, (0, inversify_1$1u.optional)()), __metadata$L("design:paramtypes", [Array])], UIExtensionRegistry);
var SetUIExtensionVisibilityAction;
(function(SetUIExtensionVisibilityAction2) {
  SetUIExtensionVisibilityAction2.KIND = "setUIExtensionVisibility";
  function create2(options) {
    var _a;
    return {
      kind: SetUIExtensionVisibilityAction2.KIND,
      extensionId: options.extensionId,
      visible: options.visible,
      contextElementsId: (_a = options.contextElementsId) !== null && _a !== void 0 ? _a : []
    };
  }
  SetUIExtensionVisibilityAction2.create = create2;
})(SetUIExtensionVisibilityAction || (uiExtensionRegistry.SetUIExtensionVisibilityAction = SetUIExtensionVisibilityAction = {}));
let SetUIExtensionVisibilityCommand = class SetUIExtensionVisibilityCommand2 extends command_1$g.SystemCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    const extension = this.registry.get(this.action.extensionId);
    if (extension) {
      this.action.visible ? extension.show(context.root, ...this.action.contextElementsId) : extension.hide();
    }
    return {
      model: context.root,
      modelChanged: false
    };
  }
  undo(context) {
    return {
      model: context.root,
      modelChanged: false
    };
  }
  redo(context) {
    return {
      model: context.root,
      modelChanged: false
    };
  }
};
uiExtensionRegistry.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand;
SetUIExtensionVisibilityCommand.KIND = SetUIExtensionVisibilityAction.KIND;
__decorate$17([(0, inversify_1$1u.inject)(types_1$_.TYPES.UIExtensionRegistry), __metadata$L("design:type", UIExtensionRegistry)], SetUIExtensionVisibilityCommand.prototype, "registry", void 0);
uiExtensionRegistry.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand = __decorate$17([(0, inversify_1$1u.injectable)(), __param$p(0, (0, inversify_1$1u.inject)(types_1$_.TYPES.Action)), __metadata$L("design:paramtypes", [Object])], SetUIExtensionVisibilityCommand);
var uiExtension = {};
var __decorate$16 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$K = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(uiExtension, "__esModule", {
  value: true
});
uiExtension.AbstractUIExtension = uiExtension.isUIExtension = void 0;
const inversify_1$1t = require$$0$1;
const sprotty_protocol_1$6 = lib;
const types_1$Z = types;
function isUIExtension(object2) {
  return (0, sprotty_protocol_1$6.hasOwnProperty)(object2, "id", "function") && (0, sprotty_protocol_1$6.hasOwnProperty)(object2, "show", "function") && (0, sprotty_protocol_1$6.hasOwnProperty)(object2, "hide", "function");
}
uiExtension.isUIExtension = isUIExtension;
let AbstractUIExtension = class AbstractUIExtension2 {
  show(root, ...contextElementIds) {
    this.activeElement = document.activeElement;
    if (!this.containerElement) {
      if (!this.initialize())
        return;
    }
    this.onBeforeShow(this.containerElement, root, ...contextElementIds);
    this.setContainerVisible(true);
  }
  hide() {
    this.setContainerVisible(false);
    this.restoreFocus();
    this.activeElement = null;
  }
  restoreFocus() {
    const focusedElement = this.activeElement;
    if (focusedElement) {
      focusedElement.focus();
    }
  }
  initialize() {
    const baseDiv = document.getElementById(this.options.baseDiv);
    if (!baseDiv) {
      this.logger.warn(this, `Could not obtain sprotty base container for initializing UI extension ${this.id}`, this);
      return false;
    }
    this.containerElement = this.getOrCreateContainer(baseDiv.id);
    this.initializeContents(this.containerElement);
    if (baseDiv) {
      baseDiv.insertBefore(this.containerElement, baseDiv.firstChild);
    }
    return true;
  }
  getOrCreateContainer(baseDivId) {
    let container = document.getElementById(this.id());
    if (container === null) {
      container = document.createElement("div");
      container.id = baseDivId + "_" + this.id();
      container.classList.add(this.containerClass());
    }
    return container;
  }
  setContainerVisible(visible) {
    if (this.containerElement) {
      if (visible) {
        this.containerElement.style.visibility = "visible";
        this.containerElement.style.opacity = "1";
      } else {
        this.containerElement.style.visibility = "hidden";
        this.containerElement.style.opacity = "0";
      }
    }
  }
  /**
   * Updates the `containerElement` under the given `context` before it becomes visible.
   *
   * Subclasses may override this method to, for instance, modifying the position of the
   * `containerElement`, add or remove elements, etc. depending on the specified `root`
   * or `contextElementIds`.
   */
  onBeforeShow(containerElement, root, ...contextElementIds) {
  }
};
uiExtension.AbstractUIExtension = AbstractUIExtension;
__decorate$16([(0, inversify_1$1t.inject)(types_1$Z.TYPES.ViewerOptions), __metadata$K("design:type", Object)], AbstractUIExtension.prototype, "options", void 0);
__decorate$16([(0, inversify_1$1t.inject)(types_1$Z.TYPES.ILogger), __metadata$K("design:type", Object)], AbstractUIExtension.prototype, "logger", void 0);
uiExtension.AbstractUIExtension = AbstractUIExtension = __decorate$16([(0, inversify_1$1t.injectable)()], AbstractUIExtension);
var keyTool = {};
var vnodeUtils = {};
Object.defineProperty(vnodeUtils, "__esModule", {
  value: true
});
vnodeUtils.getAttrs = vnodeUtils.on = vnodeUtils.mergeStyle = vnodeUtils.copyClassesFromElement = vnodeUtils.copyClassesFromVNode = vnodeUtils.setNamespace = vnodeUtils.setClass = vnodeUtils.setAttr = void 0;
function setAttr(vnode2, name, value) {
  getAttrs(vnode2)[name] = value;
}
vnodeUtils.setAttr = setAttr;
function setClass(vnode2, name, value) {
  getClass(vnode2)[name] = value;
}
vnodeUtils.setClass = setClass;
function setNamespace(node, ns) {
  if (node.data === void 0)
    node.data = {};
  node.data.ns = ns;
  const children = node.children;
  if (children !== void 0) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (typeof child !== "string")
        setNamespace(child, ns);
    }
  }
}
vnodeUtils.setNamespace = setNamespace;
function copyClassesFromVNode(source, target) {
  const classList = getClass(source);
  Object.keys(classList).forEach((c) => setClass(target, c, true));
}
vnodeUtils.copyClassesFromVNode = copyClassesFromVNode;
function copyClassesFromElement(element, target) {
  const classList = element.classList;
  for (let i = 0; i < classList.length; i++) {
    const item = classList.item(i);
    if (item)
      setClass(target, item, true);
  }
}
vnodeUtils.copyClassesFromElement = copyClassesFromElement;
function mergeStyle(vnode2, style) {
  getData(vnode2).style = Object.assign(Object.assign({}, getData(vnode2).style || {}), style);
}
vnodeUtils.mergeStyle = mergeStyle;
function on(vnode2, event, listener) {
  const val = getOn(vnode2);
  if (val[event]) {
    throw new Error("EventListener for " + event + " already registered on VNode");
  }
  val[event] = listener;
}
vnodeUtils.on = on;
function getAttrs(vnode2) {
  const data = getData(vnode2);
  if (!data.attrs)
    data.attrs = {};
  return data.attrs;
}
vnodeUtils.getAttrs = getAttrs;
function getData(vnode2) {
  if (!vnode2.data)
    vnode2.data = {};
  return vnode2.data;
}
function getClass(vnode2) {
  const data = getData(vnode2);
  if (!data.class)
    data.class = {};
  return data.class;
}
function getOn(vnode2) {
  const data = getData(vnode2);
  if (!data.on)
    data.on = {};
  return data.on;
}
var __decorate$15 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$J = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$o = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(keyTool, "__esModule", {
  value: true
});
keyTool.KeyListener = keyTool.KeyTool = void 0;
const inversify_1$1s = require$$0$1;
const types_1$Y = types;
const smodel_1$k = smodel;
const vnode_utils_1$f = vnodeUtils;
let KeyTool = class KeyTool2 {
  constructor(keyListeners = []) {
    this.keyListeners = keyListeners;
  }
  register(keyListener) {
    this.keyListeners.push(keyListener);
  }
  deregister(keyListener) {
    const index = this.keyListeners.indexOf(keyListener);
    if (index >= 0)
      this.keyListeners.splice(index, 1);
  }
  handleEvent(methodName, model2, event) {
    const actions2 = this.keyListeners.map((listener) => listener[methodName].apply(listener, [model2, event])).reduce((a, b) => a.concat(b));
    if (actions2.length > 0) {
      event.preventDefault();
      this.actionDispatcher.dispatchAll(actions2);
    }
  }
  keyDown(element, event) {
    this.handleEvent("keyDown", element, event);
  }
  keyUp(element, event) {
    this.handleEvent("keyUp", element, event);
  }
  focus() {
  }
  decorate(vnode2, element) {
    if (element instanceof smodel_1$k.SModelRootImpl) {
      (0, vnode_utils_1$f.on)(vnode2, "focus", this.focus.bind(this, element));
      (0, vnode_utils_1$f.on)(vnode2, "keydown", this.keyDown.bind(this, element));
      (0, vnode_utils_1$f.on)(vnode2, "keyup", this.keyUp.bind(this, element));
    }
    return vnode2;
  }
  postUpdate() {
  }
};
keyTool.KeyTool = KeyTool;
__decorate$15([(0, inversify_1$1s.inject)(types_1$Y.TYPES.IActionDispatcher), __metadata$J("design:type", Object)], KeyTool.prototype, "actionDispatcher", void 0);
keyTool.KeyTool = KeyTool = __decorate$15([(0, inversify_1$1s.injectable)(), __param$o(0, (0, inversify_1$1s.multiInject)(types_1$Y.TYPES.KeyListener)), __param$o(0, (0, inversify_1$1s.optional)()), __metadata$J("design:paramtypes", [Array])], KeyTool);
let KeyListener = class KeyListener2 {
  keyDown(element, event) {
    return [];
  }
  keyUp(element, event) {
    return [];
  }
};
keyTool.KeyListener = KeyListener;
keyTool.KeyListener = KeyListener = __decorate$15([(0, inversify_1$1s.injectable)()], KeyListener);
var mouseTool = {};
var domHelper = {};
var __decorate$14 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$I = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(domHelper, "__esModule", {
  value: true
});
domHelper.DOMHelper = void 0;
const inversify_1$1r = require$$0$1;
const types_1$X = types;
let DOMHelper = class DOMHelper2 {
  getPrefix() {
    const prefix = this.viewerOptions !== void 0 && this.viewerOptions.baseDiv !== void 0 ? this.viewerOptions.baseDiv + "_" : "";
    return prefix;
  }
  createUniqueDOMElementId(element) {
    return this.getPrefix() + element.id;
  }
  findSModelIdByDOMElement(element) {
    return element.id.replace(this.getPrefix(), "");
  }
};
domHelper.DOMHelper = DOMHelper;
__decorate$14([(0, inversify_1$1r.inject)(types_1$X.TYPES.ViewerOptions), __metadata$I("design:type", Object)], DOMHelper.prototype, "viewerOptions", void 0);
domHelper.DOMHelper = DOMHelper = __decorate$14([(0, inversify_1$1r.injectable)()], DOMHelper);
var __decorate$13 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$H = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$n = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(mouseTool, "__esModule", {
  value: true
});
mouseTool.MousePositionTracker = mouseTool.MouseListener = mouseTool.PopupMouseTool = mouseTool.MouseTool = void 0;
const inversify_1$1q = require$$0$1;
const actions_1$p = actions;
const smodel_1$j = smodel;
const types_1$W = types;
const dom_helper_1$4 = domHelper;
const vnode_utils_1$e = vnodeUtils;
let MouseTool = class MouseTool2 {
  constructor(mouseListeners = []) {
    this.mouseListeners = mouseListeners;
  }
  register(mouseListener2) {
    this.mouseListeners.push(mouseListener2);
  }
  deregister(mouseListener2) {
    const index = this.mouseListeners.indexOf(mouseListener2);
    if (index >= 0)
      this.mouseListeners.splice(index, 1);
  }
  getTargetElement(model2, event) {
    let target = event.target;
    const index = model2.index;
    while (target) {
      if (target.id) {
        const element = index.getById(this.domHelper.findSModelIdByDOMElement(target));
        if (element !== void 0)
          return element;
      }
      target = target.parentNode;
    }
    return void 0;
  }
  handleEvent(methodName, model2, event) {
    this.focusOnMouseEvent(methodName, model2);
    const element = this.getTargetElement(model2, event);
    if (!element)
      return;
    const actions2 = this.mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a, b) => a.concat(b));
    if (actions2.length > 0) {
      event.preventDefault();
      for (const actionOrPromise of actions2) {
        if ((0, actions_1$p.isAction)(actionOrPromise)) {
          this.actionDispatcher.dispatch(actionOrPromise);
        } else {
          actionOrPromise.then((action2) => {
            this.actionDispatcher.dispatch(action2);
          });
        }
      }
    }
  }
  focusOnMouseEvent(methodName, model2) {
    if (document && methodName === "mouseDown") {
      const domElement = document.getElementById(this.domHelper.createUniqueDOMElementId(model2));
      if (domElement !== null && typeof domElement.focus === "function")
        domElement.focus();
    }
  }
  mouseOver(model2, event) {
    this.handleEvent("mouseOver", model2, event);
  }
  mouseOut(model2, event) {
    this.handleEvent("mouseOut", model2, event);
  }
  mouseEnter(model2, event) {
    this.handleEvent("mouseEnter", model2, event);
  }
  mouseLeave(model2, event) {
    this.handleEvent("mouseLeave", model2, event);
  }
  mouseDown(model2, event) {
    this.handleEvent("mouseDown", model2, event);
  }
  mouseMove(model2, event) {
    this.handleEvent("mouseMove", model2, event);
  }
  mouseUp(model2, event) {
    this.handleEvent("mouseUp", model2, event);
  }
  wheel(model2, event) {
    this.handleEvent("wheel", model2, event);
  }
  contextMenu(model2, event) {
    event.preventDefault();
    this.handleEvent("contextMenu", model2, event);
  }
  doubleClick(model2, event) {
    this.handleEvent("doubleClick", model2, event);
  }
  decorate(vnode2, element) {
    if (element instanceof smodel_1$j.SModelRootImpl) {
      (0, vnode_utils_1$e.on)(vnode2, "mouseover", this.mouseOver.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mouseout", this.mouseOut.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mouseenter", this.mouseEnter.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mouseleave", this.mouseLeave.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mousedown", this.mouseDown.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mouseup", this.mouseUp.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "mousemove", this.mouseMove.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "wheel", this.wheel.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "contextmenu", this.contextMenu.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "dblclick", this.doubleClick.bind(this, element));
      (0, vnode_utils_1$e.on)(vnode2, "dragover", (event) => this.handleEvent("dragOver", element, event));
      (0, vnode_utils_1$e.on)(vnode2, "drop", (event) => this.handleEvent("drop", element, event));
    }
    vnode2 = this.mouseListeners.reduce((n, listener) => listener.decorate(n, element), vnode2);
    return vnode2;
  }
  postUpdate() {
  }
};
mouseTool.MouseTool = MouseTool;
__decorate$13([(0, inversify_1$1q.inject)(types_1$W.TYPES.IActionDispatcher), __metadata$H("design:type", Object)], MouseTool.prototype, "actionDispatcher", void 0);
__decorate$13([(0, inversify_1$1q.inject)(types_1$W.TYPES.DOMHelper), __metadata$H("design:type", dom_helper_1$4.DOMHelper)], MouseTool.prototype, "domHelper", void 0);
mouseTool.MouseTool = MouseTool = __decorate$13([(0, inversify_1$1q.injectable)(), __param$n(0, (0, inversify_1$1q.multiInject)(types_1$W.TYPES.MouseListener)), __param$n(0, (0, inversify_1$1q.optional)()), __metadata$H("design:paramtypes", [Array])], MouseTool);
let PopupMouseTool = class PopupMouseTool2 extends MouseTool {
  constructor(mouseListeners = []) {
    super(mouseListeners);
    this.mouseListeners = mouseListeners;
  }
};
mouseTool.PopupMouseTool = PopupMouseTool;
mouseTool.PopupMouseTool = PopupMouseTool = __decorate$13([(0, inversify_1$1q.injectable)(), __param$n(0, (0, inversify_1$1q.multiInject)(types_1$W.TYPES.PopupMouseListener)), __param$n(0, (0, inversify_1$1q.optional)()), __metadata$H("design:paramtypes", [Array])], PopupMouseTool);
let MouseListener = class MouseListener2 {
  mouseOver(target, event) {
    return [];
  }
  mouseOut(target, event) {
    return [];
  }
  mouseEnter(target, event) {
    return [];
  }
  mouseLeave(target, event) {
    return [];
  }
  mouseDown(target, event) {
    return [];
  }
  mouseMove(target, event) {
    return [];
  }
  mouseUp(target, event) {
    return [];
  }
  wheel(target, event) {
    return [];
  }
  doubleClick(target, event) {
    return [];
  }
  contextMenu(target, event) {
    return [];
  }
  dragOver(target, event) {
    return [];
  }
  drop(target, event) {
    return [];
  }
  decorate(vnode2, element) {
    return vnode2;
  }
};
mouseTool.MouseListener = MouseListener;
mouseTool.MouseListener = MouseListener = __decorate$13([(0, inversify_1$1q.injectable)()], MouseListener);
let MousePositionTracker = class MousePositionTracker2 extends MouseListener {
  mouseMove(target, event) {
    this.lastPosition = target.root.parentToLocal({
      x: event.offsetX,
      y: event.offsetY
    });
    return [];
  }
  /**
   * Returns the last tracked mouse cursor position relative to the diagram root or `undefined`
   * if no mouse cursor position was ever tracked yet.
   */
  get lastPositionOnDiagram() {
    return this.lastPosition;
  }
};
mouseTool.MousePositionTracker = MousePositionTracker;
mouseTool.MousePositionTracker = MousePositionTracker = __decorate$13([(0, inversify_1$1q.injectable)()], MousePositionTracker);
var thunkView = {};
function createElement(tagName2, options) {
  return document.createElement(tagName2, options);
}
function createElementNS(namespaceURI, qualifiedName, options) {
  return document.createElementNS(namespaceURI, qualifiedName, options);
}
function createDocumentFragment() {
  return parseFragment(document.createDocumentFragment());
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function createComment(text) {
  return document.createComment(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  if (isDocumentFragment$1(parentNode2)) {
    let node = parentNode2;
    while (node && isDocumentFragment$1(node)) {
      const fragment2 = parseFragment(node);
      node = fragment2.parent;
    }
    parentNode2 = node !== null && node !== void 0 ? node : parentNode2;
  }
  if (isDocumentFragment$1(newNode)) {
    newNode = parseFragment(newNode, parentNode2);
  }
  if (referenceNode && isDocumentFragment$1(referenceNode)) {
    referenceNode = parseFragment(referenceNode).firstChildNode;
  }
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  if (isDocumentFragment$1(child)) {
    child = parseFragment(child, node);
  }
  node.appendChild(child);
}
function parentNode(node) {
  if (isDocumentFragment$1(node)) {
    while (node && isDocumentFragment$1(node)) {
      const fragment2 = parseFragment(node);
      node = fragment2.parent;
    }
    return node !== null && node !== void 0 ? node : null;
  }
  return node.parentNode;
}
function nextSibling(node) {
  var _a;
  if (isDocumentFragment$1(node)) {
    const fragment2 = parseFragment(node);
    const parent = parentNode(fragment2);
    if (parent && fragment2.lastChildNode) {
      const children = Array.from(parent.childNodes);
      const index = children.indexOf(fragment2.lastChildNode);
      return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;
    }
    return null;
  }
  return node.nextSibling;
}
function tagName(elm) {
  return elm.tagName;
}
function setTextContent(node, text) {
  node.textContent = text;
}
function getTextContent(node) {
  return node.textContent;
}
function isElement$1(node) {
  return node.nodeType === 1;
}
function isText(node) {
  return node.nodeType === 3;
}
function isComment(node) {
  return node.nodeType === 8;
}
function isDocumentFragment$1(node) {
  return node.nodeType === 11;
}
function parseFragment(fragmentNode, parentNode2) {
  var _a, _b, _c;
  const fragment2 = fragmentNode;
  (_a = fragment2.parent) !== null && _a !== void 0 ? _a : fragment2.parent = parentNode2 !== null && parentNode2 !== void 0 ? parentNode2 : null;
  (_b = fragment2.firstChildNode) !== null && _b !== void 0 ? _b : fragment2.firstChildNode = fragmentNode.firstChild;
  (_c = fragment2.lastChildNode) !== null && _c !== void 0 ? _c : fragment2.lastChildNode = fragmentNode.lastChild;
  return fragment2;
}
const htmlDomApi = {
  createElement,
  createElementNS,
  createTextNode,
  createDocumentFragment,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  getTextContent,
  isElement: isElement$1,
  isText,
  isComment,
  isDocumentFragment: isDocumentFragment$1
};
function vnode(sel, data, children, text, elm) {
  const key = data === void 0 ? void 0 : data.key;
  return {
    sel,
    data,
    children,
    text,
    elm,
    key
  };
}
const array = Array.isArray;
function primitive(s) {
  return typeof s === "string" || typeof s === "number" || s instanceof String || s instanceof Number;
}
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
const emptyNode = vnode("", {}, [], void 0, void 0);
function sameVnode(vnode1, vnode2) {
  var _a, _b;
  const isSameKey = vnode1.key === vnode2.key;
  const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);
  const isSameSel = vnode1.sel === vnode2.sel;
  const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
  return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
}
function documentFragmentIsNotSupported() {
  throw new Error("The document fragment is not supported on this platform.");
}
function isElement(api, vnode2) {
  return api.isElement(vnode2);
}
function isDocumentFragment(api, vnode2) {
  return api.isDocumentFragment(vnode2);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var _a;
  const map = {};
  for (let i = beginIdx; i <= endIdx; ++i) {
    const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;
    if (key !== void 0) {
      map[key] = i;
    }
  }
  return map;
}
const hooks = ["create", "update", "remove", "destroy", "pre", "post"];
function init$1(modules2, domApi, options) {
  const cbs = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: []
  };
  const api = domApi !== void 0 ? domApi : htmlDomApi;
  for (const hook of hooks) {
    for (const module of modules2) {
      const currentHook = module[hook];
      if (currentHook !== void 0) {
        cbs[hook].push(currentHook);
      }
    }
  }
  function emptyNodeAt(elm) {
    const id2 = elm.id ? "#" + elm.id : "";
    const classes = elm.getAttribute("class");
    const c = classes ? "." + classes.split(" ").join(".") : "";
    return vnode(api.tagName(elm).toLowerCase() + id2 + c, {}, [], void 0, elm);
  }
  function emptyDocumentFragmentAt(frag) {
    return vnode(void 0, {}, [], void 0, frag);
  }
  function createRmCb(childElm, listeners) {
    return function rmCb() {
      if (--listeners === 0) {
        const parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }
  function createElm(vnode2, insertedVnodeQueue) {
    var _a, _b, _c, _d;
    let i;
    let data = vnode2.data;
    if (data !== void 0) {
      const init2 = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;
      if (isDef(init2)) {
        init2(vnode2);
        data = vnode2.data;
      }
    }
    const children = vnode2.children;
    const sel = vnode2.sel;
    if (sel === "!") {
      if (isUndef(vnode2.text)) {
        vnode2.text = "";
      }
      vnode2.elm = api.createComment(vnode2.text);
    } else if (sel !== void 0) {
      const hashIdx = sel.indexOf("#");
      const dotIdx = sel.indexOf(".", hashIdx);
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      const dot = dotIdx > 0 ? dotIdx : sel.length;
      const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      const elm = vnode2.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);
      if (hash < dot)
        elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0)
        elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      for (i = 0; i < cbs.create.length; ++i)
        cbs.create[i](emptyNode, vnode2);
      if (array(children)) {
        for (i = 0; i < children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch, insertedVnodeQueue));
          }
        }
      } else if (primitive(vnode2.text)) {
        api.appendChild(elm, api.createTextNode(vnode2.text));
      }
      const hook = vnode2.data.hook;
      if (isDef(hook)) {
        (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode2);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode2);
        }
      }
    } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode2.children) {
      vnode2.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
      for (i = 0; i < cbs.create.length; ++i)
        cbs.create[i](emptyNode, vnode2);
      for (i = 0; i < vnode2.children.length; ++i) {
        const ch = vnode2.children[i];
        if (ch != null) {
          api.appendChild(vnode2.elm, createElm(ch, insertedVnodeQueue));
        }
      }
    } else {
      vnode2.elm = api.createTextNode(vnode2.text);
    }
    return vnode2.elm;
  }
  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }
  function invokeDestroyHook(vnode2) {
    var _a, _b;
    const data = vnode2.data;
    if (data !== void 0) {
      (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode2);
      for (let i = 0; i < cbs.destroy.length; ++i)
        cbs.destroy[i](vnode2);
      if (vnode2.children !== void 0) {
        for (let j = 0; j < vnode2.children.length; ++j) {
          const child = vnode2.children[j];
          if (child != null && typeof child !== "string") {
            invokeDestroyHook(child);
          }
        }
      }
    }
  }
  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    var _a, _b;
    for (; startIdx <= endIdx; ++startIdx) {
      let listeners;
      let rm;
      const ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (let i = 0; i < cbs.remove.length; ++i)
            cbs.remove[i](ch, rm);
          const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;
          if (isDef(removeHook)) {
            removeHook(ch, rm);
          } else {
            rm();
          }
        } else if (ch.children) {
          invokeDestroyHook(ch);
          removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
        } else {
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let oldKeyToIdx;
    let idxInOld;
    let elmToMove;
    let before;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === void 0) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = void 0;
            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (newStartIdx <= newEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    }
    if (oldStartIdx <= oldEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
  function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const hook = (_a = vnode2.data) === null || _a === void 0 ? void 0 : _a.hook;
    (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode2);
    const elm = vnode2.elm = oldVnode.elm;
    if (oldVnode === vnode2)
      return;
    if (vnode2.data !== void 0 || isDef(vnode2.text) && vnode2.text !== oldVnode.text) {
      (_c = vnode2.data) !== null && _c !== void 0 ? _c : vnode2.data = {};
      (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
      for (let i = 0; i < cbs.update.length; ++i)
        cbs.update[i](oldVnode, vnode2);
      (_g = (_f = (_e = vnode2.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode2);
    }
    const oldCh = oldVnode.children;
    const ch = vnode2.children;
    if (isUndef(vnode2.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch)
          updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text))
          api.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode2.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      api.setTextContent(elm, vnode2.text);
    }
    (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode2);
  }
  return function patch(oldVnode, vnode2) {
    let i, elm, parent;
    const insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i)
      cbs.pre[i]();
    if (isElement(api, oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    } else if (isDocumentFragment(api, oldVnode)) {
      oldVnode = emptyDocumentFragmentAt(oldVnode);
    }
    if (sameVnode(oldVnode, vnode2)) {
      patchVnode(oldVnode, vnode2, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);
      createElm(vnode2, insertedVnodeQueue);
      if (parent !== null) {
        api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }
    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i)
      cbs.post[i]();
    return vnode2;
  };
}
function addNS(data, children, sel) {
  data.ns = "http://www.w3.org/2000/svg";
  if (sel !== "foreignObject" && children !== void 0) {
    for (let i = 0; i < children.length; ++i) {
      const child = children[i];
      if (typeof child === "string")
        continue;
      const childData = child.data;
      if (childData !== void 0) {
        addNS(childData, child.children, child.sel);
      }
    }
  }
}
function h(sel, b, c) {
  let data = {};
  let children;
  let text;
  let i;
  if (c !== void 0) {
    if (b !== null) {
      data = b;
    }
    if (array(c)) {
      children = c;
    } else if (primitive(c)) {
      text = c.toString();
    } else if (c && c.sel) {
      children = [c];
    }
  } else if (b !== void 0 && b !== null) {
    if (array(b)) {
      children = b;
    } else if (primitive(b)) {
      text = b.toString();
    } else if (b && b.sel) {
      children = [b];
    } else {
      data = b;
    }
  }
  if (children !== void 0) {
    for (i = 0; i < children.length; ++i) {
      if (primitive(children[i]))
        children[i] = vnode(void 0, void 0, void 0, children[i], void 0);
    }
  }
  if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
    addNS(data, children, sel);
  }
  return vnode(sel, data, children, text, void 0);
}
function fragment(children) {
  let c;
  let text;
  if (array(children)) {
    c = children;
  } else if (primitive(c)) {
    text = children;
  } else if (c && c.sel) {
    c = [children];
  }
  if (c !== void 0) {
    for (let i = 0; i < c.length; ++i) {
      if (primitive(c[i]))
        c[i] = vnode(void 0, void 0, void 0, c[i], void 0);
    }
  }
  return vnode(void 0, {}, c, text, void 0);
}
function copyToThunk(vnode2, thunk3) {
  var _a;
  const ns = (_a = thunk3.data) === null || _a === void 0 ? void 0 : _a.ns;
  vnode2.data.fn = thunk3.data.fn;
  vnode2.data.args = thunk3.data.args;
  thunk3.data = vnode2.data;
  thunk3.children = vnode2.children;
  thunk3.text = vnode2.text;
  thunk3.elm = vnode2.elm;
  if (ns)
    addNS(thunk3.data, thunk3.children, thunk3.sel);
}
function init(thunk3) {
  const cur = thunk3.data;
  const vnode2 = cur.fn(...cur.args);
  copyToThunk(vnode2, thunk3);
}
function prepatch(oldVnode, thunk3) {
  let i;
  const old = oldVnode.data;
  const cur = thunk3.data;
  const oldArgs = old.args;
  const args = cur.args;
  if (old.fn !== cur.fn || oldArgs.length !== args.length) {
    copyToThunk(cur.fn(...args), thunk3);
    return;
  }
  for (i = 0; i < args.length; ++i) {
    if (oldArgs[i] !== args[i]) {
      copyToThunk(cur.fn(...args), thunk3);
      return;
    }
  }
  copyToThunk(oldVnode, thunk3);
}
const thunk = function thunk2(sel, key, fn, args) {
  if (args === void 0) {
    args = fn;
    fn = key;
    key = void 0;
  }
  return h(sel, {
    key,
    hook: {
      init,
      prepatch
    },
    fn,
    args
  });
};
function pre(vnode2, newVnode) {
  const attachData = vnode2.data.attachData;
  newVnode.data.attachData.placeholder = attachData.placeholder;
  newVnode.data.attachData.real = attachData.real;
  vnode2.elm = vnode2.data.attachData.real;
}
function post(_, vnode2) {
  vnode2.elm = vnode2.data.attachData.placeholder;
}
function destroy(vnode2) {
  if (vnode2.elm !== void 0) {
    vnode2.elm.parentNode.removeChild(vnode2.elm);
  }
  vnode2.elm = vnode2.data.attachData.real;
}
function create$1(_, vnode2) {
  const real = vnode2.elm;
  const attachData = vnode2.data.attachData;
  const placeholder = document.createElement("span");
  vnode2.elm = placeholder;
  attachData.target.appendChild(real);
  attachData.real = real;
  attachData.placeholder = placeholder;
}
function attachTo(target, vnode2) {
  if (vnode2.data === void 0)
    vnode2.data = {};
  if (vnode2.data.hook === void 0)
    vnode2.data.hook = {};
  const data = vnode2.data;
  const hook = vnode2.data.hook;
  data.attachData = {
    target,
    placeholder: void 0,
    real: void 0
  };
  hook.create = create$1;
  hook.prepatch = pre;
  hook.postpatch = post;
  hook.destroy = destroy;
  return vnode2;
}
function toVNode$1(node, domApi) {
  const api = domApi !== void 0 ? domApi : htmlDomApi;
  let text;
  if (api.isElement(node)) {
    const id2 = node.id ? "#" + node.id : "";
    const cn = node.getAttribute("class");
    const c = cn ? "." + cn.split(" ").join(".") : "";
    const sel = api.tagName(node).toLowerCase() + id2 + c;
    const attrs = {};
    const dataset = {};
    const data = {};
    const children = [];
    let name;
    let i, n;
    const elmAttrs = node.attributes;
    const elmChildren = node.childNodes;
    for (i = 0, n = elmAttrs.length; i < n; i++) {
      name = elmAttrs[i].nodeName;
      if (name[0] === "d" && name[1] === "a" && name[2] === "t" && name[3] === "a" && name[4] === "-") {
        dataset[name.slice(5)] = elmAttrs[i].nodeValue || "";
      } else if (name !== "id" && name !== "class") {
        attrs[name] = elmAttrs[i].nodeValue;
      }
    }
    for (i = 0, n = elmChildren.length; i < n; i++) {
      children.push(toVNode$1(elmChildren[i], domApi));
    }
    if (Object.keys(attrs).length > 0)
      data.attrs = attrs;
    if (Object.keys(dataset).length > 0)
      data.dataset = dataset;
    if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
      addNS(data, children, sel);
    }
    return vnode(sel, data, children, void 0, node);
  } else if (api.isText(node)) {
    text = api.getTextContent(node);
    return vnode(void 0, void 0, void 0, text, node);
  } else if (api.isComment(node)) {
    text = api.getTextContent(node);
    return vnode("!", {}, [], text, node);
  } else {
    return vnode("", {}, [], void 0, node);
  }
}
const xlinkNS = "http://www.w3.org/1999/xlink";
const xmlNS = "http://www.w3.org/XML/1998/namespace";
const colonChar = 58;
const xChar = 120;
function updateAttrs(oldVnode, vnode2) {
  let key;
  const elm = vnode2.elm;
  let oldAttrs = oldVnode.data.attrs;
  let attrs = vnode2.data.attrs;
  if (!oldAttrs && !attrs)
    return;
  if (oldAttrs === attrs)
    return;
  oldAttrs = oldAttrs || {};
  attrs = attrs || {};
  for (key in attrs) {
    const cur = attrs[key];
    const old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(xmlNS, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(xlinkNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
const attributesModule = {
  create: updateAttrs,
  update: updateAttrs
};
function updateClass(oldVnode, vnode2) {
  let cur;
  let name;
  const elm = vnode2.elm;
  let oldClass = oldVnode.data.class;
  let klass = vnode2.data.class;
  if (!oldClass && !klass)
    return;
  if (oldClass === klass)
    return;
  oldClass = oldClass || {};
  klass = klass || {};
  for (name in oldClass) {
    if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? "add" : "remove"](name);
    }
  }
}
const classModule = {
  create: updateClass,
  update: updateClass
};
const CAPS_REGEX = /[A-Z]/g;
function updateDataset(oldVnode, vnode2) {
  const elm = vnode2.elm;
  let oldDataset = oldVnode.data.dataset;
  let dataset = vnode2.data.dataset;
  let key;
  if (!oldDataset && !dataset)
    return;
  if (oldDataset === dataset)
    return;
  oldDataset = oldDataset || {};
  dataset = dataset || {};
  const d = elm.dataset;
  for (key in oldDataset) {
    if (!dataset[key]) {
      if (d) {
        if (key in d) {
          delete d[key];
        }
      } else {
        elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
      }
    }
  }
  for (key in dataset) {
    if (oldDataset[key] !== dataset[key]) {
      if (d) {
        d[key] = dataset[key];
      } else {
        elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset[key]);
      }
    }
  }
}
const datasetModule = {
  create: updateDataset,
  update: updateDataset
};
function invokeHandler(handler, vnode2, event) {
  if (typeof handler === "function") {
    handler.call(vnode2, event, vnode2);
  } else if (typeof handler === "object") {
    for (let i = 0; i < handler.length; i++) {
      invokeHandler(handler[i], vnode2, event);
    }
  }
}
function handleEvent(event, vnode2) {
  const name = event.type;
  const on2 = vnode2.data.on;
  if (on2 && on2[name]) {
    invokeHandler(on2[name], vnode2, event);
  }
}
function createListener() {
  return function handler(event) {
    handleEvent(event, handler.vnode);
  };
}
function updateEventListeners(oldVnode, vnode2) {
  const oldOn = oldVnode.data.on;
  const oldListener = oldVnode.listener;
  const oldElm = oldVnode.elm;
  const on2 = vnode2 && vnode2.data.on;
  const elm = vnode2 && vnode2.elm;
  let name;
  if (oldOn === on2) {
    return;
  }
  if (oldOn && oldListener) {
    if (!on2) {
      for (name in oldOn) {
        oldElm.removeEventListener(name, oldListener, false);
      }
    } else {
      for (name in oldOn) {
        if (!on2[name]) {
          oldElm.removeEventListener(name, oldListener, false);
        }
      }
    }
  }
  if (on2) {
    const listener = vnode2.listener = oldVnode.listener || createListener();
    listener.vnode = vnode2;
    if (!oldOn) {
      for (name in on2) {
        elm.addEventListener(name, listener, false);
      }
    } else {
      for (name in on2) {
        if (!oldOn[name]) {
          elm.addEventListener(name, listener, false);
        }
      }
    }
  }
}
const eventListenersModule = {
  create: updateEventListeners,
  update: updateEventListeners,
  destroy: updateEventListeners
};
function updateProps(oldVnode, vnode2) {
  let key;
  let cur;
  let old;
  const elm = vnode2.elm;
  let oldProps = oldVnode.data.props;
  let props = vnode2.data.props;
  if (!oldProps && !props)
    return;
  if (oldProps === props)
    return;
  oldProps = oldProps || {};
  props = props || {};
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== "value" || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}
const propsModule = {
  create: updateProps,
  update: updateProps
};
const raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
const nextFrame = function(fn) {
  raf(function() {
    raf(fn);
  });
};
let reflowForced = false;
function setNextFrame(obj, prop, val) {
  nextFrame(function() {
    obj[prop] = val;
  });
}
function updateStyle(oldVnode, vnode2) {
  let cur;
  let name;
  const elm = vnode2.elm;
  let oldStyle = oldVnode.data.style;
  let style = vnode2.data.style;
  if (!oldStyle && !style)
    return;
  if (oldStyle === style)
    return;
  oldStyle = oldStyle || {};
  style = style || {};
  const oldHasDel = "delayed" in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.removeProperty(name);
      } else {
        elm.style[name] = "";
      }
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === "delayed" && style.delayed) {
      for (const name2 in style.delayed) {
        cur = style.delayed[name2];
        if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
          setNextFrame(elm.style, name2, cur);
        }
      }
    } else if (name !== "remove" && cur !== oldStyle[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.setProperty(name, cur);
      } else {
        elm.style[name] = cur;
      }
    }
  }
}
function applyDestroyStyle(vnode2) {
  let style;
  let name;
  const elm = vnode2.elm;
  const s = vnode2.data.style;
  if (!s || !(style = s.destroy))
    return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}
function applyRemoveStyle(vnode2, rm) {
  const s = vnode2.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  if (!reflowForced) {
    vnode2.elm.offsetLeft;
    reflowForced = true;
  }
  let name;
  const elm = vnode2.elm;
  let i = 0;
  const style = s.remove;
  let amount = 0;
  const applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  const compStyle = getComputedStyle(elm);
  const props = compStyle["transition-property"].split(", ");
  for (; i < props.length; ++i) {
    if (applied.indexOf(props[i]) !== -1)
      amount++;
  }
  elm.addEventListener("transitionend", function(ev) {
    if (ev.target === elm)
      --amount;
    if (amount === 0)
      rm();
  });
}
function forceReflow() {
  reflowForced = false;
}
const styleModule = {
  pre: forceReflow,
  create: updateStyle,
  update: updateStyle,
  destroy: applyDestroyStyle,
  remove: applyRemoveStyle
};
function Fragment(data, ...children) {
  const flatChildren = flattenAndFilter(children, []);
  if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
    return vnode(void 0, void 0, void 0, flatChildren[0].text, void 0);
  } else {
    return vnode(void 0, data !== null && data !== void 0 ? data : {}, flatChildren, void 0, void 0);
  }
}
function flattenAndFilter(children, flattened) {
  for (const child of children) {
    if (child !== void 0 && child !== null && child !== false && child !== "") {
      if (Array.isArray(child)) {
        flattenAndFilter(child, flattened);
      } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
        flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
      } else {
        flattened.push(child);
      }
    }
  }
  return flattened;
}
function jsx$1(tag, data, ...children) {
  const flatChildren = flattenAndFilter(children, []);
  if (typeof tag === "function") {
    return tag(data, flatChildren);
  } else {
    if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
      return h(tag, data, flatChildren[0].text);
    } else {
      return h(tag, data, flatChildren);
    }
  }
}
(function(jsx2) {
})(jsx$1 || (jsx$1 = {}));
const build = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Fragment,
  array,
  attachTo,
  attributesModule,
  classModule,
  datasetModule,
  eventListenersModule,
  fragment,
  h,
  htmlDomApi,
  init: init$1,
  get jsx() {
    return jsx$1;
  },
  primitive,
  propsModule,
  styleModule,
  thunk,
  toVNode: toVNode$1,
  vnode
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(build);
var __decorate$12 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(thunkView, "__esModule", {
  value: true
});
thunkView.isThunk = thunkView.ThunkView = void 0;
const snabbdom_1$4 = require$$0;
const inversify_1$1p = require$$0$1;
let ThunkView = class ThunkView2 {
  render(model2, context) {
    return (0, snabbdom_1$4.h)(this.selector(model2), {
      key: model2.id,
      hook: {
        init: this.init.bind(this),
        prepatch: this.prepatch.bind(this)
      },
      fn: () => this.renderAndDecorate(model2, context),
      args: this.watchedArgs(model2),
      thunk: true
    });
  }
  renderAndDecorate(model2, context) {
    const vnode2 = this.doRender(model2, context);
    context.decorate(vnode2, model2);
    return vnode2;
  }
  copyToThunk(vnode2, thunk3) {
    thunk3.elm = vnode2.elm;
    vnode2.data.fn = thunk3.data.fn;
    vnode2.data.args = thunk3.data.args;
    thunk3.data = vnode2.data;
    thunk3.children = vnode2.children;
    thunk3.text = vnode2.text;
    thunk3.elm = vnode2.elm;
  }
  init(thunk3) {
    const cur = thunk3.data;
    const vnode2 = cur.fn.apply(void 0, cur.args);
    this.copyToThunk(vnode2, thunk3);
  }
  prepatch(oldVnode, thunk3) {
    const old = oldVnode.data, cur = thunk3.data;
    if (!this.equals(old.args, cur.args))
      this.copyToThunk(cur.fn.apply(void 0, cur.args), thunk3);
    else
      this.copyToThunk(oldVnode, thunk3);
  }
  equals(oldArg, newArg) {
    if (Array.isArray(oldArg) && Array.isArray(newArg)) {
      if (oldArg.length !== newArg.length)
        return false;
      for (let i = 0; i < newArg.length; ++i) {
        if (!this.equals(oldArg[i], newArg[i]))
          return false;
      }
    } else if (typeof oldArg === "object" && typeof newArg === "object") {
      if (Object.keys(oldArg).length !== Object.keys(newArg).length)
        return false;
      for (const key in oldArg) {
        if (key !== "parent" && key !== "root" && (!(key in newArg) || !this.equals(oldArg[key], newArg[key])))
          return false;
      }
    } else if (oldArg !== newArg) {
      return false;
    }
    return true;
  }
};
thunkView.ThunkView = ThunkView;
thunkView.ThunkView = ThunkView = __decorate$12([(0, inversify_1$1p.injectable)()], ThunkView);
function isThunk(vnode2) {
  return "thunk" in vnode2;
}
thunkView.isThunk = isThunk;
var view = {};
var jsx = {};
Object.defineProperty(jsx, "__esModule", {
  value: true
});
jsx.JSX = jsx.svg = jsx.html = void 0;
const snabbdom_1$3 = require$$0;
const modulesNS = ["hook", "on", "style", "class", "props", "attrs", "dataset"];
const SVGNS = "http://www.w3.org/2000/svg";
function normalizeAttrs(source, defNS, namespace) {
  const data = {};
  if (namespace) {
    data.ns = namespace;
  }
  if (source === null) {
    return data;
  }
  modulesNS.forEach((mod) => {
    if (source[mod]) {
      data[mod] = source[mod];
    }
  });
  Object.keys(source).forEach((key) => {
    if (key === "key" || key === "classNames" || key === "selector")
      return;
    const idx = key.indexOf("-");
    if (idx > 0) {
      const modname = key.slice(0, idx);
      if (modulesNS.includes(modname)) {
        addAttr(modname, key.slice(idx + 1), source[key]);
      } else {
        addAttr(defNS, key, source[key]);
      }
    } else if (!data[key])
      addAttr(defNS, key, source[key]);
  });
  return data;
  function addAttr(modname, key, val) {
    const mod = data[modname] || (data[modname] = {});
    mod[key] = val;
  }
}
function JSX(namespace, defNS = "props") {
  return (tag, attrs, ...children) => {
    const isComponent = typeof tag === "function";
    return (0, snabbdom_1$3.jsx)(tag, isComponent ? attrs : normalizeAttrs(attrs, defNS, namespace), children);
  };
}
jsx.JSX = JSX;
const html = JSX();
jsx.html = html;
const svg = JSX(SVGNS, "attrs");
jsx.svg = svg;
var __decorate$11 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$G = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$m = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MissingView_1;
Object.defineProperty(view, "__esModule", {
  value: true
});
view.MissingView = view.EmptyView = view.configureView = view.overrideModelElement = view.configureModelElement = view.ViewRegistry = view.findArgValue = void 0;
const jsx_1$8 = jsx;
const inversify_1$1o = require$$0$1;
const types_1$V = types;
const registry_1$3 = registry;
const inversify_2$2 = inversify;
const smodel_factory_1$4 = smodelFactory;
const smodel_utils_1$d = smodelUtils;
const sprotty_protocol_1$5 = lib;
function findArgValue(arg, key) {
  while (arg !== void 0 && !(key in arg) && arg.parentArgs) {
    arg = arg.parentArgs;
  }
  return arg ? arg[key] : void 0;
}
view.findArgValue = findArgValue;
let ViewRegistry = class ViewRegistry2 extends registry_1$3.InstanceRegistry {
  constructor(registrations) {
    super();
    this.registerDefaults();
    registrations.forEach((registration) => {
      if (registration.isOverride) {
        this.override(registration.type, registration.factory());
      } else {
        this.register(registration.type, registration.factory());
      }
    });
  }
  registerDefaults() {
    this.register(smodel_factory_1$4.EMPTY_ROOT.type, new EmptyView());
  }
  missing(key) {
    this.logger.warn(this, `no registered view for type '${key}', please configure a view in the ContainerModule`);
    return new MissingView();
  }
};
view.ViewRegistry = ViewRegistry;
__decorate$11([(0, inversify_1$1o.inject)(types_1$V.TYPES.ILogger), __metadata$G("design:type", Object)], ViewRegistry.prototype, "logger", void 0);
view.ViewRegistry = ViewRegistry = __decorate$11([(0, inversify_1$1o.injectable)(), __param$m(0, (0, inversify_1$1o.multiInject)(types_1$V.TYPES.ViewRegistration)), __param$m(0, (0, inversify_1$1o.optional)()), __metadata$G("design:paramtypes", [Array])], ViewRegistry);
function configureModelElement(context, type, modelConstr, viewConstr, features) {
  (0, smodel_utils_1$d.registerModelElement)(context, type, modelConstr, features);
  configureView(context, type, viewConstr);
}
view.configureModelElement = configureModelElement;
function overrideModelElement(context, type, modelConstr, viewConstr, features) {
  (0, smodel_utils_1$d.registerModelElement)(context, type, modelConstr, features, true);
  configureView(context, type, viewConstr, true);
}
view.overrideModelElement = overrideModelElement;
function configureView(context, type, constr, isOverride) {
  if (typeof constr === "function") {
    if (!(0, inversify_2$2.isInjectable)(constr)) {
      throw new Error(`Views should be @injectable: ${constr.name}`);
    }
    if (!context.isBound(constr)) {
      context.bind(constr).toSelf();
    }
  }
  context.bind(types_1$V.TYPES.ViewRegistration).toDynamicValue((ctx) => ({
    type,
    factory: () => ctx.container.get(constr),
    isOverride
  }));
}
view.configureView = configureView;
let EmptyView = class EmptyView2 {
  render(model2, context) {
    return (0, jsx_1$8.svg)("svg", {
      "class-sprotty-empty": true
    });
  }
};
view.EmptyView = EmptyView;
view.EmptyView = EmptyView = __decorate$11([(0, inversify_1$1o.injectable)()], EmptyView);
let MissingView = MissingView_1 = class MissingView2 {
  render(model2, context) {
    const position = model2.position || this.getPostion(model2.type);
    return (0, jsx_1$8.svg)("text", {
      "class-sprotty-missing": true,
      x: position.x,
      y: position.y
    }, 'missing "', model2.type, '" view');
  }
  getPostion(type) {
    let position = MissingView_1.positionMap.get(type);
    if (!position) {
      position = sprotty_protocol_1$5.Point.ORIGIN;
      MissingView_1.positionMap.forEach((value) => position = value.y >= position.y ? {
        x: 0,
        y: value.y + 20
      } : position);
      MissingView_1.positionMap.set(type, position);
    }
    return position;
  }
};
view.MissingView = MissingView;
MissingView.positionMap = /* @__PURE__ */ new Map();
view.MissingView = MissingView = MissingView_1 = __decorate$11([(0, inversify_1$1o.injectable)()], MissingView);
var viewerCache = {};
var __decorate$10 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$F = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(viewerCache, "__esModule", {
  value: true
});
viewerCache.ViewerCache = void 0;
const inversify_1$1n = require$$0$1;
const types_1$U = types;
const animation_frame_syncer_1$1 = animationFrameSyncer;
let ViewerCache = class ViewerCache2 {
  update(model2, cause) {
    if (cause !== void 0) {
      this.delegate.update(model2, cause);
      this.cachedModel = void 0;
    } else {
      const isCacheEmpty = this.cachedModel === void 0;
      this.cachedModel = model2;
      if (isCacheEmpty) {
        this.scheduleUpdate();
      }
    }
  }
  scheduleUpdate() {
    this.syncer.onEndOfNextFrame(() => {
      if (this.cachedModel) {
        this.delegate.update(this.cachedModel);
        this.cachedModel = void 0;
      }
    });
  }
};
viewerCache.ViewerCache = ViewerCache;
__decorate$10([(0, inversify_1$1n.inject)(types_1$U.TYPES.IViewer), __metadata$F("design:type", Object)], ViewerCache.prototype, "delegate", void 0);
__decorate$10([(0, inversify_1$1n.inject)(types_1$U.TYPES.AnimationFrameSyncer), __metadata$F("design:type", animation_frame_syncer_1$1.AnimationFrameSyncer)], ViewerCache.prototype, "syncer", void 0);
viewerCache.ViewerCache = ViewerCache = __decorate$10([(0, inversify_1$1n.injectable)()], ViewerCache);
var viewerOptions = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.overrideViewerOptions = exports.configureViewerOptions = exports.defaultViewerOptions = void 0;
  const object_12 = object;
  const types_12 = types;
  const defaultViewerOptions = () => ({
    baseDiv: "sprotty",
    baseClass: "sprotty",
    hiddenDiv: "sprotty-hidden",
    hiddenClass: "sprotty-hidden",
    popupDiv: "sprotty-popup",
    popupClass: "sprotty-popup",
    popupClosedClass: "sprotty-popup-closed",
    needsClientLayout: true,
    needsServerLayout: false,
    popupOpenDelay: 1e3,
    popupCloseDelay: 300,
    zoomLimits: {
      min: 0.01,
      max: 10
    },
    horizontalScrollLimits: {
      min: -1e5,
      max: 1e5
    },
    verticalScrollLimits: {
      min: -1e5,
      max: 1e5
    }
  });
  exports.defaultViewerOptions = defaultViewerOptions;
  function configureViewerOptions(context, options) {
    const opt = Object.assign(Object.assign({}, (0, exports.defaultViewerOptions)()), options);
    if (context.isBound(types_12.TYPES.ViewerOptions)) {
      context.rebind(types_12.TYPES.ViewerOptions).toConstantValue(opt);
    } else {
      context.bind(types_12.TYPES.ViewerOptions).toConstantValue(opt);
    }
  }
  exports.configureViewerOptions = configureViewerOptions;
  function overrideViewerOptions(container, options) {
    const opt = container.get(types_12.TYPES.ViewerOptions);
    (0, object_12.safeAssign)(opt, options);
    return opt;
  }
  exports.overrideViewerOptions = overrideViewerOptions;
})(viewerOptions);
var viewer = {};
var __decorate$$ = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$E = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$l = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(viewer, "__esModule", {
  value: true
});
viewer.PopupModelViewer = viewer.HiddenModelViewer = viewer.ModelViewer = viewer.PatcherProvider = viewer.ModelRenderer = void 0;
const inversify_1$1m = require$$0$1;
const snabbdom_1$2 = require$$0;
const jsx_1$7 = jsx;
const browser_1$5 = browser;
const initialize_canvas_1$1 = initializeCanvas;
const smodel_factory_1$3 = smodelFactory;
const types_1$T = types;
const thunk_view_1 = thunkView;
const vnode_utils_1$d = vnodeUtils;
class ModelRenderer {
  constructor(viewRegistry, targetKind, postprocessors, args = {}) {
    this.viewRegistry = viewRegistry;
    this.targetKind = targetKind;
    this.postprocessors = postprocessors;
    this.args = args;
  }
  decorate(vnode2, element) {
    if ((0, thunk_view_1.isThunk)(vnode2)) {
      return vnode2;
    }
    return this.postprocessors.reduce((n, processor) => processor.decorate(n, element), vnode2);
  }
  renderElement(element) {
    const view2 = this.viewRegistry.get(element.type);
    const vnode2 = view2.render(element, this, this.args);
    if (vnode2) {
      return this.decorate(vnode2, element);
    } else {
      return void 0;
    }
  }
  renderChildren(element, args) {
    const context = args ? new ModelRenderer(this.viewRegistry, this.targetKind, this.postprocessors, Object.assign(Object.assign({}, args), {
      parentArgs: this.args
    })) : this;
    return element.children.map((child) => context.renderElement(child)).filter((vnode2) => vnode2 !== void 0);
  }
  postUpdate(cause) {
    this.postprocessors.forEach((processor) => processor.postUpdate(cause));
  }
}
viewer.ModelRenderer = ModelRenderer;
let PatcherProvider = class PatcherProvider2 {
  constructor() {
    this.patcher = (0, snabbdom_1$2.init)(this.createModules());
  }
  createModules() {
    return [snabbdom_1$2.propsModule, snabbdom_1$2.attributesModule, snabbdom_1$2.classModule, snabbdom_1$2.styleModule, snabbdom_1$2.eventListenersModule];
  }
};
viewer.PatcherProvider = PatcherProvider;
viewer.PatcherProvider = PatcherProvider = __decorate$$([(0, inversify_1$1m.injectable)(), __metadata$E("design:paramtypes", [])], PatcherProvider);
let ModelViewer = class ModelViewer2 {
  constructor(modelRendererFactory, patcherProvider, postprocessors) {
    this.renderer = modelRendererFactory("main", postprocessors);
    this.patcher = patcherProvider.patcher;
  }
  update(model2, cause) {
    var _a;
    this.logger.log(this, "rendering", model2);
    const newVDOM = (0, jsx_1$7.html)("div", {
      id: this.options.baseDiv
    }, this.renderer.renderElement(model2));
    if (this.lastVDOM !== void 0) {
      const hadFocus = this.hasFocus();
      (0, vnode_utils_1$d.copyClassesFromVNode)(this.lastVDOM, newVDOM);
      this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
      this.restoreFocus(hadFocus);
    } else if (typeof document !== "undefined") {
      let placeholder = null;
      if (this.options.shadowRoot) {
        const shadowRoot = (_a = document.getElementById(this.options.shadowRoot)) === null || _a === void 0 ? void 0 : _a.shadowRoot;
        if (shadowRoot) {
          placeholder = shadowRoot.getElementById(this.options.baseDiv);
        }
      } else {
        placeholder = document.getElementById(this.options.baseDiv);
      }
      if (placeholder !== null) {
        if (typeof window !== "undefined") {
          window.addEventListener("resize", () => {
            this.onWindowResize(newVDOM);
          });
        }
        (0, vnode_utils_1$d.copyClassesFromElement)(placeholder, newVDOM);
        (0, vnode_utils_1$d.setClass)(newVDOM, this.options.baseClass, true);
        this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
      } else {
        this.logger.error(this, "element not in DOM:", this.options.baseDiv);
      }
    }
    this.renderer.postUpdate(cause);
  }
  hasFocus() {
    if (typeof document !== "undefined" && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
      const lastRootVNode = this.lastVDOM.children[0];
      if (typeof lastRootVNode === "object") {
        const lastElement = lastRootVNode.elm;
        return document.activeElement === lastElement;
      }
    }
    return false;
  }
  restoreFocus(focus) {
    if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
      const lastRootVNode = this.lastVDOM.children[0];
      if (typeof lastRootVNode === "object") {
        const lastElement = lastRootVNode.elm;
        if (lastElement && typeof lastElement.focus === "function")
          lastElement.focus();
      }
    }
  }
  onWindowResize(vdom2) {
    const baseDiv = document.getElementById(this.options.baseDiv);
    if (baseDiv !== null) {
      const newBounds = this.getBoundsInPage(baseDiv);
      this.actiondispatcher.dispatch(initialize_canvas_1$1.InitializeCanvasBoundsAction.create(newBounds));
    }
  }
  getBoundsInPage(element) {
    const bounds = element.getBoundingClientRect();
    const scroll2 = (0, browser_1$5.getWindowScroll)();
    return {
      x: bounds.left + scroll2.x,
      y: bounds.top + scroll2.y,
      width: bounds.width,
      height: bounds.height
    };
  }
};
viewer.ModelViewer = ModelViewer;
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ViewerOptions), __metadata$E("design:type", Object)], ModelViewer.prototype, "options", void 0);
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ILogger), __metadata$E("design:type", Object)], ModelViewer.prototype, "logger", void 0);
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.IActionDispatcher), __metadata$E("design:type", Object)], ModelViewer.prototype, "actiondispatcher", void 0);
viewer.ModelViewer = ModelViewer = __decorate$$([(0, inversify_1$1m.injectable)(), __param$l(0, (0, inversify_1$1m.inject)(types_1$T.TYPES.ModelRendererFactory)), __param$l(1, (0, inversify_1$1m.inject)(types_1$T.TYPES.PatcherProvider)), __param$l(2, (0, inversify_1$1m.multiInject)(types_1$T.TYPES.IVNodePostprocessor)), __param$l(2, (0, inversify_1$1m.optional)()), __metadata$E("design:paramtypes", [Function, PatcherProvider, Array])], ModelViewer);
let HiddenModelViewer = class HiddenModelViewer2 {
  constructor(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
    this.hiddenRenderer = modelRendererFactory("hidden", hiddenPostprocessors);
    this.patcher = patcherProvider.patcher;
  }
  update(hiddenModel, cause) {
    this.logger.log(this, "rendering hidden");
    let newVDOM;
    if (hiddenModel.type === smodel_factory_1$3.EMPTY_ROOT.type) {
      newVDOM = (0, jsx_1$7.html)("div", {
        id: this.options.hiddenDiv
      });
    } else {
      const hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
      if (hiddenVNode) {
        (0, vnode_utils_1$d.setAttr)(hiddenVNode, "opacity", 0);
      }
      newVDOM = (0, jsx_1$7.html)("div", {
        id: this.options.hiddenDiv
      }, hiddenVNode);
    }
    if (this.lastHiddenVDOM !== void 0) {
      (0, vnode_utils_1$d.copyClassesFromVNode)(this.lastHiddenVDOM, newVDOM);
      this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
    } else {
      let placeholder = document.getElementById(this.options.hiddenDiv);
      if (placeholder === null) {
        placeholder = document.createElement("div");
        document.body.appendChild(placeholder);
      } else {
        (0, vnode_utils_1$d.copyClassesFromElement)(placeholder, newVDOM);
      }
      (0, vnode_utils_1$d.setClass)(newVDOM, this.options.baseClass, true);
      (0, vnode_utils_1$d.setClass)(newVDOM, this.options.hiddenClass, true);
      this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
    }
    this.hiddenRenderer.postUpdate(cause);
  }
};
viewer.HiddenModelViewer = HiddenModelViewer;
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ViewerOptions), __metadata$E("design:type", Object)], HiddenModelViewer.prototype, "options", void 0);
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ILogger), __metadata$E("design:type", Object)], HiddenModelViewer.prototype, "logger", void 0);
viewer.HiddenModelViewer = HiddenModelViewer = __decorate$$([(0, inversify_1$1m.injectable)(), __param$l(0, (0, inversify_1$1m.inject)(types_1$T.TYPES.ModelRendererFactory)), __param$l(1, (0, inversify_1$1m.inject)(types_1$T.TYPES.PatcherProvider)), __param$l(2, (0, inversify_1$1m.multiInject)(types_1$T.TYPES.HiddenVNodePostprocessor)), __param$l(2, (0, inversify_1$1m.optional)()), __metadata$E("design:paramtypes", [Function, PatcherProvider, Array])], HiddenModelViewer);
let PopupModelViewer = class PopupModelViewer2 {
  constructor(modelRendererFactory, patcherProvider, popupPostprocessors) {
    this.modelRendererFactory = modelRendererFactory;
    this.popupRenderer = this.modelRendererFactory("popup", popupPostprocessors);
    this.patcher = patcherProvider.patcher;
  }
  update(model2, cause) {
    this.logger.log(this, "rendering popup", model2);
    const popupClosed = model2.type === smodel_factory_1$3.EMPTY_ROOT.type;
    let newVDOM;
    if (popupClosed) {
      newVDOM = (0, jsx_1$7.html)("div", {
        id: this.options.popupDiv
      });
    } else {
      const position = model2.canvasBounds;
      const inlineStyle = {
        top: position.y + "px",
        left: position.x + "px"
      };
      newVDOM = (0, jsx_1$7.html)("div", {
        id: this.options.popupDiv,
        style: inlineStyle
      }, this.popupRenderer.renderElement(model2));
    }
    if (this.lastPopupVDOM !== void 0) {
      (0, vnode_utils_1$d.copyClassesFromVNode)(this.lastPopupVDOM, newVDOM);
      (0, vnode_utils_1$d.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
      this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
    } else if (typeof document !== "undefined") {
      let placeholder = document.getElementById(this.options.popupDiv);
      if (placeholder === null) {
        placeholder = document.createElement("div");
        document.body.appendChild(placeholder);
      } else {
        (0, vnode_utils_1$d.copyClassesFromElement)(placeholder, newVDOM);
      }
      (0, vnode_utils_1$d.setClass)(newVDOM, this.options.popupClass, true);
      (0, vnode_utils_1$d.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
      this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
    }
    this.popupRenderer.postUpdate(cause);
  }
};
viewer.PopupModelViewer = PopupModelViewer;
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ViewerOptions), __metadata$E("design:type", Object)], PopupModelViewer.prototype, "options", void 0);
__decorate$$([(0, inversify_1$1m.inject)(types_1$T.TYPES.ILogger), __metadata$E("design:type", Object)], PopupModelViewer.prototype, "logger", void 0);
viewer.PopupModelViewer = PopupModelViewer = __decorate$$([(0, inversify_1$1m.injectable)(), __param$l(0, (0, inversify_1$1m.inject)(types_1$T.TYPES.ModelRendererFactory)), __param$l(1, (0, inversify_1$1m.inject)(types_1$T.TYPES.PatcherProvider)), __param$l(2, (0, inversify_1$1m.multiInject)(types_1$T.TYPES.PopupVNodePostprocessor)), __param$l(2, (0, inversify_1$1m.optional)()), __metadata$E("design:paramtypes", [Function, PatcherProvider, Array])], PopupModelViewer);
var vnodePostprocessor = {};
var __decorate$_ = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(vnodePostprocessor, "__esModule", {
  value: true
});
vnodePostprocessor.FocusFixPostprocessor = void 0;
const inversify_1$1l = require$$0$1;
const vnode_utils_1$c = vnodeUtils;
let FocusFixPostprocessor = class FocusFixPostprocessor2 {
  decorate(vnode2, element) {
    if (vnode2.sel && vnode2.sel.startsWith("svg"))
      (0, vnode_utils_1$c.setAttr)(vnode2, "tabindex", 0);
    return vnode2;
  }
  postUpdate() {
  }
};
vnodePostprocessor.FocusFixPostprocessor = FocusFixPostprocessor;
vnodePostprocessor.FocusFixPostprocessor = FocusFixPostprocessor = __decorate$_([(0, inversify_1$1l.injectable)()], FocusFixPostprocessor);
var di_config$m = {};
var logging$1 = {};
var __decorate$Z = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$D = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(logging$1, "__esModule", {
  value: true
});
logging$1.ConsoleLogger = logging$1.NullLogger = logging$1.LogLevel = void 0;
const inversify_1$1k = require$$0$1;
const types_1$S = types;
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["none"] = 0] = "none";
  LogLevel2[LogLevel2["error"] = 1] = "error";
  LogLevel2[LogLevel2["warn"] = 2] = "warn";
  LogLevel2[LogLevel2["info"] = 3] = "info";
  LogLevel2[LogLevel2["log"] = 4] = "log";
})(LogLevel || (logging$1.LogLevel = LogLevel = {}));
let NullLogger = class NullLogger2 {
  constructor() {
    this.logLevel = LogLevel.none;
  }
  error(thisArg, message, ...params) {
  }
  warn(thisArg, message, ...params) {
  }
  info(thisArg, message, ...params) {
  }
  log(thisArg, message, ...params) {
  }
};
logging$1.NullLogger = NullLogger;
logging$1.NullLogger = NullLogger = __decorate$Z([(0, inversify_1$1k.injectable)()], NullLogger);
let ConsoleLogger = class ConsoleLogger2 {
  constructor() {
    this.logLevel = LogLevel.log;
    this.viewOptions = {
      baseDiv: ""
    };
  }
  error(thisArg, message, ...params) {
    if (this.logLevel >= LogLevel.error)
      try {
        console.error.apply(thisArg, this.consoleArguments(thisArg, message, params));
      } catch (error) {
      }
  }
  warn(thisArg, message, ...params) {
    if (this.logLevel >= LogLevel.warn)
      try {
        console.warn.apply(thisArg, this.consoleArguments(thisArg, message, params));
      } catch (error) {
      }
  }
  info(thisArg, message, ...params) {
    if (this.logLevel >= LogLevel.info)
      try {
        console.info.apply(thisArg, this.consoleArguments(thisArg, message, params));
      } catch (error) {
      }
  }
  log(thisArg, message, ...params) {
    if (this.logLevel >= LogLevel.log)
      try {
        console.log.apply(thisArg, this.consoleArguments(thisArg, message, params));
      } catch (error) {
      }
  }
  consoleArguments(thisArg, message, params) {
    let caller;
    if (typeof thisArg === "object")
      caller = thisArg.constructor.name;
    else
      caller = thisArg;
    const date = /* @__PURE__ */ new Date();
    return [date.toLocaleTimeString() + " " + this.viewOptions.baseDiv + " " + caller + ": " + message, ...params];
  }
};
logging$1.ConsoleLogger = ConsoleLogger;
__decorate$Z([(0, inversify_1$1k.inject)(types_1$S.TYPES.LogLevel), __metadata$D("design:type", Number)], ConsoleLogger.prototype, "logLevel", void 0);
__decorate$Z([(0, inversify_1$1k.inject)(types_1$S.TYPES.ViewerOptions), __metadata$D("design:type", Object)], ConsoleLogger.prototype, "viewOptions", void 0);
logging$1.ConsoleLogger = ConsoleLogger = __decorate$Z([(0, inversify_1$1k.injectable)()], ConsoleLogger);
var idPostprocessor = {};
var __decorate$Y = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$C = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(idPostprocessor, "__esModule", {
  value: true
});
idPostprocessor.IdPostprocessor = void 0;
const inversify_1$1j = require$$0$1;
const types_1$R = types;
const dom_helper_1$3 = domHelper;
const vnode_utils_1$b = vnodeUtils;
let IdPostprocessor = class IdPostprocessor2 {
  decorate(vnode2, element) {
    const attrs = (0, vnode_utils_1$b.getAttrs)(vnode2);
    if (attrs.id !== void 0)
      this.logger.warn(vnode2, "Overriding id of vnode (" + attrs.id + "). Make sure not to set it manually in view.");
    attrs.id = this.domHelper.createUniqueDOMElementId(element);
    if (!vnode2.key)
      vnode2.key = element.id;
    return vnode2;
  }
  postUpdate() {
  }
};
idPostprocessor.IdPostprocessor = IdPostprocessor;
__decorate$Y([(0, inversify_1$1j.inject)(types_1$R.TYPES.ILogger), __metadata$C("design:type", Object)], IdPostprocessor.prototype, "logger", void 0);
__decorate$Y([(0, inversify_1$1j.inject)(types_1$R.TYPES.DOMHelper), __metadata$C("design:type", dom_helper_1$3.DOMHelper)], IdPostprocessor.prototype, "domHelper", void 0);
idPostprocessor.IdPostprocessor = IdPostprocessor = __decorate$Y([(0, inversify_1$1j.injectable)()], IdPostprocessor);
var cssClassPostprocessor = {};
var __decorate$X = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(cssClassPostprocessor, "__esModule", {
  value: true
});
cssClassPostprocessor.CssClassPostprocessor = void 0;
const model_utils_1$3 = modelUtils;
const vnode_utils_1$a = vnodeUtils;
const inversify_1$1i = require$$0$1;
let CssClassPostprocessor = class CssClassPostprocessor2 {
  decorate(vnode2, element) {
    if (element.cssClasses) {
      for (const cssClass of element.cssClasses)
        (0, vnode_utils_1$a.setClass)(vnode2, cssClass, true);
    }
    const subType = (0, model_utils_1$3.getSubType)(element);
    if (subType && subType !== element.type) {
      (0, vnode_utils_1$a.setClass)(vnode2, subType, true);
    }
    return vnode2;
  }
  postUpdate() {
  }
};
cssClassPostprocessor.CssClassPostprocessor = CssClassPostprocessor;
cssClassPostprocessor.CssClassPostprocessor = CssClassPostprocessor = __decorate$X([(0, inversify_1$1i.injectable)()], CssClassPostprocessor);
Object.defineProperty(di_config$m, "__esModule", {
  value: true
});
const inversify_1$1h = require$$0$1;
const types_1$Q = types;
const initialize_canvas_1 = initializeCanvas;
const logging_1$1 = logging$1;
const action_dispatcher_1$1 = actionDispatcher;
const action_handler_1$2 = actionHandler$1;
const command_stack_1 = commandStack;
const command_stack_options_1 = commandStackOptions;
const smodel_factory_1$2 = smodelFactory;
const animation_frame_syncer_1 = animationFrameSyncer;
const viewer_1 = viewer;
const viewer_options_1 = viewerOptions;
const mouse_tool_1$a = mouseTool;
const key_tool_1$7 = keyTool;
const vnode_postprocessor_1 = vnodePostprocessor;
const view_1$3 = view;
const viewer_cache_1 = viewerCache;
const dom_helper_1$2 = domHelper;
const id_postprocessor_1 = idPostprocessor;
const command_registration_1$b = commandRegistration;
const css_class_postprocessor_1 = cssClassPostprocessor;
const set_model_1$1 = setModel;
const ui_extension_registry_1$2 = uiExtensionRegistry;
const diagram_locker_1 = diagramLocker;
const defaultContainerModule = new inversify_1$1h.ContainerModule((bind, _unbind, isBound) => {
  bind(types_1$Q.TYPES.ILogger).to(logging_1$1.NullLogger).inSingletonScope();
  bind(types_1$Q.TYPES.LogLevel).toConstantValue(logging_1$1.LogLevel.warn);
  bind(types_1$Q.TYPES.SModelRegistry).to(smodel_factory_1$2.SModelRegistry).inSingletonScope();
  bind(action_handler_1$2.ActionHandlerRegistry).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.ActionHandlerRegistryProvider).toProvider((ctx) => {
    return () => {
      return new Promise((resolve2) => {
        resolve2(ctx.container.get(action_handler_1$2.ActionHandlerRegistry));
      });
    };
  });
  bind(types_1$Q.TYPES.ViewRegistry).to(view_1$3.ViewRegistry).inSingletonScope();
  bind(types_1$Q.TYPES.IModelFactory).to(smodel_factory_1$2.SModelFactory).inSingletonScope();
  bind(types_1$Q.TYPES.IActionDispatcher).to(action_dispatcher_1$1.ActionDispatcher).inSingletonScope();
  bind(types_1$Q.TYPES.IActionDispatcherProvider).toProvider((ctx) => {
    return () => {
      return new Promise((resolve2) => {
        resolve2(ctx.container.get(types_1$Q.TYPES.IActionDispatcher));
      });
    };
  });
  bind(types_1$Q.TYPES.IDiagramLocker).to(diagram_locker_1.DefaultDiagramLocker).inSingletonScope();
  bind(types_1$Q.TYPES.IActionHandlerInitializer).to(command_registration_1$b.CommandActionHandlerInitializer);
  bind(types_1$Q.TYPES.ICommandStack).to(command_stack_1.CommandStack).inSingletonScope();
  bind(types_1$Q.TYPES.ICommandStackProvider).toProvider((ctx) => {
    return () => {
      return new Promise((resolve2) => {
        resolve2(ctx.container.get(types_1$Q.TYPES.ICommandStack));
      });
    };
  });
  bind(types_1$Q.TYPES.CommandStackOptions).toConstantValue((0, command_stack_options_1.defaultCommandStackOptions)());
  bind(viewer_1.ModelViewer).toSelf().inSingletonScope();
  bind(viewer_1.HiddenModelViewer).toSelf().inSingletonScope();
  bind(viewer_1.PopupModelViewer).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.ModelViewer).toDynamicValue((ctx) => {
    const container = ctx.container.createChild();
    container.bind(types_1$Q.TYPES.IViewer).toService(viewer_1.ModelViewer);
    container.bind(viewer_cache_1.ViewerCache).toSelf();
    return container.get(viewer_cache_1.ViewerCache);
  }).inSingletonScope();
  bind(types_1$Q.TYPES.PopupModelViewer).toDynamicValue((ctx) => {
    const container = ctx.container.createChild();
    container.bind(types_1$Q.TYPES.IViewer).toService(viewer_1.PopupModelViewer);
    container.bind(viewer_cache_1.ViewerCache).toSelf();
    return container.get(viewer_cache_1.ViewerCache);
  }).inSingletonScope();
  bind(types_1$Q.TYPES.HiddenModelViewer).toService(viewer_1.HiddenModelViewer);
  bind(types_1$Q.TYPES.IViewerProvider).toDynamicValue((ctx) => {
    return {
      get modelViewer() {
        return ctx.container.get(types_1$Q.TYPES.ModelViewer);
      },
      get hiddenModelViewer() {
        return ctx.container.get(types_1$Q.TYPES.HiddenModelViewer);
      },
      get popupModelViewer() {
        return ctx.container.get(types_1$Q.TYPES.PopupModelViewer);
      }
    };
  });
  bind(types_1$Q.TYPES.ViewerOptions).toConstantValue((0, viewer_options_1.defaultViewerOptions)());
  bind(types_1$Q.TYPES.PatcherProvider).to(viewer_1.PatcherProvider).inSingletonScope();
  bind(types_1$Q.TYPES.DOMHelper).to(dom_helper_1$2.DOMHelper).inSingletonScope();
  bind(types_1$Q.TYPES.ModelRendererFactory).toFactory((ctx) => {
    return (targetKind, processors, args = {}) => {
      const viewRegistry = ctx.container.get(types_1$Q.TYPES.ViewRegistry);
      return new viewer_1.ModelRenderer(viewRegistry, targetKind, processors, args);
    };
  });
  bind(id_postprocessor_1.IdPostprocessor).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
  bind(types_1$Q.TYPES.HiddenVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
  bind(css_class_postprocessor_1.CssClassPostprocessor).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
  bind(types_1$Q.TYPES.HiddenVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
  bind(mouse_tool_1$a.MouseTool).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(mouse_tool_1$a.MouseTool);
  bind(key_tool_1$7.KeyTool).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(key_tool_1$7.KeyTool);
  bind(vnode_postprocessor_1.FocusFixPostprocessor).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(vnode_postprocessor_1.FocusFixPostprocessor);
  bind(types_1$Q.TYPES.PopupVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
  bind(mouse_tool_1$a.PopupMouseTool).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.PopupVNodePostprocessor).toService(mouse_tool_1$a.PopupMouseTool);
  bind(types_1$Q.TYPES.AnimationFrameSyncer).to(animation_frame_syncer_1.AnimationFrameSyncer).inSingletonScope();
  const context = {
    bind,
    isBound
  };
  (0, command_registration_1$b.configureCommand)(context, initialize_canvas_1.InitializeCanvasBoundsCommand);
  bind(initialize_canvas_1.CanvasBoundsInitializer).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.IVNodePostprocessor).toService(initialize_canvas_1.CanvasBoundsInitializer);
  (0, command_registration_1$b.configureCommand)(context, set_model_1$1.SetModelCommand);
  bind(types_1$Q.TYPES.UIExtensionRegistry).to(ui_extension_registry_1$2.UIExtensionRegistry).inSingletonScope();
  (0, command_registration_1$b.configureCommand)(context, ui_extension_registry_1$2.SetUIExtensionVisibilityCommand);
  bind(mouse_tool_1$a.MousePositionTracker).toSelf().inSingletonScope();
  bind(types_1$Q.TYPES.MouseListener).toService(mouse_tool_1$a.MousePositionTracker);
});
di_config$m.default = defaultContainerModule;
var boundsManipulation = {};
var model$g = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SShapeElementImpl = exports.findChildrenAtPosition = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.isAlignable = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.alignFeature = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.boundsFeature = void 0;
  const geometry_12 = geometry$1;
  const smodel_12 = smodel;
  const smodel_utils_12 = smodelUtils;
  const browser_12 = browser;
  exports.boundsFeature = Symbol("boundsFeature");
  exports.layoutContainerFeature = Symbol("layoutContainerFeature");
  exports.layoutableChildFeature = Symbol("layoutableChildFeature");
  exports.alignFeature = Symbol("alignFeature");
  function isBoundsAware(element) {
    return "bounds" in element;
  }
  exports.isBoundsAware = isBoundsAware;
  function isLayoutContainer(element) {
    return isBoundsAware(element) && element.hasFeature(exports.layoutContainerFeature) && "layout" in element;
  }
  exports.isLayoutContainer = isLayoutContainer;
  function isLayoutableChild(element) {
    return isBoundsAware(element) && element.hasFeature(exports.layoutableChildFeature);
  }
  exports.isLayoutableChild = isLayoutableChild;
  function isSizeable(element) {
    return element.hasFeature(exports.boundsFeature) && isBoundsAware(element);
  }
  exports.isSizeable = isSizeable;
  function isAlignable(element) {
    return element.hasFeature(exports.alignFeature) && "alignment" in element;
  }
  exports.isAlignable = isAlignable;
  function getAbsoluteBounds(element) {
    const boundsAware = (0, smodel_utils_12.findParentByFeature)(element, isBoundsAware);
    if (boundsAware !== void 0) {
      let bounds = boundsAware.bounds;
      let current = boundsAware;
      while (current instanceof smodel_12.SChildElementImpl) {
        const parent = current.parent;
        bounds = parent.localToParent(bounds);
        current = parent;
      }
      return bounds;
    } else if (element instanceof smodel_12.SModelRootImpl) {
      const canvasBounds = element.canvasBounds;
      return {
        x: 0,
        y: 0,
        width: canvasBounds.width,
        height: canvasBounds.height
      };
    } else {
      return geometry_12.Bounds.EMPTY;
    }
  }
  exports.getAbsoluteBounds = getAbsoluteBounds;
  function getAbsoluteClientBounds(element, domHelper2, viewerOptions2) {
    let x = 0;
    let y = 0;
    let width = 0;
    let height = 0;
    const svgElementId = domHelper2.createUniqueDOMElementId(element);
    const svgElement = document.getElementById(svgElementId);
    if (svgElement) {
      const rect = svgElement.getBoundingClientRect();
      const scroll2 = (0, browser_12.getWindowScroll)();
      x = rect.left + scroll2.x;
      y = rect.top + scroll2.y;
      width = rect.width;
      height = rect.height;
    }
    let container = document.getElementById(viewerOptions2.baseDiv);
    if (container) {
      while (container.offsetParent instanceof HTMLElement && (container = container.offsetParent)) {
        x -= container.offsetLeft;
        y -= container.offsetTop;
      }
    }
    return {
      x,
      y,
      width,
      height
    };
  }
  exports.getAbsoluteClientBounds = getAbsoluteClientBounds;
  function findChildrenAtPosition(parent, point) {
    const matches = [];
    doFindChildrenAtPosition(parent, point, matches);
    return matches;
  }
  exports.findChildrenAtPosition = findChildrenAtPosition;
  function doFindChildrenAtPosition(parent, point, matches) {
    parent.children.forEach((child) => {
      if (isBoundsAware(child) && geometry_12.Bounds.includes(child.bounds, point))
        matches.push(child);
      if (child instanceof smodel_12.SParentElementImpl) {
        const newPoint = child.parentToLocal(point);
        doFindChildrenAtPosition(child, newPoint, matches);
      }
    });
  }
  class SShapeElementImpl extends smodel_12.SChildElementImpl {
    constructor() {
      super(...arguments);
      this.position = geometry_12.Point.ORIGIN;
      this.size = geometry_12.Dimension.EMPTY;
    }
    get bounds() {
      return {
        x: this.position.x,
        y: this.position.y,
        width: this.size.width,
        height: this.size.height
      };
    }
    set bounds(newBounds) {
      this.position = {
        x: newBounds.x,
        y: newBounds.y
      };
      this.size = {
        width: newBounds.width,
        height: newBounds.height
      };
    }
    localToParent(point) {
      const result = {
        x: point.x + this.position.x,
        y: point.y + this.position.y,
        width: -1,
        height: -1
      };
      if ((0, geometry_12.isBounds)(point)) {
        result.width = point.width;
        result.height = point.height;
      }
      return result;
    }
    parentToLocal(point) {
      const result = {
        x: point.x - this.position.x,
        y: point.y - this.position.y,
        width: -1,
        height: -1
      };
      if ((0, geometry_12.isBounds)(point)) {
        result.width = point.width;
        result.height = point.height;
      }
      return result;
    }
  }
  exports.SShapeElementImpl = SShapeElementImpl;
})(model$g);
var __decorate$W = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$B = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$k = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(boundsManipulation, "__esModule", {
  value: true
});
boundsManipulation.RequestBoundsCommand = boundsManipulation.SetBoundsCommand = void 0;
const inversify_1$1g = require$$0$1;
const actions_1$o = actions;
const command_1$f = command;
const types_1$P = types;
const model_1$M = model$g;
let SetBoundsCommand = class SetBoundsCommand2 extends command_1$f.SystemCommand {
  constructor(action2) {
    super();
    this.action = action2;
    this.bounds = [];
  }
  execute(context) {
    this.action.bounds.forEach((b) => {
      const element = context.root.index.getById(b.elementId);
      if (element && (0, model_1$M.isBoundsAware)(element)) {
        this.bounds.push({
          element,
          oldBounds: element.bounds,
          newPosition: b.newPosition,
          newSize: b.newSize
        });
      }
    });
    return this.redo(context);
  }
  undo(context) {
    this.bounds.forEach((b) => b.element.bounds = b.oldBounds);
    return context.root;
  }
  redo(context) {
    this.bounds.forEach((b) => {
      if (b.newPosition)
        b.element.bounds = Object.assign(Object.assign({}, b.newPosition), b.newSize);
      else
        b.element.bounds = Object.assign({
          x: b.element.bounds.x,
          y: b.element.bounds.y
        }, b.newSize);
    });
    return context.root;
  }
};
boundsManipulation.SetBoundsCommand = SetBoundsCommand;
SetBoundsCommand.KIND = actions_1$o.SetBoundsAction.KIND;
boundsManipulation.SetBoundsCommand = SetBoundsCommand = __decorate$W([(0, inversify_1$1g.injectable)(), __param$k(0, (0, inversify_1$1g.inject)(types_1$P.TYPES.Action)), __metadata$B("design:paramtypes", [Object])], SetBoundsCommand);
let RequestBoundsCommand = class RequestBoundsCommand2 extends command_1$f.HiddenCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    return {
      model: context.modelFactory.createRoot(this.action.newRoot),
      modelChanged: true,
      cause: this.action
    };
  }
  get blockUntil() {
    return (action2) => action2.kind === actions_1$o.ComputedBoundsAction.KIND;
  }
};
boundsManipulation.RequestBoundsCommand = RequestBoundsCommand;
RequestBoundsCommand.KIND = actions_1$o.RequestBoundsAction.KIND;
boundsManipulation.RequestBoundsCommand = RequestBoundsCommand = __decorate$W([(0, inversify_1$1g.injectable)(), __param$k(0, (0, inversify_1$1g.inject)(types_1$P.TYPES.Action)), __metadata$B("design:paramtypes", [Object])], RequestBoundsCommand);
var hiddenBoundsUpdater = {};
var layout = {};
var __decorate$V = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$A = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$j = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(layout, "__esModule", {
  value: true
});
layout.configureLayout = layout.StatefulLayouter = layout.Layouter = layout.LayoutRegistry = void 0;
const inversify_1$1f = require$$0$1;
const geometry_1$r = geometry$1;
const types_1$O = types;
const registry_1$2 = registry;
const model_1$L = model$g;
const inversify_2$1 = inversify;
let LayoutRegistry = class LayoutRegistry2 extends registry_1$2.InstanceRegistry {
  constructor(layouts = []) {
    super();
    layouts.forEach((layout2) => {
      if (this.hasKey(layout2.layoutKind)) {
        this.logger.warn("Layout kind is already defined: ", layout2.layoutKind);
      } else {
        this.register(layout2.layoutKind, layout2.factory());
      }
    });
  }
};
layout.LayoutRegistry = LayoutRegistry;
__decorate$V([(0, inversify_1$1f.inject)(types_1$O.TYPES.ILogger), __metadata$A("design:type", Object)], LayoutRegistry.prototype, "logger", void 0);
layout.LayoutRegistry = LayoutRegistry = __decorate$V([(0, inversify_1$1f.injectable)(), __param$j(0, (0, inversify_1$1f.multiInject)(types_1$O.TYPES.LayoutRegistration)), __param$j(0, (0, inversify_1$1f.optional)()), __metadata$A("design:paramtypes", [Array])], LayoutRegistry);
let Layouter = class Layouter2 {
  layout(element2boundsData) {
    new StatefulLayouter(element2boundsData, this.layoutRegistry, this.logger).layout();
  }
};
layout.Layouter = Layouter;
__decorate$V([(0, inversify_1$1f.inject)(types_1$O.TYPES.LayoutRegistry), __metadata$A("design:type", LayoutRegistry)], Layouter.prototype, "layoutRegistry", void 0);
__decorate$V([(0, inversify_1$1f.inject)(types_1$O.TYPES.ILogger), __metadata$A("design:type", Object)], Layouter.prototype, "logger", void 0);
layout.Layouter = Layouter = __decorate$V([(0, inversify_1$1f.injectable)()], Layouter);
class StatefulLayouter {
  constructor(element2boundsData, layoutRegistry, log) {
    this.element2boundsData = element2boundsData;
    this.layoutRegistry = layoutRegistry;
    this.log = log;
    this.toBeLayouted = [];
    element2boundsData.forEach((data, element) => {
      if ((0, model_1$L.isLayoutContainer)(element))
        this.toBeLayouted.push(element);
    });
  }
  getBoundsData(element) {
    let boundsData = this.element2boundsData.get(element);
    let bounds = element.bounds;
    if ((0, model_1$L.isLayoutContainer)(element) && this.toBeLayouted.indexOf(element) >= 0) {
      bounds = this.doLayout(element);
    }
    if (!boundsData) {
      boundsData = {
        bounds,
        boundsChanged: false,
        alignmentChanged: false
      };
      this.element2boundsData.set(element, boundsData);
    }
    return boundsData;
  }
  layout() {
    while (this.toBeLayouted.length > 0) {
      const element = this.toBeLayouted[0];
      this.doLayout(element);
    }
  }
  doLayout(element) {
    const index = this.toBeLayouted.indexOf(element);
    if (index >= 0)
      this.toBeLayouted.splice(index, 1);
    const layout2 = this.layoutRegistry.get(element.layout);
    if (layout2)
      layout2.layout(element, this);
    const boundsData = this.element2boundsData.get(element);
    if (boundsData !== void 0 && boundsData.bounds !== void 0) {
      return boundsData.bounds;
    } else {
      this.log.error(element, "Layout failed");
      return geometry_1$r.Bounds.EMPTY;
    }
  }
}
layout.StatefulLayouter = StatefulLayouter;
function configureLayout(context, kind, constr) {
  if (typeof constr === "function") {
    if (!(0, inversify_2$1.isInjectable)(constr)) {
      throw new Error(`Layouts be @injectable: ${constr.name}`);
    }
    if (!context.isBound(constr)) {
      context.bind(constr).toSelf();
    }
  }
  context.bind(types_1$O.TYPES.LayoutRegistration).toDynamicValue((ctx) => ({
    layoutKind: kind,
    factory: () => ctx.container.get(constr)
  }));
}
layout.configureLayout = configureLayout;
(function(exports) {
  var __decorate2 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata2 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ATTR_BBOX_ELEMENT = exports.HiddenBoundsUpdater = exports.BoundsData = void 0;
  const inversify_12 = require$$0$1;
  const actions_12 = actions;
  const geometry_12 = geometry$1;
  const browser_12 = browser;
  const smodel_12 = smodel;
  const types_12 = types;
  const layout_12 = layout;
  const model_12 = model$g;
  class BoundsData {
  }
  exports.BoundsData = BoundsData;
  let HiddenBoundsUpdater = class HiddenBoundsUpdater {
    constructor() {
      this.element2boundsData = /* @__PURE__ */ new Map();
    }
    decorate(vnode2, element) {
      if ((0, model_12.isSizeable)(element) || (0, model_12.isLayoutContainer)(element)) {
        this.element2boundsData.set(element, {
          vnode: vnode2,
          bounds: element.bounds,
          boundsChanged: false,
          alignmentChanged: false
        });
      }
      if (element instanceof smodel_12.SModelRootImpl) {
        this.root = element;
      }
      return vnode2;
    }
    postUpdate(cause) {
      if (cause === void 0 || cause.kind !== actions_12.RequestBoundsAction.KIND) {
        return;
      }
      const request = cause;
      this.getBoundsFromDOM();
      this.layouter.layout(this.element2boundsData);
      const resizes = [];
      const alignments = [];
      this.element2boundsData.forEach((boundsData, element) => {
        if (boundsData.boundsChanged && boundsData.bounds !== void 0) {
          const resize2 = {
            elementId: element.id,
            newSize: {
              width: boundsData.bounds.width,
              height: boundsData.bounds.height
            }
          };
          if (element instanceof smodel_12.SChildElementImpl && (0, model_12.isLayoutContainer)(element.parent)) {
            resize2.newPosition = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y
            };
          }
          resizes.push(resize2);
        }
        if (boundsData.alignmentChanged && boundsData.alignment !== void 0) {
          alignments.push({
            elementId: element.id,
            newAlignment: boundsData.alignment
          });
        }
      });
      const revision = this.root !== void 0 ? this.root.revision : void 0;
      this.actionDispatcher.dispatch(actions_12.ComputedBoundsAction.create(resizes, {
        revision,
        alignments,
        requestId: request.requestId
      }));
      this.element2boundsData.clear();
    }
    getBoundsFromDOM() {
      this.element2boundsData.forEach((boundsData, element) => {
        if (boundsData.bounds && (0, model_12.isSizeable)(element)) {
          const vnode2 = boundsData.vnode;
          if (vnode2 && vnode2.elm) {
            const boundingBox = this.getBounds(vnode2.elm, element);
            if ((0, model_12.isAlignable)(element) && !((0, geometry_12.almostEquals)(boundingBox.x, 0) && (0, geometry_12.almostEquals)(boundingBox.y, 0))) {
              boundsData.alignment = {
                x: -boundingBox.x,
                y: -boundingBox.y
              };
              boundsData.alignmentChanged = true;
            }
            const newBounds = {
              x: element.bounds.x,
              y: element.bounds.y,
              width: boundingBox.width,
              height: boundingBox.height
            };
            if (!((0, geometry_12.almostEquals)(newBounds.x, element.bounds.x) && (0, geometry_12.almostEquals)(newBounds.y, element.bounds.y) && (0, geometry_12.almostEquals)(newBounds.width, element.bounds.width) && (0, geometry_12.almostEquals)(newBounds.height, element.bounds.height))) {
              boundsData.bounds = newBounds;
              boundsData.boundsChanged = true;
            }
          }
        }
      });
    }
    /**
     * Compute the bounds of the given DOM element. Override this method to customize how
     * the bounding box of a rendered view is determined.
     *
     * In case your Sprotty model element contains children that are rendered outside of
     * their parent, you can add the `ATTR_BBOX_ELEMENT` attribute to the SVG element
     * that shall be used to compute the bounding box.
     */
    getBounds(elm, element) {
      if (!(0, browser_12.isSVGGraphicsElement)(elm)) {
        this.logger.error(this, "Not an SVG element:", elm);
        return geometry_12.Bounds.EMPTY;
      }
      if (elm.tagName === "g") {
        for (const child of Array.from(elm.children)) {
          if (child.getAttribute(exports.ATTR_BBOX_ELEMENT) !== null) {
            return this.getBounds(child, element);
          }
        }
      }
      const bounds = elm.getBBox();
      return {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height
      };
    }
  };
  exports.HiddenBoundsUpdater = HiddenBoundsUpdater;
  __decorate2([(0, inversify_12.inject)(types_12.TYPES.ILogger), __metadata2("design:type", Object)], HiddenBoundsUpdater.prototype, "logger", void 0);
  __decorate2([(0, inversify_12.inject)(types_12.TYPES.IActionDispatcher), __metadata2("design:type", Object)], HiddenBoundsUpdater.prototype, "actionDispatcher", void 0);
  __decorate2([(0, inversify_12.inject)(types_12.TYPES.Layouter), __metadata2("design:type", layout_12.Layouter)], HiddenBoundsUpdater.prototype, "layouter", void 0);
  exports.HiddenBoundsUpdater = HiddenBoundsUpdater = __decorate2([(0, inversify_12.injectable)()], HiddenBoundsUpdater);
  exports.ATTR_BBOX_ELEMENT = "bboxElement";
})(hiddenBoundsUpdater);
var vboxLayout = {};
var abstractLayout = {};
var __decorate$U = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(abstractLayout, "__esModule", {
  value: true
});
abstractLayout.AbstractLayout = void 0;
const geometry_1$q = geometry$1;
const smodel_1$i = smodel;
const model_1$K = model$g;
const inversify_1$1e = require$$0$1;
let AbstractLayout = class AbstractLayout2 {
  layout(container, layouter) {
    const boundsData = layouter.getBoundsData(container);
    const options = this.getLayoutOptions(container);
    const childrenSize = this.getChildrenSize(container, options, layouter);
    const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.width, options.minWidth) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).width) - options.paddingLeft - options.paddingRight);
    const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.height, options.minHeight) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).height) - options.paddingTop - options.paddingBottom);
    if (maxWidth > 0 && maxHeight > 0) {
      const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
      boundsData.bounds = this.getFinalContainerBounds(container, offset, options, maxWidth, maxHeight);
      boundsData.boundsChanged = true;
    }
  }
  getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
    return {
      x: container.bounds.x,
      y: container.bounds.y,
      width: Math.max(options.minWidth, maxWidth + options.paddingLeft + options.paddingRight),
      height: Math.max(options.minHeight, maxHeight + options.paddingTop + options.paddingBottom)
    };
  }
  getFixedContainerBounds(container, layoutOptions, layouter) {
    let currentContainer = container;
    while (true) {
      if ((0, model_1$K.isBoundsAware)(currentContainer)) {
        const bounds = currentContainer.bounds;
        if ((0, model_1$K.isLayoutContainer)(currentContainer) && layoutOptions.resizeContainer)
          layouter.log.error(currentContainer, "Resizable container found while detecting fixed bounds");
        if (geometry_1$q.Dimension.isValid(bounds))
          return bounds;
      }
      if (currentContainer instanceof smodel_1$i.SChildElementImpl) {
        currentContainer = currentContainer.parent;
      } else {
        layouter.log.error(currentContainer, "Cannot detect fixed bounds");
        return geometry_1$q.Bounds.EMPTY;
      }
    }
  }
  layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight) {
    let currentOffset = {
      x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
      y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
    };
    container.children.forEach((child) => {
      if ((0, model_1$K.isLayoutableChild)(child)) {
        const boundsData = layouter.getBoundsData(child);
        const bounds = boundsData.bounds;
        const childOptions = this.getChildLayoutOptions(child, containerOptions);
        if (bounds !== void 0 && geometry_1$q.Dimension.isValid(bounds)) {
          currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
        }
      }
    });
    return currentOffset;
  }
  getDx(hAlign, bounds, maxWidth) {
    switch (hAlign) {
      case "left":
        return 0;
      case "center":
        return 0.5 * (maxWidth - bounds.width);
      case "right":
        return maxWidth - bounds.width;
    }
  }
  getDy(vAlign, bounds, maxHeight) {
    switch (vAlign) {
      case "top":
        return 0;
      case "center":
        return 0.5 * (maxHeight - bounds.height);
      case "bottom":
        return maxHeight - bounds.height;
    }
  }
  getChildLayoutOptions(child, containerOptions) {
    const layoutOptions = child.layoutOptions;
    if (layoutOptions === void 0)
      return containerOptions;
    else
      return this.spread(containerOptions, layoutOptions);
  }
  getLayoutOptions(element) {
    let current = element;
    const allOptions = [];
    while (current !== void 0) {
      const layoutOptions = current.layoutOptions;
      if (layoutOptions !== void 0)
        allOptions.push(layoutOptions);
      if (current instanceof smodel_1$i.SChildElementImpl)
        current = current.parent;
      else
        break;
    }
    return allOptions.reverse().reduce((a, b) => {
      return this.spread(a, b);
    }, this.getDefaultLayoutOptions());
  }
};
abstractLayout.AbstractLayout = AbstractLayout;
abstractLayout.AbstractLayout = AbstractLayout = __decorate$U([(0, inversify_1$1e.injectable)()], AbstractLayout);
var __decorate$T = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(vboxLayout, "__esModule", {
  value: true
});
vboxLayout.VBoxLayouter = void 0;
const inversify_1$1d = require$$0$1;
const geometry_1$p = geometry$1;
const abstract_layout_1$2 = abstractLayout;
const model_1$J = model$g;
let VBoxLayouter = class VBoxLayouter2 extends abstract_layout_1$2.AbstractLayout {
  getChildrenSize(container, containerOptions, layouter) {
    let maxWidth = -1;
    let maxHeight = 0;
    let isFirst = true;
    container.children.forEach((child) => {
      if ((0, model_1$J.isLayoutableChild)(child)) {
        const bounds = layouter.getBoundsData(child).bounds;
        if (bounds !== void 0 && geometry_1$p.Dimension.isValid(bounds)) {
          maxHeight += bounds.height;
          if (isFirst)
            isFirst = false;
          else
            maxHeight += containerOptions.vGap;
          maxWidth = Math.max(maxWidth, bounds.width);
        }
      }
    });
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
    const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
    boundsData.bounds = {
      x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
      y: currentOffset.y + child.bounds.y - bounds.y,
      width: bounds.width,
      height: bounds.height
    };
    boundsData.boundsChanged = true;
    return {
      x: currentOffset.x,
      y: currentOffset.y + bounds.height + containerOptions.vGap
    };
  }
  getDefaultLayoutOptions() {
    return {
      resizeContainer: true,
      paddingTop: 5,
      paddingBottom: 5,
      paddingLeft: 5,
      paddingRight: 5,
      paddingFactor: 1,
      vGap: 1,
      hAlign: "center",
      minWidth: 0,
      minHeight: 0
    };
  }
  spread(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
};
vboxLayout.VBoxLayouter = VBoxLayouter;
VBoxLayouter.KIND = "vbox";
vboxLayout.VBoxLayouter = VBoxLayouter = __decorate$T([(0, inversify_1$1d.injectable)()], VBoxLayouter);
var hboxLayout = {};
var __decorate$S = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(hboxLayout, "__esModule", {
  value: true
});
hboxLayout.HBoxLayouter = void 0;
const inversify_1$1c = require$$0$1;
const geometry_1$o = geometry$1;
const abstract_layout_1$1 = abstractLayout;
const model_1$I = model$g;
let HBoxLayouter = class HBoxLayouter2 extends abstract_layout_1$1.AbstractLayout {
  getChildrenSize(container, containerOptions, layouter) {
    let maxWidth = 0;
    let maxHeight = -1;
    let isFirst = true;
    container.children.forEach((child) => {
      if ((0, model_1$I.isLayoutableChild)(child)) {
        const bounds = layouter.getBoundsData(child).bounds;
        if (bounds !== void 0 && geometry_1$o.Dimension.isValid(bounds)) {
          if (isFirst)
            isFirst = false;
          else
            maxWidth += containerOptions.hGap;
          maxWidth += bounds.width;
          maxHeight = Math.max(maxHeight, bounds.height);
        }
      }
    });
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
    const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
    boundsData.bounds = {
      x: currentOffset.x + child.bounds.x - bounds.x,
      y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
      width: bounds.width,
      height: bounds.height
    };
    boundsData.boundsChanged = true;
    return {
      x: currentOffset.x + bounds.width + containerOptions.hGap,
      y: currentOffset.y
    };
  }
  getDefaultLayoutOptions() {
    return {
      resizeContainer: true,
      paddingTop: 5,
      paddingBottom: 5,
      paddingLeft: 5,
      paddingRight: 5,
      paddingFactor: 1,
      hGap: 1,
      vAlign: "center",
      minWidth: 0,
      minHeight: 0
    };
  }
  spread(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
};
hboxLayout.HBoxLayouter = HBoxLayouter;
HBoxLayouter.KIND = "hbox";
hboxLayout.HBoxLayouter = HBoxLayouter = __decorate$S([(0, inversify_1$1c.injectable)()], HBoxLayouter);
var stackLayout = {};
var __decorate$R = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(stackLayout, "__esModule", {
  value: true
});
stackLayout.StackLayouter = void 0;
const inversify_1$1b = require$$0$1;
const geometry_1$n = geometry$1;
const abstract_layout_1 = abstractLayout;
const model_1$H = model$g;
let StackLayouter = class StackLayouter2 extends abstract_layout_1.AbstractLayout {
  getChildrenSize(container, options, layouter) {
    let maxWidth = -1;
    let maxHeight = -1;
    container.children.forEach((child) => {
      if ((0, model_1$H.isLayoutableChild)(child)) {
        const bounds = layouter.getBoundsData(child).bounds;
        if (bounds !== void 0 && geometry_1$n.Dimension.isValid(bounds)) {
          maxWidth = Math.max(maxWidth, bounds.width);
          maxHeight = Math.max(maxHeight, bounds.height);
        }
      }
    });
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
    const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
    const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
    boundsData.bounds = {
      x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
      y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
      width: bounds.width,
      height: bounds.height
    };
    boundsData.boundsChanged = true;
    return currentOffset;
  }
  getDefaultLayoutOptions() {
    return {
      resizeContainer: true,
      paddingTop: 5,
      paddingBottom: 5,
      paddingLeft: 5,
      paddingRight: 5,
      paddingFactor: 1,
      hAlign: "center",
      vAlign: "center",
      minWidth: 0,
      minHeight: 0
    };
  }
  spread(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
};
stackLayout.StackLayouter = StackLayouter;
StackLayouter.KIND = "stack";
stackLayout.StackLayouter = StackLayouter = __decorate$R([(0, inversify_1$1b.injectable)()], StackLayouter);
var views$5 = {};
var __decorate$Q = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(views$5, "__esModule", {
  value: true
});
views$5.ShapeView = void 0;
const inversify_1$1a = require$$0$1;
const geometry_1$m = geometry$1;
const model_1$G = model$g;
let ShapeView = class ShapeView2 {
  /**
   * Check whether the given model element is in the current viewport. Use this method
   * in your `render` implementation to skip rendering in case the element is not visible.
   * This can greatly enhance performance for large models.
   */
  isVisible(model2, context) {
    if (context.targetKind === "hidden") {
      return true;
    }
    if (!geometry_1$m.Dimension.isValid(model2.bounds)) {
      return true;
    }
    const ab = (0, model_1$G.getAbsoluteBounds)(model2);
    const canvasBounds = model2.root.canvasBounds;
    return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
  }
};
views$5.ShapeView = ShapeView;
views$5.ShapeView = ShapeView = __decorate$Q([(0, inversify_1$1a.injectable)()], ShapeView);
var buttonHandler = {};
var __decorate$P = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$z = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$i = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(buttonHandler, "__esModule", {
  value: true
});
buttonHandler.configureButtonHandler = buttonHandler.ButtonHandlerRegistry = void 0;
const inversify_1$19 = require$$0$1;
const registry_1$1 = registry;
const types_1$N = types;
const inversify_2 = inversify;
let ButtonHandlerRegistry = class ButtonHandlerRegistry2 extends registry_1$1.InstanceRegistry {
  constructor(buttonHandlerRegistrations) {
    super();
    buttonHandlerRegistrations.forEach((factory) => this.register(factory.TYPE, factory.factory()));
  }
};
buttonHandler.ButtonHandlerRegistry = ButtonHandlerRegistry;
buttonHandler.ButtonHandlerRegistry = ButtonHandlerRegistry = __decorate$P([(0, inversify_1$19.injectable)(), __param$i(0, (0, inversify_1$19.multiInject)(types_1$N.TYPES.IButtonHandlerRegistration)), __param$i(0, (0, inversify_1$19.optional)()), __metadata$z("design:paramtypes", [Array])], ButtonHandlerRegistry);
function configureButtonHandler(context, type, constr) {
  if (typeof constr === "function") {
    if (!(0, inversify_2.isInjectable)(constr)) {
      throw new Error(`Button handlers should be @injectable: ${constr.name}`);
    }
    if (!context.isBound(constr)) {
      context.bind(constr).toSelf();
    }
  }
  context.bind(types_1$N.TYPES.IButtonHandlerRegistration).toDynamicValue((ctx) => ({
    TYPE: type,
    factory: () => ctx.container.get(constr)
  }));
}
buttonHandler.configureButtonHandler = configureButtonHandler;
var model$f = {};
var model$e = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isFadeable = exports.fadeFeature = void 0;
  exports.fadeFeature = Symbol("fadeFeature");
  function isFadeable(element) {
    return element.hasFeature(exports.fadeFeature) && element["opacity"] !== void 0;
  }
  exports.isFadeable = isFadeable;
})(model$e);
Object.defineProperty(model$f, "__esModule", {
  value: true
});
model$f.SButtonImpl = void 0;
const model_1$F = model$g;
const model_2$i = model$e;
class SButtonImpl extends model_1$F.SShapeElementImpl {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
}
model$f.SButtonImpl = SButtonImpl;
SButtonImpl.DEFAULT_FEATURES = [model_1$F.boundsFeature, model_1$F.layoutableChildFeature, model_2$i.fadeFeature];
var actionProviders = {};
var model$d = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.name = exports.isNameable = exports.nameFeature = void 0;
  exports.nameFeature = Symbol("nameableFeature");
  function isNameable(element) {
    return element.hasFeature(exports.nameFeature);
  }
  exports.isNameable = isNameable;
  function name(element) {
    if (isNameable(element)) {
      return element.name;
    } else {
      return void 0;
    }
  }
  exports.name = name;
})(model$d);
var __decorate$O = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$y = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$h = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(actionProviders, "__esModule", {
  value: true
});
actionProviders.RevealNamedElementActionProvider = actionProviders.CommandPaletteActionProviderRegistry = void 0;
const inversify_1$18 = require$$0$1;
const actions_1$n = actions;
const action_1$1 = action;
const types_1$M = types;
const iterable_1$4 = iterable;
const model_1$E = model$d;
let CommandPaletteActionProviderRegistry = class CommandPaletteActionProviderRegistry2 {
  constructor(actionProviders2 = []) {
    this.actionProviders = actionProviders2;
  }
  getActions(root, text, lastMousePosition, index) {
    const actionLists = this.actionProviders.map((provider) => provider.getActions(root, text, lastMousePosition, index));
    return Promise.all(actionLists).then((p2) => p2.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc));
  }
};
actionProviders.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry;
actionProviders.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry = __decorate$O([(0, inversify_1$18.injectable)(), __param$h(0, (0, inversify_1$18.multiInject)(types_1$M.TYPES.ICommandPaletteActionProvider)), __param$h(0, (0, inversify_1$18.optional)()), __metadata$y("design:paramtypes", [Array])], CommandPaletteActionProviderRegistry);
let RevealNamedElementActionProvider = class RevealNamedElementActionProvider2 {
  constructor(logger) {
    this.logger = logger;
  }
  getActions(root, text, lastMousePosition, index) {
    if (index !== void 0 && index % 2 === 0)
      return Promise.resolve(this.createSelectActions(root));
    else
      return Promise.resolve([new action_1$1.LabeledAction("Select all", [actions_1$n.SelectAllAction.create()])]);
  }
  createSelectActions(modelRoot) {
    const nameables = (0, iterable_1$4.toArray)(modelRoot.index.all().filter((element) => (0, model_1$E.isNameable)(element)));
    return nameables.map((nameable) => new action_1$1.LabeledAction(`Reveal ${(0, model_1$E.name)(nameable)}`, [actions_1$n.SelectAction.create({
      selectedElementsIDs: [nameable.id]
    }), actions_1$n.CenterAction.create([nameable.id])], "eye"));
  }
};
actionProviders.RevealNamedElementActionProvider = RevealNamedElementActionProvider;
actionProviders.RevealNamedElementActionProvider = RevealNamedElementActionProvider = __decorate$O([(0, inversify_1$18.injectable)(), __param$h(0, (0, inversify_1$18.inject)(types_1$M.TYPES.ILogger)), __metadata$y("design:paramtypes", [Object])], RevealNamedElementActionProvider);
var commandPalette = {};
var codicon = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.codiconCSSClasses = exports.codiconCSSString = exports.ANIMATION_SPIN = exports.ACTION_ITEM = void 0;
  exports.ACTION_ITEM = "action-item";
  exports.ANIMATION_SPIN = "animation-spin";
  function codiconCSSString(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
    return codiconCSSClasses(codiconId, actionItem, animationSpin, additionalCSS).join(" ");
  }
  exports.codiconCSSString = codiconCSSString;
  function codiconCSSClasses(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
    const cssClassArray = ["codicon", `codicon-${codiconId}`];
    if (actionItem) {
      cssClassArray.push(exports.ACTION_ITEM);
    }
    if (animationSpin) {
      cssClassArray.push(exports.ANIMATION_SPIN);
    }
    if (additionalCSS.length > 0) {
      cssClassArray.push(...additionalCSS);
    }
    return cssClassArray;
  }
  exports.codiconCSSClasses = codiconCSSClasses;
})(codicon);
var keyboard = {};
Object.defineProperty(keyboard, "__esModule", {
  value: true
});
keyboard.getActualCode = keyboard.matchesKeystroke = void 0;
const browser_1$4 = browser;
function matchesKeystroke(event, code, ...modifiers) {
  if (getActualCode(event) !== code)
    return false;
  if ((0, browser_1$4.isMac)()) {
    if (event.ctrlKey !== modifiers.findIndex((m) => m === "ctrl") >= 0)
      return false;
    if (event.metaKey !== modifiers.findIndex((m) => m === "meta" || m === "ctrlCmd") >= 0)
      return false;
  } else {
    if (event.ctrlKey !== modifiers.findIndex((m) => m === "ctrl" || m === "ctrlCmd") >= 0)
      return false;
    if (event.metaKey !== modifiers.findIndex((m) => m === "meta") >= 0)
      return false;
  }
  if (event.altKey !== modifiers.findIndex((m) => m === "alt") >= 0)
    return false;
  if (event.shiftKey !== modifiers.findIndex((m) => m === "shift") >= 0)
    return false;
  return true;
}
keyboard.matchesKeystroke = matchesKeystroke;
function getActualCode(event) {
  if (event.keyCode) {
    const result = STRING_CODE[event.keyCode];
    if (result !== void 0)
      return result;
  }
  return event.code;
}
keyboard.getActualCode = getActualCode;
const STRING_CODE = new Array(256);
(() => {
  function addKeyCode(stringCode, numericCode) {
    if (STRING_CODE[numericCode] === void 0)
      STRING_CODE[numericCode] = stringCode;
  }
  addKeyCode("Pause", 3);
  addKeyCode("Backspace", 8);
  addKeyCode("Tab", 9);
  addKeyCode("Enter", 13);
  addKeyCode("ShiftLeft", 16);
  addKeyCode("ShiftRight", 16);
  addKeyCode("ControlLeft", 17);
  addKeyCode("ControlRight", 17);
  addKeyCode("AltLeft", 18);
  addKeyCode("AltRight", 18);
  addKeyCode("CapsLock", 20);
  addKeyCode("Escape", 27);
  addKeyCode("Space", 32);
  addKeyCode("PageUp", 33);
  addKeyCode("PageDown", 34);
  addKeyCode("End", 35);
  addKeyCode("Home", 36);
  addKeyCode("ArrowLeft", 37);
  addKeyCode("ArrowUp", 38);
  addKeyCode("ArrowRight", 39);
  addKeyCode("ArrowDown", 40);
  addKeyCode("Insert", 45);
  addKeyCode("Delete", 46);
  addKeyCode("Digit1", 49);
  addKeyCode("Digit2", 50);
  addKeyCode("Digit3", 51);
  addKeyCode("Digit4", 52);
  addKeyCode("Digit5", 53);
  addKeyCode("Digit6", 54);
  addKeyCode("Digit7", 55);
  addKeyCode("Digit8", 56);
  addKeyCode("Digit9", 57);
  addKeyCode("Digit0", 48);
  addKeyCode("KeyA", 65);
  addKeyCode("KeyB", 66);
  addKeyCode("KeyC", 67);
  addKeyCode("KeyD", 68);
  addKeyCode("KeyE", 69);
  addKeyCode("KeyF", 70);
  addKeyCode("KeyG", 71);
  addKeyCode("KeyH", 72);
  addKeyCode("KeyI", 73);
  addKeyCode("KeyJ", 74);
  addKeyCode("KeyK", 75);
  addKeyCode("KeyL", 76);
  addKeyCode("KeyM", 77);
  addKeyCode("KeyN", 78);
  addKeyCode("KeyO", 79);
  addKeyCode("KeyP", 80);
  addKeyCode("KeyQ", 81);
  addKeyCode("KeyR", 82);
  addKeyCode("KeyS", 83);
  addKeyCode("KeyT", 84);
  addKeyCode("KeyU", 85);
  addKeyCode("KeyV", 86);
  addKeyCode("KeyW", 87);
  addKeyCode("KeyX", 88);
  addKeyCode("KeyY", 89);
  addKeyCode("KeyZ", 90);
  addKeyCode("OSLeft", 91);
  addKeyCode("MetaLeft", 91);
  addKeyCode("OSRight", 92);
  addKeyCode("MetaRight", 92);
  addKeyCode("ContextMenu", 93);
  addKeyCode("Numpad0", 96);
  addKeyCode("Numpad1", 97);
  addKeyCode("Numpad2", 98);
  addKeyCode("Numpad3", 99);
  addKeyCode("Numpad4", 100);
  addKeyCode("Numpad5", 101);
  addKeyCode("Numpad6", 102);
  addKeyCode("Numpad7", 103);
  addKeyCode("Numpad8", 104);
  addKeyCode("Numpad9", 105);
  addKeyCode("NumpadMultiply", 106);
  addKeyCode("NumpadAdd", 107);
  addKeyCode("NumpadSeparator", 108);
  addKeyCode("NumpadSubtract", 109);
  addKeyCode("NumpadDecimal", 110);
  addKeyCode("NumpadDivide", 111);
  addKeyCode("F1", 112);
  addKeyCode("F2", 113);
  addKeyCode("F3", 114);
  addKeyCode("F4", 115);
  addKeyCode("F5", 116);
  addKeyCode("F6", 117);
  addKeyCode("F7", 118);
  addKeyCode("F8", 119);
  addKeyCode("F9", 120);
  addKeyCode("F10", 121);
  addKeyCode("F11", 122);
  addKeyCode("F12", 123);
  addKeyCode("F13", 124);
  addKeyCode("F14", 125);
  addKeyCode("F15", 126);
  addKeyCode("F16", 127);
  addKeyCode("F17", 128);
  addKeyCode("F18", 129);
  addKeyCode("F19", 130);
  addKeyCode("F20", 131);
  addKeyCode("F21", 132);
  addKeyCode("F22", 133);
  addKeyCode("F23", 134);
  addKeyCode("F24", 135);
  addKeyCode("NumLock", 144);
  addKeyCode("ScrollLock", 145);
  addKeyCode("Semicolon", 186);
  addKeyCode("Equal", 187);
  addKeyCode("Comma", 188);
  addKeyCode("Minus", 189);
  addKeyCode("Period", 190);
  addKeyCode("Slash", 191);
  addKeyCode("Backquote", 192);
  addKeyCode("IntlRo", 193);
  addKeyCode("BracketLeft", 219);
  addKeyCode("Backslash", 220);
  addKeyCode("BracketRight", 221);
  addKeyCode("Quote", 222);
  addKeyCode("IntlYen", 255);
})();
var model$c = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isSelected = exports.isSelectable = exports.selectFeature = void 0;
  exports.selectFeature = Symbol("selectFeature");
  function isSelectable(element) {
    return element.hasFeature(exports.selectFeature);
  }
  exports.isSelectable = isSelectable;
  function isSelected(element) {
    return element !== void 0 && isSelectable(element) && element.selected;
  }
  exports.isSelected = isSelected;
})(model$c);
var autocomplete = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function autocomplete2(settings) {
      var doc2 = document;
      var container = settings.container || doc2.createElement("div");
      var preventSubmit = settings.preventSubmit || 0;
      container.id = container.id || "autocomplete-" + uid2();
      var containerStyle = container.style;
      var debounceWaitMs = settings.debounceWaitMs || 0;
      var disableAutoSelect = settings.disableAutoSelect || false;
      var customContainerParent = container.parentElement;
      var items = [];
      var inputValue = "";
      var minLen = 2;
      var showOnFocus = settings.showOnFocus;
      var selected;
      var fetchCounter = 0;
      var debounceTimer;
      var destroyed = false;
      var suppressAutocomplete = false;
      if (settings.minLength !== void 0) {
        minLen = settings.minLength;
      }
      if (!settings.input) {
        throw new Error("input undefined");
      }
      var input = settings.input;
      container.className = "autocomplete " + (settings.className || "");
      container.setAttribute("role", "listbox");
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-expanded", "false");
      input.setAttribute("aria-autocomplete", "list");
      input.setAttribute("aria-controls", container.id);
      input.setAttribute("aria-owns", container.id);
      input.setAttribute("aria-activedescendant", "");
      input.setAttribute("aria-haspopup", "listbox");
      containerStyle.position = "absolute";
      function uid2() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
      }
      function detach() {
        var parent = container.parentNode;
        if (parent) {
          parent.removeChild(container);
        }
      }
      function clearDebounceTimer() {
        if (debounceTimer) {
          window.clearTimeout(debounceTimer);
        }
      }
      function attach() {
        if (!container.parentNode) {
          (customContainerParent || doc2.body).appendChild(container);
        }
      }
      function containerDisplayed() {
        return !!container.parentNode;
      }
      function clear2() {
        fetchCounter++;
        items = [];
        inputValue = "";
        selected = void 0;
        input.setAttribute("aria-activedescendant", "");
        input.setAttribute("aria-expanded", "false");
        detach();
      }
      function updatePosition() {
        if (!containerDisplayed()) {
          return;
        }
        input.setAttribute("aria-expanded", "true");
        containerStyle.height = "auto";
        containerStyle.width = input.offsetWidth + "px";
        var maxHeight = 0;
        var inputRect;
        function calc() {
          var docEl = doc2.documentElement;
          var clientTop = docEl.clientTop || doc2.body.clientTop || 0;
          var clientLeft = docEl.clientLeft || doc2.body.clientLeft || 0;
          var scrollTop = window.pageYOffset || docEl.scrollTop;
          var scrollLeft = window.pageXOffset || docEl.scrollLeft;
          inputRect = input.getBoundingClientRect();
          var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
          var left = inputRect.left + scrollLeft - clientLeft;
          containerStyle.top = top + "px";
          containerStyle.left = left + "px";
          maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
          if (maxHeight < 0) {
            maxHeight = 0;
          }
          containerStyle.top = top + "px";
          containerStyle.bottom = "";
          containerStyle.left = left + "px";
          containerStyle.maxHeight = maxHeight + "px";
        }
        calc();
        calc();
        if (settings.customize && inputRect) {
          settings.customize(input, inputRect, container, maxHeight);
        }
      }
      function update() {
        container.textContent = "";
        input.setAttribute("aria-activedescendant", "");
        var render = function(item, _, __) {
          var itemElement = doc2.createElement("div");
          itemElement.textContent = item.label || "";
          return itemElement;
        };
        if (settings.render) {
          render = settings.render;
        }
        var renderGroup = function(groupName, _) {
          var groupDiv = doc2.createElement("div");
          groupDiv.textContent = groupName;
          return groupDiv;
        };
        if (settings.renderGroup) {
          renderGroup = settings.renderGroup;
        }
        var fragment2 = doc2.createDocumentFragment();
        var prevGroup = uid2();
        items.forEach(function(item, index) {
          if (item.group && item.group !== prevGroup) {
            prevGroup = item.group;
            var groupDiv = renderGroup(item.group, inputValue);
            if (groupDiv) {
              groupDiv.className += " group";
              fragment2.appendChild(groupDiv);
            }
          }
          var div = render(item, inputValue, index);
          if (div) {
            div.id = container.id + "_" + index;
            div.setAttribute("role", "option");
            div.addEventListener("click", function(ev) {
              suppressAutocomplete = true;
              try {
                settings.onSelect(item, input);
              } finally {
                suppressAutocomplete = false;
              }
              clear2();
              ev.preventDefault();
              ev.stopPropagation();
            });
            if (item === selected) {
              div.className += " selected";
              div.setAttribute("aria-selected", "true");
              input.setAttribute("aria-activedescendant", div.id);
            }
            fragment2.appendChild(div);
          }
        });
        container.appendChild(fragment2);
        if (items.length < 1) {
          if (settings.emptyMsg) {
            var empty = doc2.createElement("div");
            empty.id = container.id + "_" + uid2();
            empty.className = "empty";
            empty.textContent = settings.emptyMsg;
            container.appendChild(empty);
            input.setAttribute("aria-activedescendant", empty.id);
          } else {
            clear2();
            return;
          }
        }
        attach();
        updatePosition();
        updateScroll();
      }
      function updateIfDisplayed() {
        if (containerDisplayed()) {
          update();
        }
      }
      function resizeEventHandler() {
        updateIfDisplayed();
      }
      function scrollEventHandler(e) {
        if (e.target !== container) {
          updateIfDisplayed();
        } else {
          e.preventDefault();
        }
      }
      function inputEventHandler() {
        if (!suppressAutocomplete) {
          fetch2(
            0
            /* Keyboard */
          );
        }
      }
      function updateScroll() {
        var elements = container.getElementsByClassName("selected");
        if (elements.length > 0) {
          var element = elements[0];
          var previous = element.previousElementSibling;
          if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
            element = previous;
          }
          if (element.offsetTop < container.scrollTop) {
            container.scrollTop = element.offsetTop;
          } else {
            var selectBottom = element.offsetTop + element.offsetHeight;
            var containerBottom = container.scrollTop + container.offsetHeight;
            if (selectBottom > containerBottom) {
              container.scrollTop += selectBottom - containerBottom;
            }
          }
        }
      }
      function selectPreviousSuggestion() {
        var index = items.indexOf(selected);
        selected = index === -1 ? void 0 : items[(index + items.length - 1) % items.length];
        updateSelectedSuggestion(index);
      }
      function selectNextSuggestion() {
        var index = items.indexOf(selected);
        selected = items.length < 1 ? void 0 : index === -1 ? items[0] : items[(index + 1) % items.length];
        updateSelectedSuggestion(index);
      }
      function updateSelectedSuggestion(index) {
        if (items.length > 0) {
          unselectSuggestion(index);
          selectSuggestion(items.indexOf(selected));
          updateScroll();
        }
      }
      function selectSuggestion(index) {
        var element = doc2.getElementById(container.id + "_" + index);
        if (element) {
          element.classList.add("selected");
          element.setAttribute("aria-selected", "true");
          input.setAttribute("aria-activedescendant", element.id);
        }
      }
      function unselectSuggestion(index) {
        var element = doc2.getElementById(container.id + "_" + index);
        if (element) {
          element.classList.remove("selected");
          element.removeAttribute("aria-selected");
          input.removeAttribute("aria-activedescendant");
        }
      }
      function handleArrowAndEscapeKeys(ev, key) {
        var containerIsDisplayed = containerDisplayed();
        if (key === "Escape") {
          clear2();
        } else {
          if (!containerIsDisplayed || items.length < 1) {
            return;
          }
          key === "ArrowUp" ? selectPreviousSuggestion() : selectNextSuggestion();
        }
        ev.preventDefault();
        if (containerIsDisplayed) {
          ev.stopPropagation();
        }
      }
      function handleEnterKey(ev) {
        if (selected) {
          if (preventSubmit === 2) {
            ev.preventDefault();
          }
          suppressAutocomplete = true;
          try {
            settings.onSelect(selected, input);
          } finally {
            suppressAutocomplete = false;
          }
          clear2();
        }
        if (preventSubmit === 1) {
          ev.preventDefault();
        }
      }
      function keydownEventHandler(ev) {
        var key = ev.key;
        switch (key) {
          case "ArrowUp":
          case "ArrowDown":
          case "Escape":
            handleArrowAndEscapeKeys(ev, key);
            break;
          case "Enter":
            handleEnterKey(ev);
            break;
        }
      }
      function focusEventHandler() {
        if (showOnFocus) {
          fetch2(
            1
            /* Focus */
          );
        }
      }
      function fetch2(trigger2) {
        if (input.value.length >= minLen || trigger2 === 1) {
          clearDebounceTimer();
          debounceTimer = window.setTimeout(function() {
            return startFetch(input.value, trigger2, input.selectionStart || 0);
          }, trigger2 === 0 || trigger2 === 2 ? debounceWaitMs : 0);
        } else {
          clear2();
        }
      }
      function startFetch(inputText, trigger2, cursorPos) {
        if (destroyed)
          return;
        var savedFetchCounter = ++fetchCounter;
        settings.fetch(inputText, function(elements) {
          if (fetchCounter === savedFetchCounter && elements) {
            items = elements;
            inputValue = inputText;
            selected = items.length < 1 || disableAutoSelect ? void 0 : items[0];
            update();
          }
        }, trigger2, cursorPos);
      }
      function keyupEventHandler(e) {
        if (settings.keyup) {
          settings.keyup({
            event: e,
            fetch: function() {
              return fetch2(
                0
                /* Keyboard */
              );
            }
          });
          return;
        }
        if (!containerDisplayed() && e.key === "ArrowDown") {
          fetch2(
            0
            /* Keyboard */
          );
        }
      }
      function clickEventHandler(e) {
        settings.click && settings.click({
          event: e,
          fetch: function() {
            return fetch2(
              2
              /* Mouse */
            );
          }
        });
      }
      function blurEventHandler() {
        setTimeout(function() {
          if (doc2.activeElement !== input) {
            clear2();
          }
        }, 200);
      }
      function manualFetch() {
        startFetch(input.value, 3, input.selectionStart || 0);
      }
      container.addEventListener("mousedown", function(evt) {
        evt.stopPropagation();
        evt.preventDefault();
      });
      container.addEventListener("focus", function() {
        return input.focus();
      });
      detach();
      function destroy2() {
        input.removeEventListener("focus", focusEventHandler);
        input.removeEventListener("keyup", keyupEventHandler);
        input.removeEventListener("click", clickEventHandler);
        input.removeEventListener("keydown", keydownEventHandler);
        input.removeEventListener("input", inputEventHandler);
        input.removeEventListener("blur", blurEventHandler);
        window.removeEventListener("resize", resizeEventHandler);
        doc2.removeEventListener("scroll", scrollEventHandler, true);
        input.removeAttribute("role");
        input.removeAttribute("aria-expanded");
        input.removeAttribute("aria-autocomplete");
        input.removeAttribute("aria-controls");
        input.removeAttribute("aria-activedescendant");
        input.removeAttribute("aria-owns");
        input.removeAttribute("aria-haspopup");
        clearDebounceTimer();
        clear2();
        destroyed = true;
      }
      input.addEventListener("keyup", keyupEventHandler);
      input.addEventListener("click", clickEventHandler);
      input.addEventListener("keydown", keydownEventHandler);
      input.addEventListener("input", inputEventHandler);
      input.addEventListener("blur", blurEventHandler);
      input.addEventListener("focus", focusEventHandler);
      window.addEventListener("resize", resizeEventHandler);
      doc2.addEventListener("scroll", scrollEventHandler, true);
      return {
        destroy: destroy2,
        fetch: manualFetch
      };
    }
    return autocomplete2;
  });
})(autocomplete);
var autocompleteExports = autocomplete.exports;
var __decorate$N = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$x = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
var CommandPalette_1;
Object.defineProperty(commandPalette, "__esModule", {
  value: true
});
commandPalette.CommandPaletteKeyListener = commandPalette.CommandPalette = void 0;
const inversify_1$17 = require$$0$1;
const actions_1$m = actions;
const action_1 = action;
const types_1$L = types;
const ui_extension_1$1 = uiExtension;
const ui_extension_registry_1$1 = uiExtensionRegistry;
const dom_helper_1$1 = domHelper;
const key_tool_1$6 = keyTool;
const codicon_1 = codicon;
const iterable_1$3 = iterable;
const keyboard_1$7 = keyboard;
const model_1$D = model$g;
const model_2$h = model$c;
const action_providers_1$1 = actionProviders;
const mouse_tool_1$9 = mouseTool;
const autocompleter_1 = __importDefault$4(autocompleteExports);
let CommandPalette = CommandPalette_1 = class CommandPalette2 extends ui_extension_1$1.AbstractUIExtension {
  constructor() {
    super(...arguments);
    this.loadingIndicatorClasses = (0, codicon_1.codiconCSSClasses)("loading", false, true, ["loading"]);
    this.xOffset = 20;
    this.yOffset = 20;
    this.defaultWidth = 400;
    this.debounceWaitMs = 100;
    this.noCommandsMsg = "No commands available";
    this.paletteIndex = 0;
  }
  id() {
    return CommandPalette_1.ID;
  }
  containerClass() {
    return "command-palette";
  }
  show(root, ...contextElementIds) {
    super.show(root, ...contextElementIds);
    this.paletteIndex = 0;
    this.contextActions = void 0;
    this.inputElement.value = "";
    this.autoCompleteResult = (0, autocompleter_1.default)(this.autocompleteSettings(root));
    this.inputElement.focus();
  }
  initializeContents(containerElement) {
    containerElement.style.position = "absolute";
    this.inputElement = document.createElement("input");
    this.inputElement.style.width = "100%";
    this.inputElement.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
    this.inputElement.addEventListener("keydown", (event) => this.cylceIfInvokePaletteKey(event));
    this.inputElement.onblur = () => window.setTimeout(() => this.hide(), 200);
    containerElement.appendChild(this.inputElement);
  }
  hideIfEscapeEvent(event) {
    if ((0, keyboard_1$7.matchesKeystroke)(event, "Escape")) {
      this.hide();
    }
  }
  cylceIfInvokePaletteKey(event) {
    if (CommandPalette_1.isInvokePaletteKey(event)) {
      this.cycle();
    }
  }
  cycle() {
    this.contextActions = void 0;
    this.paletteIndex++;
  }
  onBeforeShow(containerElement, root, ...selectedElementIds) {
    let x = this.xOffset;
    let y = this.yOffset;
    const selectedElements = (0, iterable_1$3.toArray)(root.index.all().filter((e) => (0, model_2$h.isSelectable)(e) && e.selected));
    if (selectedElements.length === 1) {
      const bounds = (0, model_1$D.getAbsoluteClientBounds)(selectedElements[0], this.domHelper, this.viewerOptions);
      x += bounds.x + bounds.width;
      y += bounds.y;
    } else {
      const bounds = (0, model_1$D.getAbsoluteClientBounds)(root, this.domHelper, this.viewerOptions);
      x += bounds.x;
      y += bounds.y;
    }
    containerElement.style.left = `${x}px`;
    containerElement.style.top = `${y}px`;
    containerElement.style.width = `${this.defaultWidth}px`;
  }
  autocompleteSettings(root) {
    return {
      input: this.inputElement,
      emptyMsg: this.noCommandsMsg,
      className: "command-palette-suggestions",
      debounceWaitMs: this.debounceWaitMs,
      showOnFocus: true,
      minLength: -1,
      fetch: (text, update) => this.updateAutoCompleteActions(update, text, root),
      onSelect: (item) => this.onSelect(item),
      render: (item, currentValue) => this.renderLabeledActionSuggestion(item, currentValue),
      customize: (input, inputRect, container, maxHeight) => {
        this.customizeSuggestionContainer(container, inputRect, maxHeight);
      }
    };
  }
  onSelect(item) {
    this.executeAction(item);
    this.hide();
  }
  updateAutoCompleteActions(update, text, root) {
    this.onLoading();
    if (this.contextActions) {
      update(this.filterActions(text, this.contextActions));
      this.onLoaded("success");
    } else {
      this.actionProviderRegistry.getActions(root, text, this.mousePositionTracker.lastPositionOnDiagram, this.paletteIndex).then((actions2) => {
        this.contextActions = actions2;
        update(this.filterActions(text, actions2));
        this.onLoaded("success");
      }).catch((reason) => {
        this.logger.error(this, "Failed to obtain actions from command palette action providers", reason);
        this.onLoaded("error");
      });
    }
  }
  onLoading() {
    if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
      return;
    }
    this.loadingIndicator = document.createElement("span");
    this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
    this.containerElement.appendChild(this.loadingIndicator);
  }
  onLoaded(success) {
    if (this.containerElement.contains(this.loadingIndicator)) {
      this.containerElement.removeChild(this.loadingIndicator);
    }
  }
  renderLabeledActionSuggestion(item, value) {
    const itemElement = document.createElement("div");
    const wordMatcher = espaceForRegExp(value).split(" ").join("|");
    const regex = new RegExp(wordMatcher, "gi");
    if (item.icon) {
      this.renderIcon(itemElement, item.icon);
    }
    if (value.length > 0) {
      itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
    } else {
      itemElement.innerHTML += item.label.replace(/ /g, "&nbsp;");
    }
    return itemElement;
  }
  renderIcon(itemElement, iconId) {
    itemElement.innerHTML += `<span class="icon ${this.getCodicon(iconId)}"></span>`;
  }
  getFontAwesomeIcon(iconId) {
    return `fa fa-${iconId}`;
  }
  getCodicon(iconId) {
    return (0, codicon_1.codiconCSSString)(iconId);
  }
  filterActions(filterText, actions2) {
    return (0, iterable_1$3.toArray)(actions2.filter((action2) => {
      const label = action2.label.toLowerCase();
      const searchWords = filterText.split(" ");
      return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
    }));
  }
  customizeSuggestionContainer(container, inputRect, maxHeight) {
    container.style.position = "fixed";
    if (this.containerElement) {
      this.containerElement.appendChild(container);
    }
  }
  hide() {
    super.hide();
    if (this.autoCompleteResult) {
      this.autoCompleteResult.destroy();
    }
  }
  executeAction(input) {
    this.actionDispatcherProvider().then((actionDispatcher2) => actionDispatcher2.dispatchAll(toActionArray(input))).catch((reason) => this.logger.error(this, "No action dispatcher available to execute command palette action", reason));
  }
};
commandPalette.CommandPalette = CommandPalette;
CommandPalette.ID = "command-palette";
CommandPalette.isInvokePaletteKey = (event) => (0, keyboard_1$7.matchesKeystroke)(event, "Space", "ctrl");
__decorate$N([(0, inversify_1$17.inject)(types_1$L.TYPES.IActionDispatcherProvider), __metadata$x("design:type", Function)], CommandPalette.prototype, "actionDispatcherProvider", void 0);
__decorate$N([(0, inversify_1$17.inject)(types_1$L.TYPES.ICommandPaletteActionProviderRegistry), __metadata$x("design:type", action_providers_1$1.CommandPaletteActionProviderRegistry)], CommandPalette.prototype, "actionProviderRegistry", void 0);
__decorate$N([(0, inversify_1$17.inject)(types_1$L.TYPES.ViewerOptions), __metadata$x("design:type", Object)], CommandPalette.prototype, "viewerOptions", void 0);
__decorate$N([(0, inversify_1$17.inject)(types_1$L.TYPES.DOMHelper), __metadata$x("design:type", dom_helper_1$1.DOMHelper)], CommandPalette.prototype, "domHelper", void 0);
__decorate$N([(0, inversify_1$17.inject)(mouse_tool_1$9.MousePositionTracker), __metadata$x("design:type", mouse_tool_1$9.MousePositionTracker)], CommandPalette.prototype, "mousePositionTracker", void 0);
commandPalette.CommandPalette = CommandPalette = CommandPalette_1 = __decorate$N([(0, inversify_1$17.injectable)()], CommandPalette);
function toActionArray(input) {
  if ((0, action_1.isLabeledAction)(input)) {
    return input.actions;
  } else if ((0, actions_1$m.isAction)(input)) {
    return [input];
  }
  return [];
}
function espaceForRegExp(value) {
  return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
}
class CommandPaletteKeyListener extends key_tool_1$6.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$7.matchesKeystroke)(event, "Escape")) {
      return [ui_extension_registry_1$1.SetUIExtensionVisibilityAction.create({
        extensionId: CommandPalette.ID,
        visible: false,
        contextElementsId: []
      })];
    } else if (CommandPalette.isInvokePaletteKey(event)) {
      const selectedElements = (0, iterable_1$3.toArray)(element.index.all().filter((e) => (0, model_2$h.isSelectable)(e) && e.selected).map((e) => e.id));
      return [ui_extension_registry_1$1.SetUIExtensionVisibilityAction.create({
        extensionId: CommandPalette.ID,
        visible: true,
        contextElementsId: selectedElements
      })];
    }
    return [];
  }
}
commandPalette.CommandPaletteKeyListener = CommandPaletteKeyListener;
var contextMenuService = {};
Object.defineProperty(contextMenuService, "__esModule", {
  value: true
});
contextMenuService.toAnchor = void 0;
function toAnchor(anchor2) {
  return anchor2 instanceof HTMLElement ? {
    x: anchor2.offsetLeft,
    y: anchor2.offsetTop
  } : anchor2;
}
contextMenuService.toAnchor = toAnchor;
var menuProviders = {};
var _delete = {};
(function(exports) {
  var __decorate2 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata2 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var __param2 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DeleteElementCommand = exports.ResolvedDelete = exports.isDeletable = exports.deletableFeature = void 0;
  const inversify_12 = require$$0$1;
  const actions_12 = actions;
  const command_12 = command;
  const smodel_12 = smodel;
  const types_12 = types;
  exports.deletableFeature = Symbol("deletableFeature");
  function isDeletable(element) {
    return element instanceof smodel_12.SChildElementImpl && element.hasFeature(exports.deletableFeature);
  }
  exports.isDeletable = isDeletable;
  class ResolvedDelete {
  }
  exports.ResolvedDelete = ResolvedDelete;
  let DeleteElementCommand = class DeleteElementCommand extends command_12.Command {
    constructor(action2) {
      super();
      this.action = action2;
      this.resolvedDeletes = [];
    }
    execute(context) {
      const index = context.root.index;
      for (const id2 of this.action.elementIds) {
        const element = index.getById(id2);
        if (element && isDeletable(element)) {
          this.resolvedDeletes.push({
            child: element,
            parent: element.parent
          });
          element.parent.remove(element);
        }
      }
      return context.root;
    }
    undo(context) {
      for (const resolvedDelete of this.resolvedDeletes)
        resolvedDelete.parent.add(resolvedDelete.child);
      return context.root;
    }
    redo(context) {
      for (const resolvedDelete of this.resolvedDeletes)
        resolvedDelete.parent.remove(resolvedDelete.child);
      return context.root;
    }
  };
  exports.DeleteElementCommand = DeleteElementCommand;
  DeleteElementCommand.KIND = actions_12.DeleteElementAction.KIND;
  exports.DeleteElementCommand = DeleteElementCommand = __decorate2([(0, inversify_12.injectable)(), __param2(0, (0, inversify_12.inject)(types_12.TYPES.Action)), __metadata2("design:paramtypes", [Object])], DeleteElementCommand);
})(_delete);
var __decorate$M = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$w = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$g = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(menuProviders, "__esModule", {
  value: true
});
menuProviders.DeleteContextMenuItemProvider = menuProviders.ContextMenuProviderRegistry = void 0;
const inversify_1$16 = require$$0$1;
const types_1$K = types;
const delete_1$2 = _delete;
const model_1$C = model$c;
const sprotty_protocol_1$4 = lib;
let ContextMenuProviderRegistry = class ContextMenuProviderRegistry2 {
  constructor(menuProviders2 = []) {
    this.menuProviders = menuProviders2;
  }
  getItems(root, lastMousePosition) {
    const menues = this.menuProviders.map((provider) => provider.getItems(root, lastMousePosition));
    return Promise.all(menues).then(this.flattenAndRestructure);
  }
  flattenAndRestructure(p2) {
    let menuItems = p2.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc, []);
    const menuItemsWithParentId = menuItems.filter((menuItem) => menuItem.parentId);
    for (const menuItem of menuItemsWithParentId) {
      if (menuItem.parentId) {
        const fragments = menuItem.parentId.split(".");
        let matchingParent = void 0;
        let nextParents = menuItems;
        for (const fragment2 of fragments) {
          matchingParent = nextParents.find((item) => fragment2 === item.id);
          if (matchingParent && matchingParent.children)
            nextParents = matchingParent.children;
        }
        if (matchingParent) {
          if (matchingParent.children) {
            matchingParent.children.push(menuItem);
          } else {
            matchingParent.children = [menuItem];
          }
          menuItems = menuItems.filter((item) => item !== menuItem);
        }
      }
    }
    return menuItems;
  }
};
menuProviders.ContextMenuProviderRegistry = ContextMenuProviderRegistry;
menuProviders.ContextMenuProviderRegistry = ContextMenuProviderRegistry = __decorate$M([(0, inversify_1$16.injectable)(), __param$g(0, (0, inversify_1$16.multiInject)(types_1$K.TYPES.IContextMenuItemProvider)), __param$g(0, (0, inversify_1$16.optional)()), __metadata$w("design:paramtypes", [Array])], ContextMenuProviderRegistry);
let DeleteContextMenuItemProvider = class DeleteContextMenuItemProvider2 {
  getItems(root, lastMousePosition) {
    const selectedElements = Array.from(root.index.all().filter(model_1$C.isSelected).filter(delete_1$2.isDeletable));
    return Promise.resolve([{
      id: "delete",
      label: "Delete",
      sortString: "d",
      group: "edit",
      actions: [sprotty_protocol_1$4.DeleteElementAction.create(selectedElements.map((e) => e.id))],
      isEnabled: () => selectedElements.length > 0
    }]);
  }
};
menuProviders.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider;
menuProviders.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider = __decorate$M([(0, inversify_1$16.injectable)()], DeleteContextMenuItemProvider);
var mouseListener = {};
var __decorate$L = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$v = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$f = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(mouseListener, "__esModule", {
  value: true
});
mouseListener.ContextMenuMouseListener = void 0;
const inversify_1$15 = require$$0$1;
const actions_1$l = actions;
const smodel_utils_1$c = smodelUtils;
const types_1$J = types;
const mouse_tool_1$8 = mouseTool;
const model_1$B = model$c;
const menu_providers_1$1 = menuProviders;
let ContextMenuMouseListener = class ContextMenuMouseListener2 extends mouse_tool_1$8.MouseListener {
  constructor(contextMenuService2, menuProvider) {
    super();
    this.contextMenuService = contextMenuService2;
    this.menuProvider = menuProvider;
  }
  contextMenu(target, event) {
    this.showContextMenu(target, event);
    return [];
  }
  async showContextMenu(target, event) {
    let menuService;
    try {
      menuService = await this.contextMenuService();
    } catch (rejected) {
      return;
    }
    let isTargetSelected = false;
    const selectableTarget = (0, smodel_utils_1$c.findParentByFeature)(target, model_1$B.isSelectable);
    if (selectableTarget) {
      isTargetSelected = selectableTarget.selected;
      selectableTarget.selected = true;
    }
    const root = target.root;
    const mousePosition = {
      x: event.x,
      y: event.y
    };
    if (target.id === root.id || (0, model_1$B.isSelected)(selectableTarget)) {
      const menuItems = await this.menuProvider.getItems(root, mousePosition);
      const restoreSelection = () => {
        if (selectableTarget)
          selectableTarget.selected = isTargetSelected;
      };
      menuService.show(menuItems, mousePosition, restoreSelection);
    } else {
      if ((0, model_1$B.isSelectable)(target)) {
        const options = {
          selectedElementsIDs: [target.id],
          deselectedElementsIDs: Array.from(root.index.all().filter(model_1$B.isSelected), (val) => {
            return val.id;
          })
        };
        await this.actionDispatcher.dispatch(actions_1$l.SelectAction.create(options));
      }
      const items = await this.menuProvider.getItems(root, mousePosition);
      menuService.show(items, mousePosition);
    }
  }
};
mouseListener.ContextMenuMouseListener = ContextMenuMouseListener;
__decorate$L([(0, inversify_1$15.inject)(types_1$J.TYPES.IActionDispatcher), __metadata$v("design:type", Object)], ContextMenuMouseListener.prototype, "actionDispatcher", void 0);
mouseListener.ContextMenuMouseListener = ContextMenuMouseListener = __decorate$L([__param$f(0, (0, inversify_1$15.inject)(types_1$J.TYPES.IContextMenuServiceProvider)), __param$f(1, (0, inversify_1$15.inject)(types_1$J.TYPES.IContextMenuProviderRegistry)), __metadata$v("design:paramtypes", [Function, menu_providers_1$1.ContextMenuProviderRegistry])], ContextMenuMouseListener);
var di_config$l = {};
var edgeLayout = {};
var sgraph = {};
var model$b = {};
var model$a = {};
var model$9 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hasPopupFeature = exports.popupFeature = exports.isHoverable = exports.hoverFeedbackFeature = void 0;
  exports.hoverFeedbackFeature = Symbol("hoverFeedbackFeature");
  function isHoverable(element) {
    return element.hasFeature(exports.hoverFeedbackFeature);
  }
  exports.isHoverable = isHoverable;
  exports.popupFeature = Symbol("popupFeature");
  function hasPopupFeature(element) {
    return element.hasFeature(exports.popupFeature);
  }
  exports.hasPopupFeature = hasPopupFeature;
})(model$9);
var model$8 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isMoveable = exports.isLocateable = exports.moveFeature = void 0;
  const object_12 = object;
  exports.moveFeature = Symbol("moveFeature");
  function isLocateable(element) {
    return (0, object_12.hasOwnProperty)(element, "position");
  }
  exports.isLocateable = isLocateable;
  function isMoveable(element) {
    return element.hasFeature(exports.moveFeature) && isLocateable(element);
  }
  exports.isMoveable = isMoveable;
})(model$8);
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.edgeInProgressTargetHandleID = exports.edgeInProgressID = exports.SDanglingAnchorImpl = exports.SRoutingHandleImpl = exports.SConnectableElementImpl = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.isConnectable = exports.connectableFeature = exports.SRoutableElementImpl = void 0;
  const geometry_12 = geometry$1;
  const smodel_12 = smodel;
  const model_12 = model$g;
  const delete_12 = _delete;
  const model_22 = model$c;
  const model_32 = model$9;
  const model_42 = model$8;
  class SRoutableElementImpl extends smodel_12.SChildElementImpl {
    constructor() {
      super(...arguments);
      this.routingPoints = [];
    }
    get source() {
      return this.index.getById(this.sourceId);
    }
    get target() {
      return this.index.getById(this.targetId);
    }
    get bounds() {
      return this.routingPoints.reduce((bounds, routingPoint) => geometry_12.Bounds.combine(bounds, {
        x: routingPoint.x,
        y: routingPoint.y,
        width: 0,
        height: 0
      }), geometry_12.Bounds.EMPTY);
    }
  }
  exports.SRoutableElementImpl = SRoutableElementImpl;
  exports.connectableFeature = Symbol("connectableFeature");
  function isConnectable(element) {
    return element.hasFeature(exports.connectableFeature) && element.canConnect;
  }
  exports.isConnectable = isConnectable;
  function getAbsoluteRouteBounds(model2, route = model2.routingPoints) {
    let bounds = getRouteBounds(route);
    let current = model2;
    while (current instanceof smodel_12.SChildElementImpl) {
      const parent = current.parent;
      bounds = parent.localToParent(bounds);
      current = parent;
    }
    return bounds;
  }
  exports.getAbsoluteRouteBounds = getAbsoluteRouteBounds;
  function getRouteBounds(route) {
    const bounds = {
      x: NaN,
      y: NaN,
      width: 0,
      height: 0
    };
    for (const point of route) {
      if (isNaN(bounds.x)) {
        bounds.x = point.x;
        bounds.y = point.y;
      } else {
        if (point.x < bounds.x) {
          bounds.width += bounds.x - point.x;
          bounds.x = point.x;
        } else if (point.x > bounds.x + bounds.width) {
          bounds.width = point.x - bounds.x;
        }
        if (point.y < bounds.y) {
          bounds.height += bounds.y - point.y;
          bounds.y = point.y;
        } else if (point.y > bounds.y + bounds.height) {
          bounds.height = point.y - bounds.y;
        }
      }
    }
    return bounds;
  }
  exports.getRouteBounds = getRouteBounds;
  class SConnectableElementImpl extends model_12.SShapeElementImpl {
    constructor() {
      super(...arguments);
      this.strokeWidth = 0;
    }
    get anchorKind() {
      return void 0;
    }
    /**
     * The incoming edges of this connectable element. They are resolved by the index, which must
     * be an `SGraphIndex` for efficient lookup.
     */
    get incomingEdges() {
      const allEdges = this.index.all().filter((e) => e instanceof SRoutableElementImpl);
      return allEdges.filter((e) => e.targetId === this.id);
    }
    /**
     * The outgoing edges of this connectable element. They are resolved by the index, which must
     * be an `SGraphIndex` for efficient lookup.
     */
    get outgoingEdges() {
      const allEdges = this.index.all().filter((e) => e instanceof SRoutableElementImpl);
      return allEdges.filter((e) => e.sourceId === this.id);
    }
    canConnect(routable, role) {
      return true;
    }
  }
  exports.SConnectableElementImpl = SConnectableElementImpl;
  class SRoutingHandleImpl extends smodel_12.SChildElementImpl {
    constructor() {
      super(...arguments);
      this.editMode = false;
      this.hoverFeedback = false;
      this.selected = false;
    }
    /**
     * SRoutingHandles are created using the constructor, so we hard-wire the
     * default features
     */
    hasFeature(feature) {
      return SRoutingHandleImpl.DEFAULT_FEATURES.indexOf(feature) !== -1;
    }
  }
  exports.SRoutingHandleImpl = SRoutingHandleImpl;
  SRoutingHandleImpl.DEFAULT_FEATURES = [model_22.selectFeature, model_42.moveFeature, model_32.hoverFeedbackFeature];
  class SDanglingAnchorImpl extends SConnectableElementImpl {
    constructor() {
      super();
      this.type = "dangling-anchor";
      this.size = {
        width: 0,
        height: 0
      };
    }
  }
  exports.SDanglingAnchorImpl = SDanglingAnchorImpl;
  SDanglingAnchorImpl.DEFAULT_FEATURES = [delete_12.deletableFeature];
  exports.edgeInProgressID = "edge-in-progress";
  exports.edgeInProgressTargetHandleID = exports.edgeInProgressID + "-target-anchor";
})(model$a);
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_EDGE_PLACEMENT = exports.EdgePlacement = exports.checkEdgePlacement = exports.isEdgeLayoutable = exports.edgeLayoutFeature = void 0;
  const smodel_12 = smodel;
  const model_12 = model$g;
  const model_22 = model$a;
  exports.edgeLayoutFeature = Symbol("edgeLayout");
  function isEdgeLayoutable(element) {
    return element instanceof smodel_12.SChildElementImpl && element.parent instanceof model_22.SRoutableElementImpl && (0, model_12.isBoundsAware)(element) && element.hasFeature(exports.edgeLayoutFeature);
  }
  exports.isEdgeLayoutable = isEdgeLayoutable;
  function checkEdgePlacement(element) {
    return "edgePlacement" in element;
  }
  exports.checkEdgePlacement = checkEdgePlacement;
  class EdgePlacement extends Object {
  }
  exports.EdgePlacement = EdgePlacement;
  exports.DEFAULT_EDGE_PLACEMENT = {
    rotate: true,
    side: "top",
    position: 0.5,
    offset: 7,
    moveMode: "edge"
  };
})(model$b);
var model$7 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isWithEditableLabel = exports.withEditLabelFeature = exports.isEditableLabel = exports.editLabelFeature = exports.canEditRouting = exports.editFeature = void 0;
  const model_12 = model$a;
  exports.editFeature = Symbol("editFeature");
  function canEditRouting(element) {
    return element instanceof model_12.SRoutableElementImpl && element.hasFeature(exports.editFeature);
  }
  exports.canEditRouting = canEditRouting;
  exports.editLabelFeature = Symbol("editLabelFeature");
  function isEditableLabel(element) {
    return "text" in element && element.hasFeature(exports.editLabelFeature);
  }
  exports.isEditableLabel = isEditableLabel;
  exports.withEditLabelFeature = Symbol("withEditLabelFeature");
  function isWithEditableLabel(element) {
    return "editableLabel" in element && element.hasFeature(exports.withEditLabelFeature);
  }
  exports.isWithEditableLabel = isWithEditableLabel;
})(model$7);
var viewportRoot = {};
var model$6 = {};
var geometry = {};
Object.defineProperty(geometry, "__esModule", {
  value: true
});
geometry.limit = geometry.intersection = geometry.PointToPointLine = geometry.Diamond = void 0;
const sprotty_protocol_1$3 = lib;
class Diamond {
  constructor(bounds) {
    this.bounds = bounds;
  }
  get topPoint() {
    return {
      x: this.bounds.x + this.bounds.width / 2,
      y: this.bounds.y
    };
  }
  get rightPoint() {
    return {
      x: this.bounds.x + this.bounds.width,
      y: this.bounds.y + this.bounds.height / 2
    };
  }
  get bottomPoint() {
    return {
      x: this.bounds.x + this.bounds.width / 2,
      y: this.bounds.y + this.bounds.height
    };
  }
  get leftPoint() {
    return {
      x: this.bounds.x,
      y: this.bounds.y + this.bounds.height / 2
    };
  }
  get topRightSideLine() {
    return new PointToPointLine(this.topPoint, this.rightPoint);
  }
  get topLeftSideLine() {
    return new PointToPointLine(this.topPoint, this.leftPoint);
  }
  get bottomRightSideLine() {
    return new PointToPointLine(this.bottomPoint, this.rightPoint);
  }
  get bottomLeftSideLine() {
    return new PointToPointLine(this.bottomPoint, this.leftPoint);
  }
  /**
   * Return the closest side of this diamond to the specified `refPoint`.
   * @param {Point} refPoint a reference point
   * @returns {Line} a line representing the closest side
   */
  closestSideLine(refPoint) {
    const c = sprotty_protocol_1$3.Bounds.center(this.bounds);
    if (refPoint.x > c.x) {
      if (refPoint.y > c.y) {
        return this.bottomRightSideLine;
      } else {
        return this.topRightSideLine;
      }
    } else {
      if (refPoint.y > c.y) {
        return this.bottomLeftSideLine;
      } else {
        return this.topLeftSideLine;
      }
    }
  }
}
geometry.Diamond = Diamond;
class PointToPointLine {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
  }
  get a() {
    return this.p1.y - this.p2.y;
  }
  get b() {
    return this.p2.x - this.p1.x;
  }
  get c() {
    return this.p2.x * this.p1.y - this.p1.x * this.p2.y;
  }
  /**
   * The counter-clockwise angle of this line relative to the x-axis.
   */
  get angle() {
    return Math.atan2(-this.a, this.b);
  }
  /**
   * The slope of the line.
   * A vertical line returns `undefined`.
   */
  get slope() {
    if (this.b === 0)
      return void 0;
    return this.a / this.b;
  }
  /**
   * The slope of the line or `Number.MAX_SAFE_INTEGER` if vertical.
   */
  get slopeOrMax() {
    if (this.slope === void 0) {
      return Number.MAX_SAFE_INTEGER;
    }
    return this.slope;
  }
  /**
   * The direction of this line, such as 'north', 'south', or 'south-west'.
   */
  get direction() {
    const hDegrees = (0, sprotty_protocol_1$3.toDegrees)(this.angle);
    const degrees = hDegrees < 0 ? 360 + hDegrees : hDegrees;
    if (degrees === 90) {
      return "south";
    } else if (degrees === 0 || degrees === 360) {
      return "east";
    } else if (degrees === 270) {
      return "north";
    } else if (degrees === 180) {
      return "west";
    } else if (degrees > 0 && degrees < 90) {
      return "south-east";
    } else if (degrees > 90 && degrees < 180) {
      return "south-west";
    } else if (degrees > 180 && degrees < 270) {
      return "north-west";
    } else if (degrees > 270 && degrees < 360) {
      return "north-east";
    }
    throw new Error(`Cannot determine direction of line (${this.p1.x},${this.p1.y}) to (${this.p2.x},${this.p2.y})`);
  }
  /**
   * @param otherLine the other line
   * @returns the intersection point between `this` line and the `otherLine` if exists, or `undefined`.
   */
  intersection(otherLine) {
    if (this.hasIndistinctPoints(otherLine)) {
      return void 0;
    }
    const x1 = this.p1.x;
    const y1 = this.p1.y;
    const x2 = this.p2.x;
    const y2 = this.p2.y;
    const x3 = otherLine.p1.x;
    const y3 = otherLine.p1.y;
    const x4 = otherLine.p2.x;
    const y4 = otherLine.p2.y;
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denominator === 0) {
      return void 0;
    }
    const numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    const numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    if (numeratorA === 0 && numeratorB === 0) {
      return void 0;
    }
    const determinantA = numeratorA / denominator;
    const determinantB = numeratorB / denominator;
    if (determinantA < 0 || determinantA > 1 || determinantB < 0 || determinantB > 1) {
      return void 0;
    }
    const x = x1 + determinantA * (x2 - x1);
    const y = y1 + determinantA * (y2 - y1);
    return {
      x,
      y
    };
  }
  /**
   * @param otherLine the other line
   * @returns whether the start and end point of this line is does not have distinct start
   * or end points with the `otherLine`
   */
  hasIndistinctPoints(otherLine) {
    return sprotty_protocol_1$3.Point.equals(this.p1, otherLine.p1) || sprotty_protocol_1$3.Point.equals(this.p1, otherLine.p2) || sprotty_protocol_1$3.Point.equals(this.p2, otherLine.p1) || sprotty_protocol_1$3.Point.equals(this.p2, otherLine.p2);
  }
}
geometry.PointToPointLine = PointToPointLine;
function intersection(l1, l2) {
  return {
    x: (l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b),
    y: (l1.a * l2.c - l2.a * l1.c) / (l1.a * l2.b - l2.a * l1.b)
  };
}
geometry.intersection = intersection;
function limit(value, limits) {
  if (value < limits.min) {
    return limits.min;
  }
  if (value > limits.max) {
    return limits.max;
  }
  return value;
}
geometry.limit = limit;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.limitViewport = exports.isViewport = exports.viewportFeature = void 0;
  const sprotty_protocol_12 = lib;
  const smodel_12 = smodel;
  const geometry_12 = geometry;
  exports.viewportFeature = Symbol("viewportFeature");
  function isViewport(element) {
    return element instanceof smodel_12.SModelRootImpl && element.hasFeature(exports.viewportFeature) && "zoom" in element && "scroll" in element;
  }
  exports.isViewport = isViewport;
  function limitViewport(viewport2, canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits) {
    if (canvasBounds && !sprotty_protocol_12.Dimension.isValid(canvasBounds)) {
      canvasBounds = void 0;
    }
    let zoom2 = zoomLimits ? (0, geometry_12.limit)(viewport2.zoom, zoomLimits) : viewport2.zoom;
    if (canvasBounds && horizontalScrollLimits) {
      const minZoom = canvasBounds.width / (horizontalScrollLimits.max - horizontalScrollLimits.min);
      if (zoom2 < minZoom) {
        zoom2 = minZoom;
      }
    }
    if (canvasBounds && verticalScrollLimits) {
      const minZoom = canvasBounds.height / (verticalScrollLimits.max - verticalScrollLimits.min);
      if (zoom2 < minZoom) {
        zoom2 = minZoom;
      }
    }
    let scrollX;
    if (horizontalScrollLimits) {
      const min = horizontalScrollLimits.min;
      const max = canvasBounds ? horizontalScrollLimits.max - canvasBounds.width / zoom2 : horizontalScrollLimits.max;
      scrollX = (0, geometry_12.limit)(viewport2.scroll.x, {
        min,
        max
      });
    } else {
      scrollX = viewport2.scroll.x;
    }
    let scrollY;
    if (verticalScrollLimits) {
      const min = verticalScrollLimits.min;
      const max = canvasBounds ? verticalScrollLimits.max - canvasBounds.height / zoom2 : verticalScrollLimits.max;
      scrollY = (0, geometry_12.limit)(viewport2.scroll.y, {
        min,
        max
      });
    } else {
      scrollY = viewport2.scroll.y;
    }
    return {
      scroll: {
        x: scrollX,
        y: scrollY
      },
      zoom: zoom2
    };
  }
  exports.limitViewport = limitViewport;
})(model$6);
var model$5 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isExportable = exports.exportFeature = void 0;
  exports.exportFeature = Symbol("exportFeature");
  function isExportable(element) {
    return element.hasFeature(exports.exportFeature);
  }
  exports.isExportable = isExportable;
})(model$5);
Object.defineProperty(viewportRoot, "__esModule", {
  value: true
});
viewportRoot.ViewportRootElementImpl = void 0;
const geometry_1$l = geometry$1;
const smodel_1$h = smodel;
const model_1$A = model$6;
const model_2$g = model$5;
class ViewportRootElementImpl extends smodel_1$h.SModelRootImpl {
  constructor(index) {
    super(index);
    this.scroll = {
      x: 0,
      y: 0
    };
    this.zoom = 1;
    this.position = geometry_1$l.Point.ORIGIN;
    this.size = geometry_1$l.Dimension.EMPTY;
  }
  get bounds() {
    return {
      x: this.position.x,
      y: this.position.y,
      width: this.size.width,
      height: this.size.height
    };
  }
  set bounds(newBounds) {
    this.position = {
      x: newBounds.x,
      y: newBounds.y
    };
    this.size = {
      width: newBounds.width,
      height: newBounds.height
    };
  }
  localToParent(point) {
    const result = {
      x: (point.x - this.scroll.x) * this.zoom,
      y: (point.y - this.scroll.y) * this.zoom,
      width: -1,
      height: -1
    };
    if ((0, geometry_1$l.isBounds)(point)) {
      result.width = point.width * this.zoom;
      result.height = point.height * this.zoom;
    }
    return result;
  }
  parentToLocal(point) {
    const result = {
      x: point.x / this.zoom + this.scroll.x,
      y: point.y / this.zoom + this.scroll.y,
      width: -1,
      height: -1
    };
    if ((0, geometry_1$l.isBounds)(point) && geometry_1$l.Dimension.isValid(point)) {
      result.width = point.width / this.zoom;
      result.height = point.height / this.zoom;
    }
    return result;
  }
}
viewportRoot.ViewportRootElementImpl = ViewportRootElementImpl;
ViewportRootElementImpl.DEFAULT_FEATURES = [model_1$A.viewportFeature, model_2$g.exportFeature];
Object.defineProperty(sgraph, "__esModule", {
  value: true
});
sgraph.SGraphIndex = sgraph.SCompartmentImpl = sgraph.SLabelImpl = sgraph.SEdgeImpl = sgraph.SPortImpl = sgraph.SNodeImpl = sgraph.SGraphImpl = void 0;
const geometry_1$k = geometry$1;
const smodel_1$g = smodel;
const model_1$z = model$g;
const model_2$f = model$b;
const delete_1$1 = _delete;
const model_3$8 = model$7;
const model_4$5 = model$e;
const model_5$2 = model$9;
const model_6$2 = model$8;
const model_7 = model$a;
const model_8 = model$c;
const viewport_root_1$1 = viewportRoot;
const iterable_1$2 = iterable;
class SGraphImpl extends viewport_root_1$1.ViewportRootElementImpl {
  constructor(index = new SGraphIndex()) {
    super(index);
  }
}
sgraph.SGraphImpl = SGraphImpl;
class SNodeImpl extends model_7.SConnectableElementImpl {
  constructor() {
    super(...arguments);
    this.selected = false;
    this.hoverFeedback = false;
    this.opacity = 1;
  }
  canConnect(routable, role) {
    return this.children.find((c) => c instanceof SPortImpl) === void 0;
  }
  get incomingEdges() {
    const index = this.index;
    if (index instanceof SGraphIndex) {
      return index.getIncomingEdges(this);
    }
    const allEdges = this.index.all().filter((e) => e instanceof SEdgeImpl);
    return allEdges.filter((e) => e.targetId === this.id);
  }
  get outgoingEdges() {
    const index = this.index;
    if (index instanceof SGraphIndex) {
      return index.getOutgoingEdges(this);
    }
    const allEdges = this.index.all().filter((e) => e instanceof SEdgeImpl);
    return allEdges.filter((e) => e.sourceId === this.id);
  }
}
sgraph.SNodeImpl = SNodeImpl;
SNodeImpl.DEFAULT_FEATURES = [model_7.connectableFeature, delete_1$1.deletableFeature, model_8.selectFeature, model_1$z.boundsFeature, model_6$2.moveFeature, model_1$z.layoutContainerFeature, model_4$5.fadeFeature, model_5$2.hoverFeedbackFeature, model_5$2.popupFeature];
class SPortImpl extends model_7.SConnectableElementImpl {
  constructor() {
    super(...arguments);
    this.selected = false;
    this.hoverFeedback = false;
    this.opacity = 1;
  }
  get incomingEdges() {
    const index = this.index;
    if (index instanceof SGraphIndex) {
      return index.getIncomingEdges(this);
    }
    return super.incomingEdges.filter((e) => e instanceof SEdgeImpl);
  }
  get outgoingEdges() {
    const index = this.index;
    if (index instanceof SGraphIndex) {
      return index.getOutgoingEdges(this);
    }
    return super.outgoingEdges.filter((e) => e instanceof SEdgeImpl);
  }
}
sgraph.SPortImpl = SPortImpl;
SPortImpl.DEFAULT_FEATURES = [model_7.connectableFeature, model_8.selectFeature, model_1$z.boundsFeature, model_4$5.fadeFeature, model_5$2.hoverFeedbackFeature];
class SEdgeImpl extends model_7.SRoutableElementImpl {
  constructor() {
    super(...arguments);
    this.selected = false;
    this.hoverFeedback = false;
    this.opacity = 1;
  }
}
sgraph.SEdgeImpl = SEdgeImpl;
SEdgeImpl.DEFAULT_FEATURES = [model_3$8.editFeature, delete_1$1.deletableFeature, model_8.selectFeature, model_4$5.fadeFeature, model_5$2.hoverFeedbackFeature];
class SLabelImpl extends model_1$z.SShapeElementImpl {
  constructor() {
    super(...arguments);
    this.selected = false;
    this.alignment = geometry_1$k.Point.ORIGIN;
    this.opacity = 1;
  }
}
sgraph.SLabelImpl = SLabelImpl;
SLabelImpl.DEFAULT_FEATURES = [model_1$z.boundsFeature, model_1$z.alignFeature, model_1$z.layoutableChildFeature, model_2$f.edgeLayoutFeature, model_4$5.fadeFeature];
class SCompartmentImpl extends model_1$z.SShapeElementImpl {
  constructor() {
    super(...arguments);
    this.opacity = 1;
  }
}
sgraph.SCompartmentImpl = SCompartmentImpl;
SCompartmentImpl.DEFAULT_FEATURES = [model_1$z.boundsFeature, model_1$z.layoutContainerFeature, model_1$z.layoutableChildFeature, model_4$5.fadeFeature];
class SGraphIndex extends smodel_1$g.ModelIndexImpl {
  constructor() {
    super(...arguments);
    this.outgoing = /* @__PURE__ */ new Map();
    this.incoming = /* @__PURE__ */ new Map();
  }
  add(element) {
    super.add(element);
    if (element instanceof SEdgeImpl) {
      if (element.sourceId) {
        const sourceArr = this.outgoing.get(element.sourceId);
        if (sourceArr === void 0)
          this.outgoing.set(element.sourceId, [element]);
        else
          sourceArr.push(element);
      }
      if (element.targetId) {
        const targetArr = this.incoming.get(element.targetId);
        if (targetArr === void 0)
          this.incoming.set(element.targetId, [element]);
        else
          targetArr.push(element);
      }
    }
  }
  remove(element) {
    super.remove(element);
    if (element instanceof SEdgeImpl) {
      const sourceArr = this.outgoing.get(element.sourceId);
      if (sourceArr !== void 0) {
        const index = sourceArr.indexOf(element);
        if (index >= 0) {
          if (sourceArr.length === 1)
            this.outgoing.delete(element.sourceId);
          else
            sourceArr.splice(index, 1);
        }
      }
      const targetArr = this.incoming.get(element.targetId);
      if (targetArr !== void 0) {
        const index = targetArr.indexOf(element);
        if (index >= 0) {
          if (targetArr.length === 1)
            this.incoming.delete(element.targetId);
          else
            targetArr.splice(index, 1);
        }
      }
    }
  }
  getAttachedElements(element) {
    return new iterable_1$2.FluentIterableImpl(() => ({
      outgoing: this.outgoing.get(element.id),
      incoming: this.incoming.get(element.id),
      nextOutgoingIndex: 0,
      nextIncomingIndex: 0
    }), (state) => {
      let index = state.nextOutgoingIndex;
      if (state.outgoing !== void 0 && index < state.outgoing.length) {
        state.nextOutgoingIndex = index + 1;
        return {
          done: false,
          value: state.outgoing[index]
        };
      }
      index = state.nextIncomingIndex;
      if (state.incoming !== void 0) {
        while (index < state.incoming.length) {
          const edge = state.incoming[index];
          if (edge.sourceId !== edge.targetId) {
            state.nextIncomingIndex = index + 1;
            return {
              done: false,
              value: edge
            };
          }
          index++;
        }
      }
      return {
        done: true,
        value: void 0
      };
    });
  }
  getIncomingEdges(element) {
    return this.incoming.get(element.id) || [];
  }
  getOutgoingEdges(element) {
    return this.outgoing.get(element.id) || [];
  }
}
sgraph.SGraphIndex = SGraphIndex;
var routing = {};
var polylineEdgeRouter = {};
var anchor = {};
(function(exports) {
  var __decorate2 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata2 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var __param2 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnchorComputerRegistry = exports.RECTANGULAR_ANCHOR_KIND = exports.ELLIPTIC_ANCHOR_KIND = exports.DIAMOND_ANCHOR_KIND = void 0;
  const inversify_12 = require$$0$1;
  const types_12 = types;
  const registry_12 = registry;
  exports.DIAMOND_ANCHOR_KIND = "diamond";
  exports.ELLIPTIC_ANCHOR_KIND = "elliptic";
  exports.RECTANGULAR_ANCHOR_KIND = "rectangular";
  let AnchorComputerRegistry = class AnchorComputerRegistry extends registry_12.InstanceRegistry {
    constructor(anchors) {
      super();
      anchors.forEach((anchor2) => this.register(anchor2.kind, anchor2));
    }
    get defaultAnchorKind() {
      return exports.RECTANGULAR_ANCHOR_KIND;
    }
    get(routerKind, anchorKind) {
      return super.get(`${routerKind}:${anchorKind || this.defaultAnchorKind}`);
    }
  };
  exports.AnchorComputerRegistry = AnchorComputerRegistry;
  exports.AnchorComputerRegistry = AnchorComputerRegistry = __decorate2([(0, inversify_12.injectable)(), __param2(0, (0, inversify_12.multiInject)(types_12.TYPES.IAnchorComputer)), __metadata2("design:paramtypes", [Array])], AnchorComputerRegistry);
})(anchor);
var abstractEdgeRouter = {};
var __decorate$K = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$u = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(abstractEdgeRouter, "__esModule", {
  value: true
});
abstractEdgeRouter.AbstractEdgeRouter = abstractEdgeRouter.DefaultAnchors = abstractEdgeRouter.Side = void 0;
const inversify_1$14 = require$$0$1;
const geometry_1$j = geometry$1;
const smodel_utils_1$b = smodelUtils;
const model_1$y = model$a;
const anchor_1$6 = anchor;
const model_2$e = model$a;
var Side;
(function(Side2) {
  Side2[Side2["RIGHT"] = 0] = "RIGHT";
  Side2[Side2["LEFT"] = 1] = "LEFT";
  Side2[Side2["TOP"] = 2] = "TOP";
  Side2[Side2["BOTTOM"] = 3] = "BOTTOM";
})(Side || (abstractEdgeRouter.Side = Side = {}));
class DefaultAnchors {
  constructor(element, edgeParent, kind) {
    this.element = element;
    this.kind = kind;
    const bounds = element.bounds;
    this.bounds = (0, smodel_utils_1$b.translateBounds)(bounds, element.parent, edgeParent);
    this.left = {
      x: this.bounds.x,
      y: this.bounds.y + 0.5 * this.bounds.height,
      kind
    };
    this.right = {
      x: this.bounds.x + this.bounds.width,
      y: this.bounds.y + 0.5 * this.bounds.height,
      kind
    };
    this.top = {
      x: this.bounds.x + 0.5 * this.bounds.width,
      y: this.bounds.y,
      kind
    };
    this.bottom = {
      x: this.bounds.x + 0.5 * this.bounds.width,
      y: this.bounds.y + this.bounds.height,
      kind
    };
  }
  get(side) {
    return this[Side[side].toLowerCase()];
  }
  getNearestSide(point) {
    const leftDistance = geometry_1$j.Point.euclideanDistance(point, this.left);
    const rightDistance = geometry_1$j.Point.euclideanDistance(point, this.right);
    const topDistance = geometry_1$j.Point.euclideanDistance(point, this.top);
    const bottomDistance = geometry_1$j.Point.euclideanDistance(point, this.bottom);
    let currentNearestSide = Side.LEFT;
    let currentMinDist = leftDistance;
    if (rightDistance < currentMinDist) {
      currentMinDist = rightDistance;
      currentNearestSide = Side.RIGHT;
    }
    if (topDistance < currentMinDist) {
      currentMinDist = topDistance;
      currentNearestSide = Side.TOP;
    }
    if (bottomDistance < currentMinDist) {
      currentMinDist = bottomDistance;
      currentNearestSide = Side.BOTTOM;
    }
    return currentNearestSide;
  }
}
abstractEdgeRouter.DefaultAnchors = DefaultAnchors;
let AbstractEdgeRouter = class AbstractEdgeRouter2 {
  findOrthogonalIntersection(edge, point) {
    const calcOrthogonalIntersectionForSegment = (p1, p2) => {
      const d = geometry_1$j.Point.subtract(p2, p1);
      const pq = geometry_1$j.Point.subtract(point, p1);
      const t = geometry_1$j.Point.dotProduct(pq, d) / geometry_1$j.Point.dotProduct(d, d);
      if (t >= 0 && t <= 1) {
        return geometry_1$j.Point.linear(p1, p2, t);
      } else if (t < 0) {
        return p1;
      } else {
        return p2;
      }
    };
    const routedPoints = this.route(edge);
    let intersectionPoint = routedPoints[0];
    let index = 0;
    for (let i = 0; i < routedPoints.length - 1; ++i) {
      const intersection2 = calcOrthogonalIntersectionForSegment(routedPoints[i], routedPoints[i + 1]);
      if (geometry_1$j.Point.euclideanDistance(point, intersection2) < geometry_1$j.Point.euclideanDistance(point, intersectionPoint)) {
        intersectionPoint = intersection2;
        index = i;
      }
    }
    const derivative = geometry_1$j.Point.subtract(routedPoints[index + 1], routedPoints[index]);
    return {
      point: intersectionPoint,
      derivative
    };
  }
  pointAt(edge, t) {
    const segments = this.calculateSegment(edge, t);
    if (!segments)
      return void 0;
    const {
      segmentStart,
      segmentEnd,
      lambda
    } = segments;
    return geometry_1$j.Point.linear(segmentStart, segmentEnd, lambda);
  }
  derivativeAt(edge, t) {
    const segments = this.calculateSegment(edge, t);
    if (!segments)
      return void 0;
    const {
      segmentStart,
      segmentEnd
    } = segments;
    return {
      x: segmentEnd.x - segmentStart.x,
      y: segmentEnd.y - segmentStart.y
    };
  }
  calculateSegment(edge, t) {
    if (t < 0 || t > 1)
      return void 0;
    const routedPoints = this.route(edge);
    if (routedPoints.length < 2)
      return void 0;
    const segmentLengths = [];
    let totalLength = 0;
    for (let i = 0; i < routedPoints.length - 1; ++i) {
      segmentLengths[i] = geometry_1$j.Point.euclideanDistance(routedPoints[i], routedPoints[i + 1]);
      totalLength += segmentLengths[i];
    }
    let currentLenght = 0;
    const tAsLenght = t * totalLength;
    for (let i = 0; i < routedPoints.length - 1; ++i) {
      const newLength = currentLenght + segmentLengths[i];
      if (segmentLengths[i] > 1e-8) {
        if (newLength >= tAsLenght) {
          const lambda = Math.max(0, tAsLenght - currentLenght) / segmentLengths[i];
          return {
            segmentStart: routedPoints[i],
            segmentEnd: routedPoints[i + 1],
            lambda
          };
        }
      }
      currentLenght = newLength;
    }
    return {
      segmentEnd: routedPoints.pop(),
      segmentStart: routedPoints.pop(),
      lambda: 1
    };
  }
  addHandle(edge, kind, type, routingPointIndex) {
    const handle = new model_1$y.SRoutingHandleImpl();
    handle.kind = kind;
    handle.pointIndex = routingPointIndex;
    handle.type = type;
    if (kind === "target" && edge.id === model_1$y.edgeInProgressID)
      handle.id = model_1$y.edgeInProgressTargetHandleID;
    edge.add(handle);
    return handle;
  }
  getHandlePosition(edge, route, handle) {
    switch (handle.kind) {
      case "source":
        if (edge.source instanceof model_1$y.SDanglingAnchorImpl)
          return edge.source.position;
        else
          return route[0];
      case "target":
        if (edge.target instanceof model_1$y.SDanglingAnchorImpl)
          return edge.target.position;
        else {
          return route[route.length - 1];
        }
      default:
        const position = this.getInnerHandlePosition(edge, route, handle);
        if (position !== void 0)
          return position;
        if (handle.pointIndex >= 0 && handle.pointIndex < edge.routingPoints.length)
          return edge.routingPoints[handle.pointIndex];
    }
    return void 0;
  }
  findRouteSegment(edge, route, handleIndex) {
    const getIndex = (rp) => {
      if (rp.pointIndex !== void 0)
        return rp.pointIndex;
      else if (rp.kind === "target")
        return edge.routingPoints.length;
      else
        return -2;
    };
    let start, end;
    for (const rp of route) {
      const i = getIndex(rp);
      if (i <= handleIndex && (start === void 0 || i > getIndex(start)))
        start = rp;
      if (i > handleIndex && (end === void 0 || i < getIndex(end)))
        end = rp;
    }
    return {
      start,
      end
    };
  }
  getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection = 0) {
    const translatedRefPoint = (0, smodel_utils_1$b.translatePoint)(refPoint, refContainer, connectable.parent);
    const anchorComputer = this.getAnchorComputer(connectable);
    const strokeCorrection = 0.5 * connectable.strokeWidth;
    const anchor2 = anchorComputer.getAnchor(connectable, translatedRefPoint, anchorCorrection + strokeCorrection);
    return (0, smodel_utils_1$b.translatePoint)(anchor2, connectable.parent, edge.parent);
  }
  getAnchorComputer(connectable) {
    return this.anchorRegistry.get(this.kind, connectable.anchorKind);
  }
  applyHandleMoves(edge, moves) {
    const remainingMoves = moves.slice();
    moves.forEach((move2) => {
      const handle = move2.handle;
      if (handle.kind === "source" && !(edge.source instanceof model_1$y.SDanglingAnchorImpl)) {
        const anchor2 = new model_1$y.SDanglingAnchorImpl();
        anchor2.id = edge.id + "_dangling-source";
        anchor2.original = edge.source;
        anchor2.position = move2.toPosition;
        handle.root.add(anchor2);
        handle.danglingAnchor = anchor2;
        edge.sourceId = anchor2.id;
      } else if (handle.kind === "target" && !(edge.target instanceof model_1$y.SDanglingAnchorImpl)) {
        const anchor2 = new model_1$y.SDanglingAnchorImpl();
        anchor2.id = edge.id + "_dangling-target";
        anchor2.original = edge.target;
        anchor2.position = move2.toPosition;
        handle.root.add(anchor2);
        handle.danglingAnchor = anchor2;
        edge.targetId = anchor2.id;
      }
      if (handle.danglingAnchor) {
        handle.danglingAnchor.position = move2.toPosition;
        remainingMoves.splice(remainingMoves.indexOf(move2), 1);
      }
    });
    if (remainingMoves.length > 0)
      this.applyInnerHandleMoves(edge, remainingMoves);
    this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
  }
  cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
    const sourceAnchors = new DefaultAnchors(edge.source, edge.parent, "source");
    const targetAnchors = new DefaultAnchors(edge.target, edge.parent, "target");
    this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors);
  }
  resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors) {
    if (routingPoints.length === 0 || edge.source instanceof model_1$y.SDanglingAnchorImpl || edge.target instanceof model_1$y.SDanglingAnchorImpl) {
      const options = this.getOptions(edge);
      const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
      routingPoints.splice(0, routingPoints.length, ...corners);
      if (updateHandles) {
        let maxPointIndex = -2;
        edge.children.forEach((child) => {
          if (child instanceof model_1$y.SRoutingHandleImpl) {
            if (child.kind === "target")
              child.pointIndex = routingPoints.length;
            else if (child.kind === "line" && child.pointIndex >= routingPoints.length)
              edge.remove(child);
            else
              maxPointIndex = Math.max(child.pointIndex, maxPointIndex);
          }
        });
        for (let i = maxPointIndex; i < routingPoints.length - 1; ++i)
          this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i);
      }
      return true;
    }
    return false;
  }
  applyReconnect(edge, newSourceId, newTargetId) {
    let hasChanged2 = false;
    if (newSourceId) {
      const newSource = edge.root.index.getById(newSourceId);
      if (newSource instanceof model_2$e.SConnectableElementImpl) {
        edge.sourceId = newSource.id;
        hasChanged2 = true;
      }
    }
    if (newTargetId) {
      const newTarget = edge.root.index.getById(newTargetId);
      if (newTarget instanceof model_2$e.SConnectableElementImpl) {
        edge.targetId = newTarget.id;
        hasChanged2 = true;
      }
    }
    if (hasChanged2) {
      edge.index.remove(edge);
      if (edge.id === model_1$y.edgeInProgressID) {
        const idGen = (counter) => `${edge.sourceId}_to_${edge.targetId}_${counter}`;
        let idx = 0;
        let newId = idGen(idx);
        while (edge.index.getById(newId) !== void 0) {
          newId = idGen(++idx);
        }
        edge.id = newId;
        const progressTargetHandle = edge.children.find((child) => child.id === model_1$y.edgeInProgressTargetHandleID);
        if (progressTargetHandle instanceof model_1$y.SRoutingHandleImpl) {
          edge.remove(progressTargetHandle);
          if (progressTargetHandle.danglingAnchor) {
            progressTargetHandle.danglingAnchor.parent.remove(progressTargetHandle.danglingAnchor);
          }
        }
      }
      edge.index.add(edge);
      if (this.getSelfEdgeIndex(edge) > -1) {
        edge.routingPoints = [];
        this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
      }
    }
  }
  takeSnapshot(edge) {
    return {
      routingPoints: edge.routingPoints.slice(),
      routingHandles: edge.children.filter((child) => child instanceof model_1$y.SRoutingHandleImpl).map((child) => child),
      routedPoints: this.route(edge),
      router: this,
      source: edge.source,
      target: edge.target
    };
  }
  applySnapshot(edge, snapshot) {
    edge.routingPoints = snapshot.routingPoints;
    edge.removeAll((child) => child instanceof model_1$y.SRoutingHandleImpl);
    edge.routerKind = snapshot.router.kind;
    snapshot.routingHandles.forEach((handle) => edge.add(handle));
    if (snapshot.source)
      edge.sourceId = snapshot.source.id;
    if (snapshot.target)
      edge.targetId = snapshot.target.id;
    edge.root.index.remove(edge);
    edge.root.index.add(edge);
  }
  calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
    const selfEdgeIndex = this.getSelfEdgeIndex(edge);
    if (selfEdgeIndex >= 0) {
      const standardDist = options.standardDistance;
      const delta = options.selfEdgeOffset * Math.min(sourceAnchors.bounds.width, sourceAnchors.bounds.height);
      switch (selfEdgeIndex % 4) {
        case 0:
          return [{
            x: sourceAnchors.get(Side.RIGHT).x + standardDist,
            y: sourceAnchors.get(Side.RIGHT).y + delta
          }, {
            x: sourceAnchors.get(Side.RIGHT).x + standardDist,
            y: sourceAnchors.get(Side.BOTTOM).y + standardDist
          }, {
            x: sourceAnchors.get(Side.BOTTOM).x + delta,
            y: sourceAnchors.get(Side.BOTTOM).y + standardDist
          }];
        case 1:
          return [{
            x: sourceAnchors.get(Side.BOTTOM).x - delta,
            y: sourceAnchors.get(Side.BOTTOM).y + standardDist
          }, {
            x: sourceAnchors.get(Side.LEFT).x - standardDist,
            y: sourceAnchors.get(Side.BOTTOM).y + standardDist
          }, {
            x: sourceAnchors.get(Side.LEFT).x - standardDist,
            y: sourceAnchors.get(Side.LEFT).y + delta
          }];
        case 2:
          return [{
            x: sourceAnchors.get(Side.LEFT).x - standardDist,
            y: sourceAnchors.get(Side.LEFT).y - delta
          }, {
            x: sourceAnchors.get(Side.LEFT).x - standardDist,
            y: sourceAnchors.get(Side.TOP).y - standardDist
          }, {
            x: sourceAnchors.get(Side.TOP).x - delta,
            y: sourceAnchors.get(Side.TOP).y - standardDist
          }];
        case 3:
          return [{
            x: sourceAnchors.get(Side.TOP).x + delta,
            y: sourceAnchors.get(Side.TOP).y - standardDist
          }, {
            x: sourceAnchors.get(Side.RIGHT).x + standardDist,
            y: sourceAnchors.get(Side.TOP).y - standardDist
          }, {
            x: sourceAnchors.get(Side.RIGHT).x + standardDist,
            y: sourceAnchors.get(Side.RIGHT).y - delta
          }];
      }
    }
    return [];
  }
  getSelfEdgeIndex(edge) {
    if (!edge.source || edge.source !== edge.target)
      return -1;
    return edge.source.outgoingEdges.filter((otherEdge) => otherEdge.target === edge.source).indexOf(edge);
  }
  commitRoute(edge, routedPoints) {
    const newRoutingPoints = [];
    for (let i = 1; i < routedPoints.length - 1; ++i)
      newRoutingPoints.push({
        x: routedPoints[i].x,
        y: routedPoints[i].y
      });
    edge.routingPoints = newRoutingPoints;
  }
};
abstractEdgeRouter.AbstractEdgeRouter = AbstractEdgeRouter;
__decorate$K([(0, inversify_1$14.inject)(anchor_1$6.AnchorComputerRegistry), __metadata$u("design:type", anchor_1$6.AnchorComputerRegistry)], AbstractEdgeRouter.prototype, "anchorRegistry", void 0);
abstractEdgeRouter.AbstractEdgeRouter = AbstractEdgeRouter = __decorate$K([(0, inversify_1$14.injectable)()], AbstractEdgeRouter);
var __decorate$J = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$t = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var PolylineEdgeRouter_1;
Object.defineProperty(polylineEdgeRouter, "__esModule", {
  value: true
});
polylineEdgeRouter.PolylineEdgeRouter = void 0;
const inversify_1$13 = require$$0$1;
const geometry_1$i = geometry$1;
const model_1$x = model$a;
const anchor_1$5 = anchor;
const abstract_edge_router_1$2 = abstractEdgeRouter;
let PolylineEdgeRouter = PolylineEdgeRouter_1 = class PolylineEdgeRouter2 extends abstract_edge_router_1$2.AbstractEdgeRouter {
  get kind() {
    return PolylineEdgeRouter_1.KIND;
  }
  getOptions(edge) {
    return {
      minimalPointDistance: 2,
      removeAngleThreshold: 0.1,
      standardDistance: 20,
      selfEdgeOffset: 0.25
    };
  }
  route(edge) {
    const source = edge.source;
    const target = edge.target;
    if (source === void 0 || target === void 0) {
      return [];
    }
    let sourceAnchor;
    let targetAnchor;
    const options = this.getOptions(edge);
    const routingPoints = edge.routingPoints.length > 0 ? edge.routingPoints : [];
    this.cleanupRoutingPoints(edge, routingPoints, false, false);
    const rpCount = routingPoints !== void 0 ? routingPoints.length : 0;
    if (rpCount === 0) {
      const startRef = geometry_1$i.Bounds.center(target.bounds);
      sourceAnchor = this.getTranslatedAnchor(source, startRef, target.parent, edge, edge.sourceAnchorCorrection);
      const endRef = geometry_1$i.Bounds.center(source.bounds);
      targetAnchor = this.getTranslatedAnchor(target, endRef, source.parent, edge, edge.targetAnchorCorrection);
    } else {
      const p0 = routingPoints[0];
      sourceAnchor = this.getTranslatedAnchor(source, p0, edge.parent, edge, edge.sourceAnchorCorrection);
      const pn = routingPoints[rpCount - 1];
      targetAnchor = this.getTranslatedAnchor(target, pn, edge.parent, edge, edge.targetAnchorCorrection);
    }
    const result = [];
    result.push({
      kind: "source",
      x: sourceAnchor.x,
      y: sourceAnchor.y
    });
    for (let i = 0; i < rpCount; i++) {
      const p2 = routingPoints[i];
      if (i > 0 && i < rpCount - 1 || i === 0 && geometry_1$i.Point.maxDistance(sourceAnchor, p2) >= options.minimalPointDistance + (edge.sourceAnchorCorrection || 0) || i === rpCount - 1 && geometry_1$i.Point.maxDistance(p2, targetAnchor) >= options.minimalPointDistance + (edge.targetAnchorCorrection || 0)) {
        result.push({
          kind: "linear",
          x: p2.x,
          y: p2.y,
          pointIndex: i
        });
      }
    }
    result.push({
      kind: "target",
      x: targetAnchor.x,
      y: targetAnchor.y
    });
    return this.filterEditModeHandles(result, edge, options);
  }
  /**
   * Remove routed points that are in edit mode and for which the angle between the preceding and
   * following points falls below a threshold.
   */
  filterEditModeHandles(route, edge, options) {
    if (edge.children.length === 0)
      return route;
    let i = 0;
    while (i < route.length) {
      const curr = route[i];
      if (curr.pointIndex !== void 0) {
        const handle = edge.children.find((child) => child instanceof model_1$x.SRoutingHandleImpl && child.kind === "junction" && child.pointIndex === curr.pointIndex);
        if (handle !== void 0 && handle.editMode && i > 0 && i < route.length - 1) {
          const prev = route[i - 1], next = route[i + 1];
          const prevDiff = {
            x: prev.x - curr.x,
            y: prev.y - curr.y
          };
          const nextDiff = {
            x: next.x - curr.x,
            y: next.y - curr.y
          };
          const angle = (0, geometry_1$i.angleBetweenPoints)(prevDiff, nextDiff);
          if (Math.abs(Math.PI - angle) < options.removeAngleThreshold) {
            route.splice(i, 1);
            continue;
          }
        }
      }
      i++;
    }
    return route;
  }
  createRoutingHandles(edge) {
    const rpCount = edge.routingPoints.length;
    this.addHandle(edge, "source", "routing-point", -2);
    this.addHandle(edge, "line", "volatile-routing-point", -1);
    for (let i = 0; i < rpCount; i++) {
      this.addHandle(edge, "junction", "routing-point", i);
      this.addHandle(edge, "line", "volatile-routing-point", i);
    }
    this.addHandle(edge, "target", "routing-point", rpCount);
  }
  getInnerHandlePosition(edge, route, handle) {
    if (handle.kind === "line") {
      const {
        start,
        end
      } = this.findRouteSegment(edge, route, handle.pointIndex);
      if (start !== void 0 && end !== void 0)
        return (0, geometry_1$i.centerOfLine)(start, end);
    }
    return void 0;
  }
  applyInnerHandleMoves(edge, moves) {
    moves.forEach((move2) => {
      const handle = move2.handle;
      const points = edge.routingPoints;
      let index = handle.pointIndex;
      if (handle.kind === "line") {
        handle.kind = "junction";
        handle.type = "routing-point";
        points.splice(index + 1, 0, move2.fromPosition || points[Math.max(index, 0)]);
        edge.children.forEach((child) => {
          if (child instanceof model_1$x.SRoutingHandleImpl && (child === handle || child.pointIndex > index))
            child.pointIndex++;
        });
        this.addHandle(edge, "line", "volatile-routing-point", index);
        index++;
        this.addHandle(edge, "line", "volatile-routing-point", index);
      }
      if (index >= 0 && index < points.length) {
        points[index] = move2.toPosition;
      }
    });
  }
};
polylineEdgeRouter.PolylineEdgeRouter = PolylineEdgeRouter;
PolylineEdgeRouter.KIND = "polyline";
__decorate$J([(0, inversify_1$13.inject)(anchor_1$5.AnchorComputerRegistry), __metadata$t("design:type", anchor_1$5.AnchorComputerRegistry)], PolylineEdgeRouter.prototype, "anchorRegistry", void 0);
polylineEdgeRouter.PolylineEdgeRouter = PolylineEdgeRouter = PolylineEdgeRouter_1 = __decorate$J([(0, inversify_1$13.injectable)()], PolylineEdgeRouter);
var __decorate$I = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$s = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$e = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(routing, "__esModule", {
  value: true
});
routing.EdgeRouting = routing.EdgeRouterRegistry = void 0;
const inversify_1$12 = require$$0$1;
const smodel_1$f = smodel;
const types_1$I = types;
const view_1$2 = view;
const registry_1 = registry;
const model_1$w = model$a;
const polyline_edge_router_1$2 = polylineEdgeRouter;
function isMultipleEdgesRouter(router) {
  return router.routeAll !== void 0;
}
let EdgeRouterRegistry = class EdgeRouterRegistry2 extends registry_1.InstanceRegistry {
  constructor(edgeRouters) {
    super();
    edgeRouters.forEach((router) => this.register(router.kind, router));
  }
  get defaultKind() {
    return polyline_edge_router_1$2.PolylineEdgeRouter.KIND;
  }
  get(kind) {
    return super.get(kind || this.defaultKind);
  }
  /**
   * Computes the routes of all edges contained by the specified `parent`.
   * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
   * @param parent the parent to traverse for edges
   * @returns the routes of all edges that are children of `parent`
   */
  routeAllChildren(parent) {
    const routing2 = this.doRouteAllChildren(parent);
    for (const postProcessor of this.postProcessors) {
      postProcessor.apply(routing2, parent);
    }
    return routing2;
  }
  /**
   * Recursively traverses the children of `parent`, collects children grouped by router kind,
   * and then routes them either.
   * @param parent the parent to traverse for edges
   * @returns the routes of all edges that are children of `parent`
   */
  doRouteAllChildren(parent) {
    const routing2 = new EdgeRouting();
    const routersEdges = /* @__PURE__ */ new Map();
    const elementsToProcess = [parent];
    while (elementsToProcess.length > 0) {
      const element = elementsToProcess.shift();
      for (const child of element.children) {
        if (child instanceof model_1$w.SRoutableElementImpl) {
          const routerKind = child.routerKind || this.defaultKind;
          if (routersEdges.has(routerKind)) {
            routersEdges.get(routerKind).push(child);
          } else {
            routersEdges.set(routerKind, [child]);
          }
        }
        if (child instanceof smodel_1$f.SParentElementImpl) {
          elementsToProcess.push(child);
        }
      }
    }
    routersEdges.forEach((edges, routerKind) => {
      const childRouter = this.get(routerKind);
      if (isMultipleEdgesRouter(childRouter)) {
        routing2.setAll(childRouter.routeAll(edges, parent));
      } else {
        for (const edge of edges) {
          routing2.set(edge.id, this.route(edge));
        }
      }
    });
    return routing2;
  }
  /**
   * Computes or obtains the route of a single edge.
   * @param edge the edge to be routed
   * @param args arguments that may contain an `EdgeRouting` already
   * @returns the route of the specified `edge`
   */
  route(edge, args) {
    const edgeRouting = (0, view_1$2.findArgValue)(args, "edgeRouting");
    if (edgeRouting) {
      const route = edgeRouting.get(edge.id);
      if (route) {
        return route;
      }
    }
    const router = this.get(edge.routerKind);
    return router.route(edge);
  }
};
routing.EdgeRouterRegistry = EdgeRouterRegistry;
__decorate$I([(0, inversify_1$12.multiInject)(types_1$I.TYPES.IEdgeRoutePostprocessor), (0, inversify_1$12.optional)(), __metadata$s("design:type", Array)], EdgeRouterRegistry.prototype, "postProcessors", void 0);
routing.EdgeRouterRegistry = EdgeRouterRegistry = __decorate$I([(0, inversify_1$12.injectable)(), __param$e(0, (0, inversify_1$12.multiInject)(types_1$I.TYPES.IEdgeRouter)), __metadata$s("design:paramtypes", [Array])], EdgeRouterRegistry);
class EdgeRouting {
  constructor() {
    this.routesMap = /* @__PURE__ */ new Map();
  }
  set(routableId, route) {
    this.routesMap.set(routableId, route);
  }
  setAll(otherRoutes) {
    otherRoutes.routes.forEach((route, routableId) => this.set(routableId, route));
  }
  get(routableId) {
    return this.routesMap.get(routableId);
  }
  get routes() {
    return this.routesMap;
  }
}
routing.EdgeRouting = EdgeRouting;
var __decorate$H = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$r = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(edgeLayout, "__esModule", {
  value: true
});
edgeLayout.EdgeLayoutPostprocessor = void 0;
const inversify_1$11 = require$$0$1;
const geometry_1$h = geometry$1;
const smodel_1$e = smodel;
const vnode_utils_1$9 = vnodeUtils;
const sgraph_1$4 = sgraph;
const model_1$v = model$g;
const model_2$d = model$b;
const routing_1$8 = routing;
const types_1$H = types;
let EdgeLayoutPostprocessor = class EdgeLayoutPostprocessor2 {
  /**
   * Decorates the vnode with the appropriate transformation based on the element's placement and bounds.
   * @param vnode - The vnode to decorate.
   * @param element - The SModelElementImpl to decorate.
   * @returns The decorated vnode.
   */
  decorate(vnode2, element) {
    var _a, _b;
    if ((0, model_2$d.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1$4.SEdgeImpl) {
      if (element.bounds !== geometry_1$h.Bounds.EMPTY) {
        const actualBounds = element.bounds;
        const hasOwnPlacement = (0, model_2$d.checkEdgePlacement)(element);
        const placement = this.getEdgePlacement(element);
        const edge = element.parent;
        const position = Math.min(1, Math.max(0, placement.position));
        const router = this.edgeRouterRegistry.get(edge.routerKind);
        const pointOnEdge = router.pointAt(edge, position);
        let transform = "";
        const freeTransform = `translate(${((_a = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.x) !== null && _a !== void 0 ? _a : 0) + actualBounds.x}, ${((_b = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.y) !== null && _b !== void 0 ? _b : 0) + actualBounds.y})`;
        if (hasOwnPlacement) {
          if (pointOnEdge) {
            let derivativeOnEdge;
            if (placement.moveMode && placement.moveMode !== "edge") {
              derivativeOnEdge = router.derivativeAt(edge, position);
              if (placement.moveMode === "free") {
                transform += freeTransform;
              } else {
                transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
              }
            } else {
              const orthogonalPoint = router.findOrthogonalIntersection(edge, geometry_1$h.Point.add(pointOnEdge, actualBounds));
              if (orthogonalPoint) {
                derivativeOnEdge = orthogonalPoint.derivative;
                transform += `translate(${orthogonalPoint.point.x}, ${orthogonalPoint.point.y})`;
              }
            }
            if (derivativeOnEdge) {
              const angle = (0, geometry_1$h.toDegrees)(Math.atan2(derivativeOnEdge.y, derivativeOnEdge.x));
              if (placement.rotate) {
                let flippedAngle = angle;
                if (Math.abs(angle) > 90) {
                  if (angle < 0)
                    flippedAngle += 180;
                  else if (angle > 0)
                    flippedAngle -= 180;
                }
                transform += ` rotate(${flippedAngle})`;
                const alignment = this.getRotatedAlignment(element, placement, flippedAngle !== angle);
                transform += ` translate(${alignment.x}, ${alignment.y})`;
              } else {
                const alignment = this.getAlignment(element, placement, angle);
                transform += ` translate(${alignment.x}, ${alignment.y})`;
              }
            }
          }
        } else {
          transform += freeTransform;
        }
        (0, vnode_utils_1$9.setAttr)(vnode2, "transform", transform);
      }
    }
    return vnode2;
  }
  getRotatedAlignment(element, placement, flip) {
    let x = (0, model_1$v.isAlignable)(element) ? element.alignment.x : 0;
    let y = (0, model_1$v.isAlignable)(element) ? element.alignment.y : 0;
    const bounds = element.bounds;
    if (placement.side === "on")
      return {
        x: x - 0.5 * bounds.height,
        y: y - 0.5 * bounds.height
      };
    if (flip) {
      if (placement.position < 0.3333333)
        x -= bounds.width + placement.offset;
      else if (placement.position < 0.6666666)
        x -= 0.5 * bounds.width;
      else
        x += placement.offset;
      switch (placement.side) {
        case "left":
        case "bottom":
          y -= placement.offset + bounds.height;
          break;
        case "right":
        case "top":
          y += placement.offset;
      }
    } else {
      if (placement.position < 0.3333333)
        x += placement.offset;
      else if (placement.position < 0.6666666)
        x -= 0.5 * bounds.width;
      else
        x -= bounds.width + placement.offset;
      switch (placement.side) {
        case "right":
        case "bottom":
          y += -placement.offset - bounds.height;
          break;
        case "left":
        case "top":
          y += placement.offset;
      }
    }
    return {
      x,
      y
    };
  }
  getEdgePlacement(element) {
    let current = element;
    const allPlacements = [];
    while (current !== void 0) {
      const placement = current.edgePlacement;
      if (placement !== void 0)
        allPlacements.push(placement);
      if (current instanceof smodel_1$e.SChildElementImpl)
        current = current.parent;
      else
        break;
    }
    return allPlacements.reverse().reduce((a, b) => {
      return Object.assign(Object.assign({}, a), b);
    }, model_2$d.DEFAULT_EDGE_PLACEMENT);
  }
  getAlignment(label, placement, angle) {
    const bounds = label.bounds;
    const x = (0, model_1$v.isAlignable)(label) ? label.alignment.x - bounds.width : 0;
    const y = (0, model_1$v.isAlignable)(label) ? label.alignment.y - bounds.height : 0;
    if (placement.side === "on") {
      return {
        x: x + 0.5 * bounds.width,
        y: y + 0.5 * bounds.height
      };
    }
    const quadrant = this.getQuadrant(angle);
    const midLeft = {
      x: placement.offset,
      y: y + 0.5 * bounds.height
    };
    const topLeft = {
      x: placement.offset,
      y: y + bounds.height + placement.offset
    };
    const topRight = {
      x: -bounds.width - placement.offset,
      y: y + bounds.height + placement.offset
    };
    const midRight = {
      x: -bounds.width - placement.offset,
      y: y + 0.5 * bounds.height
    };
    const bottomRight = {
      x: -bounds.width - placement.offset,
      y: y - placement.offset
    };
    const bottomLeft = {
      x: placement.offset,
      y: y - placement.offset
    };
    switch (placement.side) {
      case "left":
        switch (quadrant.orientation) {
          case "west":
            return geometry_1$h.Point.linear(topLeft, topRight, quadrant.position);
          case "north":
            return geometry_1$h.Point.linear(topRight, bottomRight, quadrant.position);
          case "east":
            return geometry_1$h.Point.linear(bottomRight, bottomLeft, quadrant.position);
          case "south":
            return geometry_1$h.Point.linear(bottomLeft, topLeft, quadrant.position);
        }
        break;
      case "right":
        switch (quadrant.orientation) {
          case "west":
            return geometry_1$h.Point.linear(bottomRight, bottomLeft, quadrant.position);
          case "north":
            return geometry_1$h.Point.linear(bottomLeft, topLeft, quadrant.position);
          case "east":
            return geometry_1$h.Point.linear(topLeft, topRight, quadrant.position);
          case "south":
            return geometry_1$h.Point.linear(topRight, bottomRight, quadrant.position);
        }
        break;
      case "top":
        switch (quadrant.orientation) {
          case "west":
            return geometry_1$h.Point.linear(bottomRight, bottomLeft, quadrant.position);
          case "north":
            return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
          case "east":
            return geometry_1$h.Point.linear(bottomRight, bottomLeft, quadrant.position);
          case "south":
            return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
        }
        break;
      case "bottom":
        switch (quadrant.orientation) {
          case "west":
            return geometry_1$h.Point.linear(topLeft, topRight, quadrant.position);
          case "north":
            return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
          case "east":
            return geometry_1$h.Point.linear(topLeft, topRight, quadrant.position);
          case "south":
            return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
        }
        break;
    }
    return {
      x: 0,
      y: 0
    };
  }
  getQuadrant(angle) {
    if (Math.abs(angle) > 135)
      return {
        orientation: "west",
        position: (angle > 0 ? angle - 135 : angle + 225) / 90
      };
    else if (angle < -45)
      return {
        orientation: "north",
        position: (angle + 135) / 90
      };
    else if (angle < 45)
      return {
        orientation: "east",
        position: (angle + 45) / 90
      };
    else
      return {
        orientation: "south",
        position: (angle - 45) / 90
      };
  }
  linearFlip(p0, p1, p2, p3, position) {
    return position < 0.5 ? geometry_1$h.Point.linear(p0, p1, 2 * position) : geometry_1$h.Point.linear(p2, p3, 2 * position - 1);
  }
  postUpdate() {
  }
};
edgeLayout.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor;
__decorate$H([(0, inversify_1$11.inject)(routing_1$8.EdgeRouterRegistry), __metadata$r("design:type", routing_1$8.EdgeRouterRegistry)], EdgeLayoutPostprocessor.prototype, "edgeRouterRegistry", void 0);
__decorate$H([(0, inversify_1$11.inject)(types_1$H.TYPES.ILogger), __metadata$r("design:type", Object)], EdgeLayoutPostprocessor.prototype, "logger", void 0);
edgeLayout.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor = __decorate$H([(0, inversify_1$11.injectable)()], EdgeLayoutPostprocessor);
Object.defineProperty(di_config$l, "__esModule", {
  value: true
});
const inversify_1$10 = require$$0$1;
const types_1$G = types;
const edge_layout_1 = edgeLayout;
const edgeLayoutModule = new inversify_1$10.ContainerModule((bind) => {
  bind(edge_layout_1.EdgeLayoutPostprocessor).toSelf().inSingletonScope();
  bind(types_1$G.TYPES.IVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
  bind(types_1$G.TYPES.HiddenVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
});
di_config$l.default = edgeLayoutModule;
var create = {};
var __decorate$G = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$q = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$d = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(create, "__esModule", {
  value: true
});
create.CreateElementCommand = void 0;
const inversify_1$$ = require$$0$1;
const actions_1$k = actions;
const command_1$e = command;
const smodel_1$d = smodel;
const types_1$F = types;
let CreateElementCommand = class CreateElementCommand2 extends command_1$e.Command {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    const container = context.root.index.getById(this.action.containerId);
    if (container instanceof smodel_1$d.SParentElementImpl) {
      this.container = container;
      this.newElement = context.modelFactory.createElement(this.action.elementSchema);
      this.container.add(this.newElement);
    }
    return context.root;
  }
  undo(context) {
    this.container.remove(this.newElement);
    return context.root;
  }
  redo(context) {
    this.container.add(this.newElement);
    return context.root;
  }
};
create.CreateElementCommand = CreateElementCommand;
CreateElementCommand.KIND = actions_1$k.CreateElementAction.KIND;
create.CreateElementCommand = CreateElementCommand = __decorate$G([(0, inversify_1$$.injectable)(), __param$d(0, (0, inversify_1$$.inject)(types_1$F.TYPES.Action)), __metadata$q("design:paramtypes", [Object])], CreateElementCommand);
var createOnDrag = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isCreatingOnDrag = exports.creatingOnDragFeature = void 0;
  exports.creatingOnDragFeature = Symbol("creatingOnDragFeature");
  function isCreatingOnDrag(element) {
    return element.hasFeature(exports.creatingOnDragFeature) && element.createAction !== void 0;
  }
  exports.isCreatingOnDrag = isCreatingOnDrag;
})(createOnDrag);
var di_config$k = {};
var svgViews = {};
var __decorate$F = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(svgViews, "__esModule", {
  value: true
});
svgViews.EmptyGroupView = svgViews.DiamondNodeView = svgViews.RectangularNodeView = svgViews.CircularNodeView = svgViews.SvgViewportView = void 0;
const jsx_1$6 = jsx;
const sgraph_1$3 = sgraph;
const views_1$3 = views$5;
const geometry_1$g = geometry;
const inversify_1$_ = require$$0$1;
let SvgViewportView = class SvgViewportView2 {
  render(model2, context, args) {
    const transform = `scale(${model2.zoom}) translate(${-model2.scroll.x},${-model2.scroll.y})`;
    return (0, jsx_1$6.svg)("svg", null, (0, jsx_1$6.svg)("g", {
      transform
    }, context.renderChildren(model2)));
  }
};
svgViews.SvgViewportView = SvgViewportView;
svgViews.SvgViewportView = SvgViewportView = __decorate$F([(0, inversify_1$_.injectable)()], SvgViewportView);
let CircularNodeView = class CircularNodeView2 extends views_1$3.ShapeView {
  render(node, context, args) {
    if (!this.isVisible(node, context)) {
      return void 0;
    }
    const radius = this.getRadius(node);
    return (0, jsx_1$6.svg)("g", null, (0, jsx_1$6.svg)("circle", {
      "class-sprotty-node": node instanceof sgraph_1$3.SNodeImpl,
      "class-sprotty-port": node instanceof sgraph_1$3.SPortImpl,
      "class-mouseover": node.hoverFeedback,
      "class-selected": node.selected,
      r: radius,
      cx: radius,
      cy: radius
    }), context.renderChildren(node));
  }
  getRadius(node) {
    const d = Math.min(node.size.width, node.size.height);
    return d > 0 ? d / 2 : 0;
  }
};
svgViews.CircularNodeView = CircularNodeView;
svgViews.CircularNodeView = CircularNodeView = __decorate$F([(0, inversify_1$_.injectable)()], CircularNodeView);
let RectangularNodeView = class RectangularNodeView2 extends views_1$3.ShapeView {
  render(node, context, args) {
    if (!this.isVisible(node, context)) {
      return void 0;
    }
    return (0, jsx_1$6.svg)("g", null, (0, jsx_1$6.svg)("rect", {
      "class-sprotty-node": node instanceof sgraph_1$3.SNodeImpl,
      "class-sprotty-port": node instanceof sgraph_1$3.SPortImpl,
      "class-mouseover": node.hoverFeedback,
      "class-selected": node.selected,
      x: "0",
      y: "0",
      width: Math.max(node.size.width, 0),
      height: Math.max(node.size.height, 0)
    }), context.renderChildren(node));
  }
};
svgViews.RectangularNodeView = RectangularNodeView;
svgViews.RectangularNodeView = RectangularNodeView = __decorate$F([(0, inversify_1$_.injectable)()], RectangularNodeView);
let DiamondNodeView = class DiamondNodeView2 extends views_1$3.ShapeView {
  render(node, context, args) {
    if (!this.isVisible(node, context)) {
      return void 0;
    }
    const diamond = new geometry_1$g.Diamond({
      height: Math.max(node.size.height, 0),
      width: Math.max(node.size.width, 0),
      x: 0,
      y: 0
    });
    const points = `${svgStr(diamond.topPoint)} ${svgStr(diamond.rightPoint)} ${svgStr(diamond.bottomPoint)} ${svgStr(diamond.leftPoint)}`;
    return (0, jsx_1$6.svg)("g", null, (0, jsx_1$6.svg)("polygon", {
      "class-sprotty-node": node instanceof sgraph_1$3.SNodeImpl,
      "class-sprotty-port": node instanceof sgraph_1$3.SPortImpl,
      "class-mouseover": node.hoverFeedback,
      "class-selected": node.selected,
      points
    }), context.renderChildren(node));
  }
};
svgViews.DiamondNodeView = DiamondNodeView;
svgViews.DiamondNodeView = DiamondNodeView = __decorate$F([(0, inversify_1$_.injectable)()], DiamondNodeView);
function svgStr(point) {
  return `${point.x},${point.y}`;
}
let EmptyGroupView = class EmptyGroupView2 {
  render(model2, context) {
    return (0, jsx_1$6.svg)("g", null);
  }
};
svgViews.EmptyGroupView = EmptyGroupView;
svgViews.EmptyGroupView = EmptyGroupView = __decorate$F([(0, inversify_1$_.injectable)()], EmptyGroupView);
var editLabel = {};
var __decorate$E = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$p = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$c = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(editLabel, "__esModule", {
  value: true
});
editLabel.getEditableLabel = editLabel.EditLabelKeyListener = editLabel.EditLabelMouseListener = editLabel.ApplyLabelEditCommand = editLabel.ResolvedLabelEdit = editLabel.isApplyLabelEditAction = editLabel.isEditLabelAction = editLabel.EditLabelAction = void 0;
const inversify_1$Z = require$$0$1;
const actions_1$j = actions;
const command_1$d = command;
const types_1$E = types;
const mouse_tool_1$7 = mouseTool;
const key_tool_1$5 = keyTool;
const keyboard_1$6 = keyboard;
const model_1$u = model$c;
const iterable_1$1 = iterable;
const model_2$c = model$7;
var EditLabelAction;
(function(EditLabelAction2) {
  EditLabelAction2.KIND = "EditLabel";
  function create2(labelId) {
    return {
      kind: EditLabelAction2.KIND,
      labelId
    };
  }
  EditLabelAction2.create = create2;
})(EditLabelAction || (editLabel.EditLabelAction = EditLabelAction = {}));
function isEditLabelAction(element) {
  return (0, actions_1$j.isAction)(element) && element.kind === EditLabelAction.KIND && "labelId" in element;
}
editLabel.isEditLabelAction = isEditLabelAction;
function isApplyLabelEditAction(element) {
  return (0, actions_1$j.isAction)(element) && element.kind === actions_1$j.ApplyLabelEditAction.KIND && "labelId" in element && "text" in element;
}
editLabel.isApplyLabelEditAction = isApplyLabelEditAction;
class ResolvedLabelEdit {
}
editLabel.ResolvedLabelEdit = ResolvedLabelEdit;
let ApplyLabelEditCommand = class ApplyLabelEditCommand2 extends command_1$d.Command {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    const index = context.root.index;
    const label = index.getById(this.action.labelId);
    if (label && (0, model_2$c.isEditableLabel)(label)) {
      this.resolvedLabelEdit = {
        label,
        oldLabel: label.text,
        newLabel: this.action.text
      };
      label.text = this.action.text;
    }
    return context.root;
  }
  undo(context) {
    if (this.resolvedLabelEdit) {
      this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.oldLabel;
    }
    return context.root;
  }
  redo(context) {
    if (this.resolvedLabelEdit) {
      this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.newLabel;
    }
    return context.root;
  }
};
editLabel.ApplyLabelEditCommand = ApplyLabelEditCommand;
ApplyLabelEditCommand.KIND = actions_1$j.ApplyLabelEditAction.KIND;
editLabel.ApplyLabelEditCommand = ApplyLabelEditCommand = __decorate$E([__param$c(0, (0, inversify_1$Z.inject)(types_1$E.TYPES.Action)), __metadata$p("design:paramtypes", [Object])], ApplyLabelEditCommand);
class EditLabelMouseListener extends mouse_tool_1$7.MouseListener {
  doubleClick(target, event) {
    const editableLabel = getEditableLabel(target);
    if (editableLabel) {
      return [EditLabelAction.create(editableLabel.id)];
    }
    return [];
  }
}
editLabel.EditLabelMouseListener = EditLabelMouseListener;
class EditLabelKeyListener extends key_tool_1$5.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$6.matchesKeystroke)(event, "F2")) {
      const editableLabels = (0, iterable_1$1.toArray)(element.index.all().filter((e) => (0, model_1$u.isSelectable)(e) && e.selected)).map(getEditableLabel).filter((e) => e !== void 0);
      if (editableLabels.length === 1) {
        return [EditLabelAction.create(editableLabels[0].id)];
      }
    }
    return [];
  }
}
editLabel.EditLabelKeyListener = EditLabelKeyListener;
function getEditableLabel(element) {
  if ((0, model_2$c.isEditableLabel)(element)) {
    return element;
  } else if ((0, model_2$c.isWithEditableLabel)(element) && element.editableLabel) {
    return element.editableLabel;
  }
  return void 0;
}
editLabel.getEditableLabel = getEditableLabel;
var editLabelUi = {};
var commitModel = {};
var modelSource = {};
var svgExporter = {};
var __decorate$D = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$o = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(svgExporter, "__esModule", {
  value: true
});
svgExporter.SvgExporter = svgExporter.ExportSvgAction = void 0;
const inversify_1$Y = require$$0$1;
const geometry_1$f = geometry$1;
const model_1$t = model$g;
const action_dispatcher_1 = actionDispatcher;
const types_1$D = types;
var ExportSvgAction;
(function(ExportSvgAction2) {
  ExportSvgAction2.KIND = "exportSvg";
  function create2(svg2, requestId) {
    return {
      kind: ExportSvgAction2.KIND,
      svg: svg2,
      responseId: requestId
    };
  }
  ExportSvgAction2.create = create2;
})(ExportSvgAction || (svgExporter.ExportSvgAction = ExportSvgAction = {}));
let SvgExporter = class SvgExporter2 {
  export(root, request) {
    if (typeof document !== "undefined") {
      const hiddenDiv = document.getElementById(this.options.hiddenDiv);
      if (hiddenDiv === null) {
        this.log.warn(this, `Element with id ${this.options.hiddenDiv} not found. Nothing to export.`);
        return;
      }
      const svgElement = hiddenDiv.querySelector("svg");
      if (svgElement === null) {
        this.log.warn(this, `No svg element found in ${this.options.hiddenDiv} div. Nothing to export.`);
        return;
      }
      const svg2 = this.createSvg(svgElement, root);
      this.actionDispatcher.dispatch(ExportSvgAction.create(svg2, request ? request.requestId : ""));
    }
  }
  createSvg(svgElementOrig, root) {
    const serializer = new XMLSerializer();
    const svgCopy = serializer.serializeToString(svgElementOrig);
    const iframe = document.createElement("iframe");
    document.body.appendChild(iframe);
    if (!iframe.contentWindow)
      throw new Error("IFrame has no contentWindow");
    const docCopy = iframe.contentWindow.document;
    docCopy.open();
    docCopy.write(svgCopy);
    docCopy.close();
    const svgElementNew = docCopy.querySelector("svg");
    svgElementNew.removeAttribute("opacity");
    this.copyStyles(svgElementOrig, svgElementNew, ["width", "height", "opacity", "inline-size"]);
    svgElementNew.setAttribute("version", "1.1");
    const bounds = this.getBounds(root);
    svgElementNew.setAttribute("viewBox", `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
    const svgCode = serializer.serializeToString(svgElementNew);
    document.body.removeChild(iframe);
    return svgCode;
  }
  copyStyles(source, target, skippedProperties) {
    const sourceStyle = getComputedStyle(source);
    const targetStyle = getComputedStyle(target);
    let diffStyle = "";
    for (let i = 0; i < sourceStyle.length; i++) {
      const key = sourceStyle[i];
      if (skippedProperties.indexOf(key) === -1) {
        const value = sourceStyle.getPropertyValue(key);
        if (targetStyle.getPropertyValue(key) !== value) {
          diffStyle += key + ":" + value + ";";
        }
      }
    }
    if (diffStyle !== "")
      target.setAttribute("style", diffStyle);
    for (let i = 0; i < source.childNodes.length; ++i) {
      const sourceChild = source.childNodes[i];
      const targetChild = target.childNodes[i];
      if (sourceChild instanceof Element)
        this.copyStyles(sourceChild, targetChild, []);
    }
  }
  getBounds(root) {
    const allBounds = [geometry_1$f.Bounds.EMPTY];
    root.children.forEach((element) => {
      if ((0, model_1$t.isBoundsAware)(element)) {
        allBounds.push(element.bounds);
      }
    });
    return allBounds.reduce((one, two) => geometry_1$f.Bounds.combine(one, two));
  }
};
svgExporter.SvgExporter = SvgExporter;
__decorate$D([(0, inversify_1$Y.inject)(types_1$D.TYPES.ViewerOptions), __metadata$o("design:type", Object)], SvgExporter.prototype, "options", void 0);
__decorate$D([(0, inversify_1$Y.inject)(types_1$D.TYPES.IActionDispatcher), __metadata$o("design:type", action_dispatcher_1.ActionDispatcher)], SvgExporter.prototype, "actionDispatcher", void 0);
__decorate$D([(0, inversify_1$Y.inject)(types_1$D.TYPES.ILogger), __metadata$o("design:type", Object)], SvgExporter.prototype, "log", void 0);
svgExporter.SvgExporter = SvgExporter = __decorate$D([(0, inversify_1$Y.injectable)()], SvgExporter);
var __decorate$C = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$n = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(modelSource, "__esModule", {
  value: true
});
modelSource.ComputedBoundsApplicator = modelSource.ModelSource = void 0;
const inversify_1$X = require$$0$1;
const actions_1$i = actions;
const model_utils_1$2 = modelUtils;
const types_1$C = types;
const svg_exporter_1$4 = svgExporter;
let ModelSource = class ModelSource2 {
  initialize(registry2) {
    registry2.register(actions_1$i.RequestModelAction.KIND, this);
    registry2.register(svg_exporter_1$4.ExportSvgAction.KIND, this);
  }
};
modelSource.ModelSource = ModelSource;
__decorate$C([(0, inversify_1$X.inject)(types_1$C.TYPES.IActionDispatcher), __metadata$n("design:type", Object)], ModelSource.prototype, "actionDispatcher", void 0);
__decorate$C([(0, inversify_1$X.inject)(types_1$C.TYPES.ViewerOptions), __metadata$n("design:type", Object)], ModelSource.prototype, "viewerOptions", void 0);
modelSource.ModelSource = ModelSource = __decorate$C([(0, inversify_1$X.injectable)()], ModelSource);
let ComputedBoundsApplicator = class ComputedBoundsApplicator2 {
  apply(root, action2) {
    const index = new model_utils_1$2.SModelIndex();
    index.add(root);
    for (const b of action2.bounds) {
      const element = index.getById(b.elementId);
      if (element !== void 0)
        this.applyBounds(element, b.newPosition, b.newSize);
    }
    if (action2.alignments !== void 0) {
      for (const a of action2.alignments) {
        const element = index.getById(a.elementId);
        if (element !== void 0)
          this.applyAlignment(element, a.newAlignment);
      }
    }
    return index;
  }
  applyAlignment(element, newAlignment) {
    const e = element;
    e.alignment = {
      x: newAlignment.x,
      y: newAlignment.y
    };
  }
  applyBounds(element, newPosition, newSize) {
    const e = element;
    if (newPosition)
      e.position = Object.assign({}, newPosition);
    e.size = Object.assign({}, newSize);
  }
};
modelSource.ComputedBoundsApplicator = ComputedBoundsApplicator;
modelSource.ComputedBoundsApplicator = ComputedBoundsApplicator = __decorate$C([(0, inversify_1$X.injectable)()], ComputedBoundsApplicator);
var __decorate$B = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$m = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$b = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(commitModel, "__esModule", {
  value: true
});
commitModel.CommitModelCommand = commitModel.CommitModelAction = void 0;
const inversify_1$W = require$$0$1;
const command_1$c = command;
const types_1$B = types;
const model_source_1$3 = modelSource;
var CommitModelAction;
(function(CommitModelAction2) {
  CommitModelAction2.KIND = "commitModel";
  function create2() {
    return {
      kind: CommitModelAction2.KIND
    };
  }
  CommitModelAction2.create = create2;
})(CommitModelAction || (commitModel.CommitModelAction = CommitModelAction = {}));
let CommitModelCommand = class CommitModelCommand2 extends command_1$c.SystemCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    this.newModel = context.modelFactory.createSchema(context.root);
    return this.doCommit(this.newModel, context.root, true);
  }
  doCommit(model2, result, doSetOriginal) {
    const commitResult = this.modelSource.commitModel(model2);
    if (commitResult instanceof Promise) {
      return commitResult.then((originalModel) => {
        if (doSetOriginal)
          this.originalModel = originalModel;
        return result;
      });
    } else {
      if (doSetOriginal)
        this.originalModel = commitResult;
      return result;
    }
  }
  undo(context) {
    return this.doCommit(this.originalModel, context.root, false);
  }
  redo(context) {
    return this.doCommit(this.newModel, context.root, false);
  }
};
commitModel.CommitModelCommand = CommitModelCommand;
CommitModelCommand.KIND = CommitModelAction.KIND;
__decorate$B([(0, inversify_1$W.inject)(types_1$B.TYPES.ModelSource), __metadata$m("design:type", model_source_1$3.ModelSource)], CommitModelCommand.prototype, "modelSource", void 0);
commitModel.CommitModelCommand = CommitModelCommand = __decorate$B([(0, inversify_1$W.injectable)(), __param$b(0, (0, inversify_1$W.inject)(types_1$B.TYPES.Action)), __metadata$m("design:paramtypes", [Object])], CommitModelCommand);
var zoom = {};
var __decorate$A = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$l = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(zoom, "__esModule", {
  value: true
});
zoom.ZoomMouseListener = zoom.getZoom = void 0;
const inversify_1$V = require$$0$1;
const actions_1$h = actions;
const geometry_1$e = geometry$1;
const smodel_utils_1$a = smodelUtils;
const types_1$A = types;
const mouse_tool_1$6 = mouseTool;
const browser_1$3 = browser;
const model_1$s = model$6;
const geometry_2$3 = geometry;
function getZoom(label) {
  let zoom2 = 1;
  const viewport2 = (0, smodel_utils_1$a.findParentByFeature)(label, model_1$s.isViewport);
  if (viewport2) {
    zoom2 = viewport2.zoom;
  }
  return zoom2;
}
zoom.getZoom = getZoom;
class ZoomMouseListener extends mouse_tool_1$6.MouseListener {
  wheel(target, event) {
    const viewport2 = (0, smodel_utils_1$a.findParentByFeature)(target, model_1$s.isViewport);
    if (!viewport2) {
      return [];
    }
    const newViewport = this.isScrollMode(event) ? this.processScroll(viewport2, event) : this.processZoom(viewport2, target, event);
    if (newViewport) {
      return [actions_1$h.SetViewportAction.create(viewport2.id, newViewport, {
        animate: false
      })];
    }
    return [];
  }
  isScrollMode(event) {
    return event.altKey;
  }
  processScroll(viewport2, event) {
    return {
      scroll: {
        x: viewport2.scroll.x + event.deltaX,
        y: viewport2.scroll.y + event.deltaY
      },
      zoom: viewport2.zoom
    };
  }
  processZoom(viewport2, target, event) {
    const zoomFactor = this.getZoomFactor(event);
    if (zoomFactor > 1 && (0, geometry_1$e.almostEquals)(viewport2.zoom, this.viewerOptions.zoomLimits.max) || zoomFactor < 1 && (0, geometry_1$e.almostEquals)(viewport2.zoom, this.viewerOptions.zoomLimits.min)) {
      return;
    }
    const zoom2 = (0, geometry_2$3.limit)(viewport2.zoom * zoomFactor, this.viewerOptions.zoomLimits);
    const viewportOffset = this.getViewportOffset(target.root, event);
    const offsetFactor = 1 / zoom2 - 1 / viewport2.zoom;
    return {
      scroll: {
        x: viewport2.scroll.x - offsetFactor * viewportOffset.x,
        y: viewport2.scroll.y - offsetFactor * viewportOffset.y
      },
      zoom: zoom2
    };
  }
  getViewportOffset(root, event) {
    const canvasBounds = root.canvasBounds;
    const windowScroll = (0, browser_1$3.getWindowScroll)();
    return {
      x: event.clientX + windowScroll.x - canvasBounds.x,
      y: event.clientY + windowScroll.y - canvasBounds.y
    };
  }
  getZoomFactor(event) {
    if (event.deltaMode === event.DOM_DELTA_PAGE)
      return Math.exp(-event.deltaY * 0.5);
    else if (event.deltaMode === event.DOM_DELTA_LINE)
      return Math.exp(-event.deltaY * 0.05);
    else
      return Math.exp(-event.deltaY * 5e-3);
  }
}
zoom.ZoomMouseListener = ZoomMouseListener;
__decorate$A([(0, inversify_1$V.inject)(types_1$A.TYPES.ViewerOptions), __metadata$l("design:type", Object)], ZoomMouseListener.prototype, "viewerOptions", void 0);
var __decorate$z = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$k = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var EditLabelUI_1;
Object.defineProperty(editLabelUi, "__esModule", {
  value: true
});
editLabelUi.EditLabelUI = editLabelUi.EditLabelActionHandler = void 0;
const inversify_1$U = require$$0$1;
const actions_1$g = actions;
const types_1$z = types;
const ui_extension_1 = uiExtension;
const ui_extension_registry_1 = uiExtensionRegistry;
const dom_helper_1 = domHelper;
const commit_model_1$2 = commitModel;
const keyboard_1$5 = keyboard;
const model_1$r = model$g;
const zoom_1$1 = zoom;
const edit_label_1$1 = editLabel;
const model_2$b = model$7;
let EditLabelActionHandler = class EditLabelActionHandler2 {
  handle(action2) {
    if ((0, edit_label_1$1.isEditLabelAction)(action2)) {
      return ui_extension_registry_1.SetUIExtensionVisibilityAction.create({
        extensionId: EditLabelUI.ID,
        visible: true,
        contextElementsId: [action2.labelId]
      });
    }
  }
};
editLabelUi.EditLabelActionHandler = EditLabelActionHandler;
editLabelUi.EditLabelActionHandler = EditLabelActionHandler = __decorate$z([(0, inversify_1$U.injectable)()], EditLabelActionHandler);
let EditLabelUI = EditLabelUI_1 = class EditLabelUI2 extends ui_extension_1.AbstractUIExtension {
  constructor() {
    super(...arguments);
    this.validationTimeout = void 0;
    this.isActive = false;
    this.blockApplyEditOnInvalidInput = true;
    this.isCurrentLabelValid = true;
  }
  id() {
    return EditLabelUI_1.ID;
  }
  containerClass() {
    return "label-edit";
  }
  get labelId() {
    return this.label ? this.label.id : "unknown";
  }
  initializeContents(containerElement) {
    containerElement.style.position = "absolute";
    this.inputElement = document.createElement("input");
    this.textAreaElement = document.createElement("textarea");
    [this.inputElement, this.textAreaElement].forEach((element) => {
      element.onkeydown = (event) => this.applyLabelEditOnEvent(event, "Enter");
      this.configureAndAdd(element, containerElement);
    });
  }
  configureAndAdd(element, containerElement) {
    element.style.visibility = "hidden";
    element.style.position = "absolute";
    element.style.top = "0px";
    element.style.left = "0px";
    element.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
    element.addEventListener("keyup", (event) => this.validateLabelIfContentChange(event, element.value));
    element.addEventListener("blur", () => window.setTimeout(() => this.applyLabelEdit(), 200));
    containerElement.appendChild(element);
  }
  get editControl() {
    if (this.label && this.label.isMultiLine) {
      return this.textAreaElement;
    }
    return this.inputElement;
  }
  hideIfEscapeEvent(event) {
    if ((0, keyboard_1$5.matchesKeystroke)(event, "Escape")) {
      this.hide();
    }
  }
  applyLabelEditOnEvent(event, code, ...modifiers) {
    if ((0, keyboard_1$5.matchesKeystroke)(event, code ? code : "Enter", ...modifiers)) {
      event.preventDefault();
      this.applyLabelEdit();
    }
  }
  validateLabelIfContentChange(event, value) {
    if (this.previousLabelContent === void 0 || this.previousLabelContent !== value) {
      this.previousLabelContent = value;
      this.performLabelValidation(event, this.editControl.value);
    }
  }
  async applyLabelEdit() {
    var _a;
    if (!this.isActive) {
      return;
    }
    if (((_a = this.label) === null || _a === void 0 ? void 0 : _a.text) === this.editControl.value) {
      this.hide();
      return;
    }
    if (this.blockApplyEditOnInvalidInput) {
      const result = await this.validateLabel(this.editControl.value);
      if ("error" === result.severity) {
        this.editControl.focus();
        return;
      }
    }
    this.actionDispatcherProvider().then((actionDispatcher2) => actionDispatcher2.dispatchAll([actions_1$g.ApplyLabelEditAction.create(this.labelId, this.editControl.value), commit_model_1$2.CommitModelAction.create()])).catch((reason) => this.logger.error(this, "No action dispatcher available to execute apply label edit action", reason));
    this.hide();
  }
  performLabelValidation(event, value) {
    if (this.validationTimeout) {
      window.clearTimeout(this.validationTimeout);
    }
    this.validationTimeout = window.setTimeout(() => this.validateLabel(value), 200);
  }
  async validateLabel(value) {
    if (this.labelValidator && this.label) {
      try {
        const result = await this.labelValidator.validate(value, this.label);
        this.isCurrentLabelValid = "error" !== result.severity;
        this.showValidationResult(result);
        return result;
      } catch (reason) {
        this.logger.error(this, "Error validating edited label", reason);
      }
    }
    this.isCurrentLabelValid = true;
    return {
      severity: "ok",
      message: void 0
    };
  }
  showValidationResult(result) {
    this.clearValidationResult();
    if (this.validationDecorator) {
      this.validationDecorator.decorate(this.editControl, result);
    }
  }
  clearValidationResult() {
    if (this.validationDecorator) {
      this.validationDecorator.dispose(this.editControl);
    }
  }
  show(root, ...contextElementIds) {
    if (!hasEditableLabel(contextElementIds, root) || this.isActive) {
      return;
    }
    super.show(root, ...contextElementIds);
    this.isActive = true;
  }
  hide() {
    this.editControl.style.visibility = "hidden";
    super.hide();
    this.clearValidationResult();
    this.isActive = false;
    this.isCurrentLabelValid = true;
    this.previousLabelContent = void 0;
    if (this.labelElement) {
      this.labelElement.style.visibility = "visible";
    }
  }
  onBeforeShow(containerElement, root, ...contextElementIds) {
    this.label = getEditableLabels(contextElementIds, root)[0];
    this.previousLabelContent = this.label.text;
    this.setPosition(containerElement);
    this.applyTextContents();
    this.applyFontStyling();
    this.editControl.style.visibility = "visible";
    this.editControl.focus();
  }
  setPosition(containerElement) {
    let x = 0;
    let y = 0;
    let width = 100;
    let height = 20;
    if (this.label) {
      const zoom2 = (0, zoom_1$1.getZoom)(this.label);
      const bounds = (0, model_1$r.getAbsoluteClientBounds)(this.label, this.domHelper, this.viewerOptions);
      x = bounds.x + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.x : 0) * zoom2;
      y = bounds.y + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.y : 0) * zoom2;
      height = (this.label.editControlDimension ? this.label.editControlDimension.height : height) * zoom2;
      width = (this.label.editControlDimension ? this.label.editControlDimension.width : width) * zoom2;
    }
    containerElement.style.left = `${x}px`;
    containerElement.style.top = `${y}px`;
    containerElement.style.width = `${width}px`;
    this.editControl.style.width = `${width}px`;
    containerElement.style.height = `${height}px`;
    this.editControl.style.height = `${height}px`;
  }
  applyTextContents() {
    if (this.label) {
      this.editControl.value = this.label.text;
      if (this.editControl instanceof HTMLTextAreaElement) {
        this.editControl.selectionStart = 0;
        this.editControl.selectionEnd = 0;
        this.editControl.scrollTop = 0;
        this.editControl.scrollLeft = 0;
      } else {
        this.editControl.setSelectionRange(0, this.editControl.value.length);
      }
    }
  }
  applyFontStyling() {
    if (this.label) {
      this.labelElement = document.getElementById(this.domHelper.createUniqueDOMElementId(this.label));
      if (this.labelElement) {
        this.labelElement.style.visibility = "hidden";
        const style = window.getComputedStyle(this.labelElement);
        this.editControl.style.font = style.font;
        this.editControl.style.fontStyle = style.fontStyle;
        this.editControl.style.fontFamily = style.fontFamily;
        this.editControl.style.fontSize = scaledFont(style.fontSize, (0, zoom_1$1.getZoom)(this.label));
        this.editControl.style.fontWeight = style.fontWeight;
        this.editControl.style.lineHeight = style.lineHeight;
      }
    }
  }
};
editLabelUi.EditLabelUI = EditLabelUI;
EditLabelUI.ID = "editLabelUi";
__decorate$z([(0, inversify_1$U.inject)(types_1$z.TYPES.IActionDispatcherProvider), __metadata$k("design:type", Function)], EditLabelUI.prototype, "actionDispatcherProvider", void 0);
__decorate$z([(0, inversify_1$U.inject)(types_1$z.TYPES.ViewerOptions), __metadata$k("design:type", Object)], EditLabelUI.prototype, "viewerOptions", void 0);
__decorate$z([(0, inversify_1$U.inject)(types_1$z.TYPES.DOMHelper), __metadata$k("design:type", dom_helper_1.DOMHelper)], EditLabelUI.prototype, "domHelper", void 0);
__decorate$z([(0, inversify_1$U.inject)(types_1$z.TYPES.IEditLabelValidator), (0, inversify_1$U.optional)(), __metadata$k("design:type", Object)], EditLabelUI.prototype, "labelValidator", void 0);
__decorate$z([(0, inversify_1$U.inject)(types_1$z.TYPES.IEditLabelValidationDecorator), (0, inversify_1$U.optional)(), __metadata$k("design:type", Object)], EditLabelUI.prototype, "validationDecorator", void 0);
editLabelUi.EditLabelUI = EditLabelUI = EditLabelUI_1 = __decorate$z([(0, inversify_1$U.injectable)()], EditLabelUI);
function hasEditableLabel(contextElementIds, root) {
  return getEditableLabels(contextElementIds, root).length === 1;
}
function getEditableLabels(contextElementIds, root) {
  return contextElementIds.map((id2) => root.index.getById(id2)).filter(model_2$b.isEditableLabel);
}
function scaledFont(font, zoom2) {
  return font.replace(/\d+(\.\d+)?/, (match) => {
    return String(Number.parseInt(match, 10) * zoom2);
  });
}
var editRouting = {};
var __decorate$y = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$j = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$a = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(editRouting, "__esModule", {
  value: true
});
editRouting.SwitchEditModeCommand = editRouting.SwitchEditModeAction = void 0;
const inversify_1$T = require$$0$1;
const command_1$b = command;
const smodel_1$c = smodel;
const types_1$y = types;
const model_1$q = model$a;
const routing_1$7 = routing;
const model_2$a = model$7;
var SwitchEditModeAction;
(function(SwitchEditModeAction2) {
  SwitchEditModeAction2.KIND = "switchEditMode";
  function create2(options) {
    var _a, _b;
    return {
      kind: SwitchEditModeAction2.KIND,
      elementsToActivate: (_a = options.elementsToActivate) !== null && _a !== void 0 ? _a : [],
      elementsToDeactivate: (_b = options.elementsToDeactivate) !== null && _b !== void 0 ? _b : []
    };
  }
  SwitchEditModeAction2.create = create2;
})(SwitchEditModeAction || (editRouting.SwitchEditModeAction = SwitchEditModeAction = {}));
let SwitchEditModeCommand = class SwitchEditModeCommand2 extends command_1$b.Command {
  constructor(action2) {
    super();
    this.action = action2;
    this.elementsToActivate = [];
    this.elementsToDeactivate = [];
    this.handlesToRemove = [];
  }
  execute(context) {
    const index = context.root.index;
    this.action.elementsToActivate.forEach((id2) => {
      const element = index.getById(id2);
      if (element !== void 0)
        this.elementsToActivate.push(element);
    });
    this.action.elementsToDeactivate.forEach((id2) => {
      const element = index.getById(id2);
      if (element !== void 0)
        this.elementsToDeactivate.push(element);
      if (element instanceof model_1$q.SRoutingHandleImpl && element.parent instanceof model_1$q.SRoutableElementImpl) {
        const parent = element.parent;
        if (this.shouldRemoveHandle(element, parent)) {
          this.handlesToRemove.push({
            handle: element,
            parent
          });
          this.elementsToDeactivate.push(parent);
          this.elementsToActivate.push(parent);
        }
      }
    });
    return this.doExecute(context);
  }
  doExecute(context) {
    this.handlesToRemove.forEach((entry) => {
      entry.point = entry.parent.routingPoints.splice(entry.handle.pointIndex, 1)[0];
    });
    this.elementsToDeactivate.forEach((element) => {
      if (element instanceof model_1$q.SRoutableElementImpl)
        element.removeAll((child) => child instanceof model_1$q.SRoutingHandleImpl);
      else if (element instanceof model_1$q.SRoutingHandleImpl) {
        element.editMode = false;
        if (element.danglingAnchor) {
          if (element.parent instanceof model_1$q.SRoutableElementImpl && element.danglingAnchor.original) {
            if (element.parent.source === element.danglingAnchor)
              element.parent.sourceId = element.danglingAnchor.original.id;
            else if (element.parent.target === element.danglingAnchor)
              element.parent.targetId = element.danglingAnchor.original.id;
            element.danglingAnchor.parent.remove(element.danglingAnchor);
            element.danglingAnchor = void 0;
          }
        }
      }
    });
    this.elementsToActivate.forEach((element) => {
      if ((0, model_2$a.canEditRouting)(element) && element instanceof smodel_1$c.SParentElementImpl) {
        const router = this.edgeRouterRegistry.get(element.routerKind);
        router.createRoutingHandles(element);
      } else if (element instanceof model_1$q.SRoutingHandleImpl)
        element.editMode = true;
    });
    return context.root;
  }
  shouldRemoveHandle(handle, parent) {
    if (handle.kind === "junction") {
      const route = this.edgeRouterRegistry.route(parent);
      return route.find((rp) => rp.pointIndex === handle.pointIndex) === void 0;
    }
    return false;
  }
  undo(context) {
    this.handlesToRemove.forEach((entry) => {
      if (entry.point !== void 0)
        entry.parent.routingPoints.splice(entry.handle.pointIndex, 0, entry.point);
    });
    this.elementsToActivate.forEach((element) => {
      if (element instanceof model_1$q.SRoutableElementImpl)
        element.removeAll((child) => child instanceof model_1$q.SRoutingHandleImpl);
      else if (element instanceof model_1$q.SRoutingHandleImpl)
        element.editMode = false;
    });
    this.elementsToDeactivate.forEach((element) => {
      if ((0, model_2$a.canEditRouting)(element)) {
        const router = this.edgeRouterRegistry.get(element.routerKind);
        router.createRoutingHandles(element);
      } else if (element instanceof model_1$q.SRoutingHandleImpl)
        element.editMode = true;
    });
    return context.root;
  }
  redo(context) {
    return this.doExecute(context);
  }
};
editRouting.SwitchEditModeCommand = SwitchEditModeCommand;
SwitchEditModeCommand.KIND = SwitchEditModeAction.KIND;
__decorate$y([(0, inversify_1$T.inject)(routing_1$7.EdgeRouterRegistry), __metadata$j("design:type", routing_1$7.EdgeRouterRegistry)], SwitchEditModeCommand.prototype, "edgeRouterRegistry", void 0);
editRouting.SwitchEditModeCommand = SwitchEditModeCommand = __decorate$y([(0, inversify_1$T.injectable)(), __param$a(0, (0, inversify_1$T.inject)(types_1$y.TYPES.Action)), __metadata$j("design:paramtypes", [Object])], SwitchEditModeCommand);
var reconnect = {};
var __decorate$x = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$i = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$9 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(reconnect, "__esModule", {
  value: true
});
reconnect.ReconnectCommand = void 0;
const inversify_1$S = require$$0$1;
const actions_1$f = actions;
const command_1$a = command;
const types_1$x = types;
const model_1$p = model$a;
const routing_1$6 = routing;
let ReconnectCommand = class ReconnectCommand2 extends command_1$a.Command {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    this.doExecute(context);
    return context.root;
  }
  doExecute(context) {
    const index = context.root.index;
    const edge = index.getById(this.action.routableId);
    if (edge instanceof model_1$p.SRoutableElementImpl) {
      const router = this.edgeRouterRegistry.get(edge.routerKind);
      const before = router.takeSnapshot(edge);
      router.applyReconnect(edge, this.action.newSourceId, this.action.newTargetId);
      const after = router.takeSnapshot(edge);
      this.memento = {
        edge,
        before,
        after
      };
    }
  }
  undo(context) {
    if (this.memento) {
      const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
      router.applySnapshot(this.memento.edge, this.memento.before);
    }
    return context.root;
  }
  redo(context) {
    if (this.memento) {
      const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
      router.applySnapshot(this.memento.edge, this.memento.after);
    }
    return context.root;
  }
};
reconnect.ReconnectCommand = ReconnectCommand;
ReconnectCommand.KIND = actions_1$f.ReconnectAction.KIND;
__decorate$x([(0, inversify_1$S.inject)(routing_1$6.EdgeRouterRegistry), __metadata$i("design:type", routing_1$6.EdgeRouterRegistry)], ReconnectCommand.prototype, "edgeRouterRegistry", void 0);
reconnect.ReconnectCommand = ReconnectCommand = __decorate$x([(0, inversify_1$S.injectable)(), __param$9(0, (0, inversify_1$S.inject)(types_1$x.TYPES.Action)), __metadata$i("design:paramtypes", [Object])], ReconnectCommand);
Object.defineProperty(di_config$k, "__esModule", {
  value: true
});
di_config$k.labelEditUiModule = di_config$k.labelEditModule = di_config$k.edgeEditModule = void 0;
const inversify_1$R = require$$0$1;
const types_1$w = types;
const command_registration_1$a = commandRegistration;
const action_handler_1$1 = actionHandler$1;
const view_1$1 = view;
const model_1$o = model$a;
const svg_views_1 = svgViews;
const delete_1 = _delete;
const edit_label_1 = editLabel;
const edit_label_ui_1 = editLabelUi;
const edit_routing_1$2 = editRouting;
const reconnect_1$1 = reconnect;
di_config$k.edgeEditModule = new inversify_1$R.ContainerModule((bind, _unbind, isBound) => {
  const context = {
    bind,
    isBound
  };
  (0, command_registration_1$a.configureCommand)(context, edit_routing_1$2.SwitchEditModeCommand);
  (0, command_registration_1$a.configureCommand)(context, reconnect_1$1.ReconnectCommand);
  (0, command_registration_1$a.configureCommand)(context, delete_1.DeleteElementCommand);
  (0, view_1$1.configureModelElement)(context, "dangling-anchor", model_1$o.SDanglingAnchorImpl, svg_views_1.EmptyGroupView);
});
di_config$k.labelEditModule = new inversify_1$R.ContainerModule((bind, _unbind, isBound) => {
  bind(edit_label_1.EditLabelMouseListener).toSelf().inSingletonScope();
  bind(types_1$w.TYPES.MouseListener).toService(edit_label_1.EditLabelMouseListener);
  bind(edit_label_1.EditLabelKeyListener).toSelf().inSingletonScope();
  bind(types_1$w.TYPES.KeyListener).toService(edit_label_1.EditLabelKeyListener);
  (0, command_registration_1$a.configureCommand)({
    bind,
    isBound
  }, edit_label_1.ApplyLabelEditCommand);
});
di_config$k.labelEditUiModule = new inversify_1$R.ContainerModule((bind, _unbind, isBound) => {
  const context = {
    bind,
    isBound
  };
  (0, action_handler_1$1.configureActionHandler)(context, edit_label_1.EditLabelAction.KIND, edit_label_ui_1.EditLabelActionHandler);
  bind(edit_label_ui_1.EditLabelUI).toSelf().inSingletonScope();
  bind(types_1$w.TYPES.IUIExtension).toService(edit_label_ui_1.EditLabelUI);
});
var expand = {};
var model$4 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isExpandable = exports.expandFeature = void 0;
  exports.expandFeature = Symbol("expandFeature");
  function isExpandable(element) {
    return element.hasFeature(exports.expandFeature) && "expanded" in element;
  }
  exports.isExpandable = isExpandable;
})(model$4);
var __decorate$w = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(expand, "__esModule", {
  value: true
});
expand.ExpandButtonHandler = void 0;
const inversify_1$Q = require$$0$1;
const actions_1$e = actions;
const smodel_utils_1$9 = smodelUtils;
const model_1$n = model$4;
let ExpandButtonHandler = class ExpandButtonHandler2 {
  buttonPressed(button) {
    const expandable = (0, smodel_utils_1$9.findParentByFeature)(button, model_1$n.isExpandable);
    if (expandable !== void 0) {
      return [actions_1$e.CollapseExpandAction.create({
        expandIds: expandable.expanded ? [] : [expandable.id],
        collapseIds: expandable.expanded ? [expandable.id] : []
      })];
    } else {
      return [];
    }
  }
};
expand.ExpandButtonHandler = ExpandButtonHandler;
ExpandButtonHandler.TYPE = "button:expand";
expand.ExpandButtonHandler = ExpandButtonHandler = __decorate$w([(0, inversify_1$Q.injectable)()], ExpandButtonHandler);
var views$4 = {};
var __decorate$v = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(views$4, "__esModule", {
  value: true
});
views$4.ExpandButtonView = void 0;
const jsx_1$5 = jsx;
const model_1$m = model$4;
const smodel_utils_1$8 = smodelUtils;
const inversify_1$P = require$$0$1;
let ExpandButtonView = class ExpandButtonView2 {
  render(button, context) {
    const expandable = (0, smodel_utils_1$8.findParentByFeature)(button, model_1$m.isExpandable);
    const path = expandable !== void 0 && expandable.expanded ? "M 1,5 L 8,12 L 15,5 Z" : "M 1,8 L 8,15 L 8,1 Z";
    return (0, jsx_1$5.svg)("g", {
      "class-sprotty-button": "{true}",
      "class-enabled": "{button.enabled}"
    }, (0, jsx_1$5.svg)("rect", {
      x: 0,
      y: 0,
      width: 16,
      height: 16,
      opacity: 0
    }), (0, jsx_1$5.svg)("path", {
      d: path
    }));
  }
};
views$4.ExpandButtonView = ExpandButtonView;
views$4.ExpandButtonView = ExpandButtonView = __decorate$v([(0, inversify_1$P.injectable)()], ExpandButtonView);
var _export = {};
var __decorate$u = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$h = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$8 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(_export, "__esModule", {
  value: true
});
_export.ExportSvgPostprocessor = _export.ExportSvgCommand = _export.RequestExportSvgAction = _export.ExportSvgKeyListener = void 0;
const inversify_1$O = require$$0$1;
const actions_1$d = actions;
const command_1$9 = command;
const model_1$l = model$c;
const smodel_1$b = smodel;
const key_tool_1$4 = keyTool;
const keyboard_1$4 = keyboard;
const model_2$9 = model$5;
const svg_exporter_1$3 = svgExporter;
const model_3$7 = model$6;
const model_4$4 = model$9;
const types_1$v = types;
let ExportSvgKeyListener = class ExportSvgKeyListener2 extends key_tool_1$4.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$4.matchesKeystroke)(event, "KeyE", "ctrlCmd", "shift"))
      return [RequestExportSvgAction.create()];
    else
      return [];
  }
};
_export.ExportSvgKeyListener = ExportSvgKeyListener;
_export.ExportSvgKeyListener = ExportSvgKeyListener = __decorate$u([(0, inversify_1$O.injectable)()], ExportSvgKeyListener);
var RequestExportSvgAction;
(function(RequestExportSvgAction2) {
  RequestExportSvgAction2.KIND = "requestExportSvg";
  function create2() {
    return {
      kind: RequestExportSvgAction2.KIND,
      requestId: (0, actions_1$d.generateRequestId)()
    };
  }
  RequestExportSvgAction2.create = create2;
})(RequestExportSvgAction || (_export.RequestExportSvgAction = RequestExportSvgAction = {}));
let ExportSvgCommand = class ExportSvgCommand2 extends command_1$9.HiddenCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    if ((0, model_2$9.isExportable)(context.root)) {
      const root = context.modelFactory.createRoot(context.root);
      if ((0, model_2$9.isExportable)(root)) {
        if ((0, model_3$7.isViewport)(root)) {
          root.zoom = 1;
          root.scroll = {
            x: 0,
            y: 0
          };
        }
        root.index.all().forEach((element) => {
          if ((0, model_1$l.isSelectable)(element) && element.selected)
            element.selected = false;
          if ((0, model_4$4.isHoverable)(element) && element.hoverFeedback)
            element.hoverFeedback = false;
        });
        return {
          model: root,
          modelChanged: true,
          cause: this.action
        };
      }
    }
    return {
      model: context.root,
      modelChanged: false
    };
  }
};
_export.ExportSvgCommand = ExportSvgCommand;
ExportSvgCommand.KIND = RequestExportSvgAction.KIND;
_export.ExportSvgCommand = ExportSvgCommand = __decorate$u([__param$8(0, (0, inversify_1$O.inject)(types_1$v.TYPES.Action)), __metadata$h("design:paramtypes", [Object])], ExportSvgCommand);
let ExportSvgPostprocessor = class ExportSvgPostprocessor2 {
  decorate(vnode2, element) {
    if (element instanceof smodel_1$b.SModelRootImpl)
      this.root = element;
    return vnode2;
  }
  postUpdate(cause) {
    if (this.root && cause !== void 0 && cause.kind === RequestExportSvgAction.KIND) {
      this.svgExporter.export(this.root, cause);
    }
  }
};
_export.ExportSvgPostprocessor = ExportSvgPostprocessor;
__decorate$u([(0, inversify_1$O.inject)(types_1$v.TYPES.SvgExporter), __metadata$h("design:type", svg_exporter_1$3.SvgExporter)], ExportSvgPostprocessor.prototype, "svgExporter", void 0);
_export.ExportSvgPostprocessor = ExportSvgPostprocessor = __decorate$u([(0, inversify_1$O.injectable)()], ExportSvgPostprocessor);
var fade = {};
var __decorate$t = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(fade, "__esModule", {
  value: true
});
fade.ElementFader = fade.FadeAnimation = void 0;
const inversify_1$N = require$$0$1;
const animation_1$4 = animation;
const smodel_1$a = smodel;
const vnode_utils_1$8 = vnodeUtils;
const model_1$k = model$e;
class FadeAnimation extends animation_1$4.Animation {
  constructor(model2, elementFades, context, removeAfterFadeOut = false) {
    super(context);
    this.model = model2;
    this.elementFades = elementFades;
    this.removeAfterFadeOut = removeAfterFadeOut;
  }
  tween(t, context) {
    for (const elementFade of this.elementFades) {
      const element = elementFade.element;
      if (elementFade.type === "in") {
        element.opacity = t;
      } else if (elementFade.type === "out") {
        element.opacity = 1 - t;
        if (t === 1 && this.removeAfterFadeOut && element instanceof smodel_1$a.SChildElementImpl) {
          element.parent.remove(element);
        }
      }
    }
    return this.model;
  }
}
fade.FadeAnimation = FadeAnimation;
let ElementFader = class ElementFader2 {
  decorate(vnode2, element) {
    if ((0, model_1$k.isFadeable)(element) && element.opacity !== 1) {
      (0, vnode_utils_1$8.setAttr)(vnode2, "opacity", element.opacity);
    }
    return vnode2;
  }
  postUpdate() {
  }
};
fade.ElementFader = ElementFader;
fade.ElementFader = ElementFader = __decorate$t([(0, inversify_1$N.injectable)()], ElementFader);
var hover = {};
var __decorate$s = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$g = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$7 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(hover, "__esModule", {
  value: true
});
hover.ClosePopupActionHandler = hover.HoverKeyListener = hover.PopupHoverMouseListener = hover.HoverMouseListener = hover.AbstractHoverMouseListener = hover.SetPopupModelCommand = hover.HoverFeedbackCommand = void 0;
const inversify_1$M = require$$0$1;
const actions_1$c = actions;
const geometry_1$d = geometry$1;
const keyboard_1$3 = keyboard;
const types_1$u = types;
const smodel_1$9 = smodel;
const mouse_tool_1$5 = mouseTool;
const command_1$8 = command;
const smodel_factory_1$1 = smodelFactory;
const key_tool_1$3 = keyTool;
const smodel_utils_1$7 = smodelUtils;
const model_1$j = model$g;
const model_2$8 = model$9;
let HoverFeedbackCommand = class HoverFeedbackCommand2 extends command_1$8.SystemCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    const model2 = context.root;
    const modelElement = model2.index.getById(this.action.mouseoverElement);
    if (modelElement) {
      if ((0, model_2$8.isHoverable)(modelElement)) {
        modelElement.hoverFeedback = this.action.mouseIsOver;
      }
    }
    return this.redo(context);
  }
  undo(context) {
    return context.root;
  }
  redo(context) {
    return context.root;
  }
};
hover.HoverFeedbackCommand = HoverFeedbackCommand;
HoverFeedbackCommand.KIND = actions_1$c.HoverFeedbackAction.KIND;
hover.HoverFeedbackCommand = HoverFeedbackCommand = __decorate$s([(0, inversify_1$M.injectable)(), __param$7(0, (0, inversify_1$M.inject)(types_1$u.TYPES.Action)), __metadata$g("design:paramtypes", [Object])], HoverFeedbackCommand);
let SetPopupModelCommand = class SetPopupModelCommand2 extends command_1$8.PopupCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    this.oldRoot = context.root;
    this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
    return this.newRoot;
  }
  undo(context) {
    return this.oldRoot;
  }
  redo(context) {
    return this.newRoot;
  }
};
hover.SetPopupModelCommand = SetPopupModelCommand;
SetPopupModelCommand.KIND = actions_1$c.SetPopupModelAction.KIND;
hover.SetPopupModelCommand = SetPopupModelCommand = __decorate$s([(0, inversify_1$M.injectable)(), __param$7(0, (0, inversify_1$M.inject)(types_1$u.TYPES.Action)), __metadata$g("design:paramtypes", [Object])], SetPopupModelCommand);
class AbstractHoverMouseListener extends mouse_tool_1$5.MouseListener {
  mouseDown(target, event) {
    this.mouseIsDown = true;
    return [];
  }
  mouseUp(target, event) {
    this.mouseIsDown = false;
    return [];
  }
  stopMouseOutTimer() {
    if (this.state.mouseOutTimer !== void 0) {
      window.clearTimeout(this.state.mouseOutTimer);
      this.state.mouseOutTimer = void 0;
    }
  }
  startMouseOutTimer() {
    this.stopMouseOutTimer();
    return new Promise((resolve2) => {
      this.state.mouseOutTimer = window.setTimeout(() => {
        this.state.popupOpen = false;
        this.state.previousPopupElement = void 0;
        resolve2(actions_1$c.SetPopupModelAction.create({
          type: smodel_factory_1$1.EMPTY_ROOT.type,
          id: smodel_factory_1$1.EMPTY_ROOT.id
        }));
      }, this.options.popupCloseDelay);
    });
  }
  stopMouseOverTimer() {
    if (this.state.mouseOverTimer !== void 0) {
      window.clearTimeout(this.state.mouseOverTimer);
      this.state.mouseOverTimer = void 0;
    }
  }
}
hover.AbstractHoverMouseListener = AbstractHoverMouseListener;
__decorate$s([(0, inversify_1$M.inject)(types_1$u.TYPES.ViewerOptions), __metadata$g("design:type", Object)], AbstractHoverMouseListener.prototype, "options", void 0);
__decorate$s([(0, inversify_1$M.inject)(types_1$u.TYPES.HoverState), __metadata$g("design:type", Object)], AbstractHoverMouseListener.prototype, "state", void 0);
let HoverMouseListener = class HoverMouseListener2 extends AbstractHoverMouseListener {
  computePopupBounds(target, mousePosition) {
    let offset = {
      x: -5,
      y: 20
    };
    const targetBounds = (0, model_1$j.getAbsoluteBounds)(target);
    const canvasBounds = target.root.canvasBounds;
    const boundsInWindow = geometry_1$d.Bounds.translate(targetBounds, canvasBounds);
    const distRight = boundsInWindow.x + boundsInWindow.width - mousePosition.x;
    const distBottom = boundsInWindow.y + boundsInWindow.height - mousePosition.y;
    if (distBottom <= distRight && this.allowSidePosition(target, "below", distBottom)) {
      offset = {
        x: -5,
        y: Math.round(distBottom + 5)
      };
    } else if (distRight <= distBottom && this.allowSidePosition(target, "right", distRight)) {
      offset = {
        x: Math.round(distRight + 5),
        y: -5
      };
    }
    let leftPopupPosition = mousePosition.x + offset.x;
    const canvasRightBorderPosition = canvasBounds.x + canvasBounds.width;
    if (leftPopupPosition > canvasRightBorderPosition) {
      leftPopupPosition = canvasRightBorderPosition;
    }
    let topPopupPosition = mousePosition.y + offset.y;
    const canvasBottomBorderPosition = canvasBounds.y + canvasBounds.height;
    if (topPopupPosition > canvasBottomBorderPosition) {
      topPopupPosition = canvasBottomBorderPosition;
    }
    return {
      x: leftPopupPosition,
      y: topPopupPosition,
      width: -1,
      height: -1
    };
  }
  allowSidePosition(target, side, distance) {
    return !(target instanceof smodel_1$9.SModelRootImpl) && distance <= 150;
  }
  startMouseOverTimer(target, event) {
    this.stopMouseOverTimer();
    return new Promise((resolve2) => {
      this.state.mouseOverTimer = window.setTimeout(() => {
        const popupBounds = this.computePopupBounds(target, {
          x: event.pageX,
          y: event.pageY
        });
        resolve2(actions_1$c.RequestPopupModelAction.create({
          elementId: target.id,
          bounds: popupBounds
        }));
        this.state.popupOpen = true;
        this.state.previousPopupElement = target;
      }, this.options.popupOpenDelay);
    });
  }
  mouseOver(target, event) {
    const result = [];
    if (!this.mouseIsDown) {
      const popupTarget = (0, smodel_utils_1$7.findParent)(target, model_2$8.hasPopupFeature);
      if (this.state.popupOpen && (popupTarget === void 0 || this.state.previousPopupElement !== void 0 && this.state.previousPopupElement.id !== popupTarget.id)) {
        result.push(this.startMouseOutTimer());
      } else {
        this.stopMouseOverTimer();
        this.stopMouseOutTimer();
      }
      if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
        result.push(this.startMouseOverTimer(popupTarget, event));
      }
      if (this.lastHoverFeedbackElementId) {
        result.push(actions_1$c.HoverFeedbackAction.create({
          mouseoverElement: this.lastHoverFeedbackElementId,
          mouseIsOver: false
        }));
        this.lastHoverFeedbackElementId = void 0;
      }
      const hoverTarget = (0, smodel_utils_1$7.findParentByFeature)(target, model_2$8.isHoverable);
      if (hoverTarget !== void 0) {
        result.push(actions_1$c.HoverFeedbackAction.create({
          mouseoverElement: hoverTarget.id,
          mouseIsOver: true
        }));
        this.lastHoverFeedbackElementId = hoverTarget.id;
      }
    }
    return result;
  }
  mouseOut(target, event) {
    const result = [];
    if (!this.mouseIsDown) {
      const elementUnderMouse = this.getElementFromEventPosition(event);
      if (!this.isSprottyPopup(elementUnderMouse)) {
        if (this.state.popupOpen) {
          const popupTarget = (0, smodel_utils_1$7.findParent)(target, model_2$8.hasPopupFeature);
          if (this.state.previousPopupElement !== void 0 && popupTarget !== void 0 && this.state.previousPopupElement.id === popupTarget.id)
            result.push(this.startMouseOutTimer());
        }
        this.stopMouseOverTimer();
        const hoverTarget = (0, smodel_utils_1$7.findParentByFeature)(target, model_2$8.isHoverable);
        if (hoverTarget !== void 0) {
          result.push(actions_1$c.HoverFeedbackAction.create({
            mouseoverElement: hoverTarget.id,
            mouseIsOver: false
          }));
          if (this.lastHoverFeedbackElementId && this.lastHoverFeedbackElementId !== hoverTarget.id) {
            result.push(actions_1$c.HoverFeedbackAction.create({
              mouseoverElement: this.lastHoverFeedbackElementId,
              mouseIsOver: false
            }));
          }
          this.lastHoverFeedbackElementId = void 0;
        }
      }
    }
    return result;
  }
  getElementFromEventPosition(event) {
    return document.elementFromPoint(event.x, event.y);
  }
  isSprottyPopup(element) {
    return element ? element.id === this.options.popupDiv || !!element.parentElement && this.isSprottyPopup(element.parentElement) : false;
  }
  mouseMove(target, event) {
    const result = [];
    if (!this.mouseIsDown) {
      if (this.state.previousPopupElement !== void 0 && this.closeOnMouseMove(this.state.previousPopupElement, event)) {
        result.push(this.startMouseOutTimer());
      }
      const popupTarget = (0, smodel_utils_1$7.findParent)(target, model_2$8.hasPopupFeature);
      if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
        result.push(this.startMouseOverTimer(popupTarget, event));
      }
    }
    return result;
  }
  closeOnMouseMove(target, event) {
    return target instanceof smodel_1$9.SModelRootImpl;
  }
};
hover.HoverMouseListener = HoverMouseListener;
__decorate$s([(0, inversify_1$M.inject)(types_1$u.TYPES.ViewerOptions), __metadata$g("design:type", Object)], HoverMouseListener.prototype, "options", void 0);
hover.HoverMouseListener = HoverMouseListener = __decorate$s([(0, inversify_1$M.injectable)()], HoverMouseListener);
let PopupHoverMouseListener = class PopupHoverMouseListener2 extends AbstractHoverMouseListener {
  mouseOut(target, event) {
    return [this.startMouseOutTimer()];
  }
  mouseOver(target, event) {
    this.stopMouseOutTimer();
    this.stopMouseOverTimer();
    return [];
  }
};
hover.PopupHoverMouseListener = PopupHoverMouseListener;
hover.PopupHoverMouseListener = PopupHoverMouseListener = __decorate$s([(0, inversify_1$M.injectable)()], PopupHoverMouseListener);
class HoverKeyListener extends key_tool_1$3.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$3.matchesKeystroke)(event, "Escape")) {
      return [actions_1$c.SetPopupModelAction.create({
        type: smodel_factory_1$1.EMPTY_ROOT.type,
        id: smodel_factory_1$1.EMPTY_ROOT.id
      })];
    }
    return [];
  }
}
hover.HoverKeyListener = HoverKeyListener;
let ClosePopupActionHandler = class ClosePopupActionHandler2 {
  constructor() {
    this.popupOpen = false;
  }
  handle(action2) {
    if (action2.kind === SetPopupModelCommand.KIND) {
      this.popupOpen = action2.newRoot.type !== smodel_factory_1$1.EMPTY_ROOT.type;
    } else if (this.popupOpen) {
      return actions_1$c.SetPopupModelAction.create({
        id: smodel_factory_1$1.EMPTY_ROOT.id,
        type: smodel_factory_1$1.EMPTY_ROOT.type
      });
    }
  }
};
hover.ClosePopupActionHandler = ClosePopupActionHandler;
hover.ClosePopupActionHandler = ClosePopupActionHandler = __decorate$s([(0, inversify_1$M.injectable)()], ClosePopupActionHandler);
var model$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SIssue = exports.SIssueMarker = exports.SIssueMarkerImpl = exports.SDecoration = exports.isDecoration = exports.decorationFeature = void 0;
  const model_12 = model$g;
  const model_22 = model$9;
  exports.decorationFeature = Symbol("decorationFeature");
  function isDecoration(e) {
    return e.hasFeature(exports.decorationFeature);
  }
  exports.isDecoration = isDecoration;
  class SDecoration extends model_12.SShapeElementImpl {
  }
  exports.SDecoration = SDecoration;
  SDecoration.DEFAULT_FEATURES = [exports.decorationFeature, model_12.boundsFeature, model_22.hoverFeedbackFeature, model_22.popupFeature];
  class SIssueMarkerImpl extends SDecoration {
  }
  exports.SIssueMarkerImpl = SIssueMarkerImpl;
  exports.SIssueMarker = SIssueMarkerImpl;
  class SIssue {
  }
  exports.SIssue = SIssue;
})(model$3);
var views$3 = {};
var __decorate$r = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(views$3, "__esModule", {
  value: true
});
views$3.IssueMarkerView = void 0;
const jsx_1$4 = jsx;
const vnode_utils_1$7 = vnodeUtils;
const inversify_1$L = require$$0$1;
let IssueMarkerView = class IssueMarkerView2 {
  render(marker, context) {
    const scale = 16 / 1792;
    const trafo = `scale(${scale}, ${scale})`;
    const maxSeverity = this.getMaxSeverity(marker);
    const group = (0, jsx_1$4.svg)("g", {
      "class-sprotty-issue": true
    }, (0, jsx_1$4.svg)("g", {
      transform: trafo
    }, (0, jsx_1$4.svg)("path", {
      d: this.getPath(maxSeverity)
    })));
    (0, vnode_utils_1$7.setClass)(group, "sprotty-" + maxSeverity, true);
    return group;
  }
  getMaxSeverity(marker) {
    let currentSeverity = "info";
    for (const severity of marker.issues.map((s) => s.severity)) {
      if (severity === "error" || severity === "warning" && currentSeverity === "info")
        currentSeverity = severity;
    }
    return currentSeverity;
  }
  getPath(severity) {
    switch (severity) {
      case "error":
      case "warning":
        return "M768 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z";
      case "info":
        return "M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zm-128-896v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zm640 416q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z";
    }
  }
};
views$3.IssueMarkerView = IssueMarkerView;
views$3.IssueMarkerView = IssueMarkerView = __decorate$r([(0, inversify_1$L.injectable)()], IssueMarkerView);
var decorationPlacer = {};
var __decorate$q = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$f = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(decorationPlacer, "__esModule", {
  value: true
});
decorationPlacer.DecorationPlacer = void 0;
const inversify_1$K = require$$0$1;
const smodel_1$8 = smodel;
const model_1$i = model$3;
const vnode_utils_1$6 = vnodeUtils;
const model_2$7 = model$g;
const model_3$6 = model$a;
const routing_1$5 = routing;
const sprotty_protocol_1$2 = lib;
let DecorationPlacer = class DecorationPlacer2 {
  decorate(vnode2, element) {
    if ((0, model_1$i.isDecoration)(element)) {
      const position = this.getPosition(element);
      const translate = "translate(" + position.x + ", " + position.y + ")";
      (0, vnode_utils_1$6.setAttr)(vnode2, "transform", translate);
    }
    return vnode2;
  }
  getPosition(element) {
    if (element instanceof smodel_1$8.SChildElementImpl && element.parent instanceof model_3$6.SRoutableElementImpl) {
      const route = this.edgeRouterRegistry.route(element.parent);
      if (route.length > 1) {
        const index = Math.floor(0.5 * (route.length - 1));
        const offset = (0, model_2$7.isSizeable)(element) ? {
          x: -0.5 * element.bounds.width,
          y: -0.5 * element.bounds.width
        } : sprotty_protocol_1$2.Point.ORIGIN;
        return {
          x: 0.5 * (route[index].x + route[index + 1].x) + offset.x,
          y: 0.5 * (route[index].y + route[index + 1].y) + offset.y
        };
      }
    }
    if ((0, model_2$7.isSizeable)(element))
      return {
        x: -0.666 * element.bounds.width,
        y: -0.666 * element.bounds.height
      };
    return sprotty_protocol_1$2.Point.ORIGIN;
  }
  postUpdate() {
  }
};
decorationPlacer.DecorationPlacer = DecorationPlacer;
__decorate$q([(0, inversify_1$K.inject)(routing_1$5.EdgeRouterRegistry), __metadata$f("design:type", routing_1$5.EdgeRouterRegistry)], DecorationPlacer.prototype, "edgeRouterRegistry", void 0);
decorationPlacer.DecorationPlacer = DecorationPlacer = __decorate$q([(0, inversify_1$K.injectable)()], DecorationPlacer);
var intersectionFinder = {};
class TinyQueue {
  constructor(data = [], compare = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--)
        this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0)
      return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const {
      data,
      compare
    } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare(item, current) >= 0)
        break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const {
      data,
      compare
    } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare(best, item) >= 0)
        break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
const tinyqueue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TinyQueue
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(tinyqueue);
var sweepline = {};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(sweepline, "__esModule", {
  value: true
});
sweepline.intersectionOfSegments = sweepline.getSegmentIndex = sweepline.checkWhichSegmentHasRightEndpointFirst = sweepline.runSweep = sweepline.Segment = sweepline.SweepEvent = sweepline.checkWhichEventIsLeft = sweepline.addRoute = void 0;
const tinyqueue_1$1 = __importDefault$3(require$$1);
const geometry_1$c = geometry;
function addRoute(routeId, route, queue2) {
  if (route.length < 1)
    return;
  let currentPoint = route[0];
  let nextPoint = void 0;
  for (let i = 0; i < route.length - 1; i++) {
    nextPoint = route[i + 1];
    const e1 = new SweepEvent(routeId, currentPoint, i);
    const e2 = new SweepEvent(routeId, nextPoint, i + 1);
    e1.otherEvent = e2;
    e2.otherEvent = e1;
    if (checkWhichEventIsLeft(e1, e2) > 0) {
      e2.isLeftEndpoint = true;
      e1.isLeftEndpoint = false;
    } else {
      e1.isLeftEndpoint = true;
      e2.isLeftEndpoint = false;
    }
    queue2.push(e1);
    queue2.push(e2);
    currentPoint = nextPoint;
  }
}
sweepline.addRoute = addRoute;
function checkWhichEventIsLeft(e1, e2) {
  if (e1.point.x > e2.point.x)
    return 1;
  if (e1.point.x < e2.point.x)
    return -1;
  if (e1.point.y !== e2.point.y)
    return e1.point.y > e2.point.y ? 1 : -1;
  return 1;
}
sweepline.checkWhichEventIsLeft = checkWhichEventIsLeft;
class SweepEvent {
  constructor(edgeId, point, segmentIndex) {
    this.edgeId = edgeId;
    this.point = point;
    this.segmentIndex = segmentIndex;
  }
}
sweepline.SweepEvent = SweepEvent;
class Segment {
  constructor(event) {
    this.leftSweepEvent = event;
    this.rightSweepEvent = event.otherEvent;
  }
}
sweepline.Segment = Segment;
function runSweep(eventQueue) {
  const intersectionPoints = [];
  const outQueue = new tinyqueue_1$1.default([], checkWhichSegmentHasRightEndpointFirst);
  while (eventQueue.length) {
    const event = eventQueue.pop();
    if (event === null || event === void 0 ? void 0 : event.isLeftEndpoint) {
      const segment = new Segment(event);
      for (let i = 0; i < outQueue.data.length; i++) {
        const otherSegment = outQueue.data[i];
        const intersection2 = intersectionOfSegments(segment, otherSegment);
        if (intersection2) {
          intersectionPoints.push({
            routable1: event.edgeId,
            routable2: otherSegment.leftSweepEvent.edgeId,
            segmentIndex1: getSegmentIndex(segment),
            segmentIndex2: getSegmentIndex(otherSegment),
            intersectionPoint: intersection2
          });
        }
      }
      outQueue.push(segment);
    } else if ((event === null || event === void 0 ? void 0 : event.isLeftEndpoint) === false) {
      outQueue.pop();
    }
  }
  return intersectionPoints;
}
sweepline.runSweep = runSweep;
function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
  if (seg1.rightSweepEvent.point.x > seg2.rightSweepEvent.point.x)
    return 1;
  if (seg1.rightSweepEvent.point.x < seg2.rightSweepEvent.point.x)
    return -1;
  if (seg1.rightSweepEvent.point.y !== seg2.rightSweepEvent.point.y)
    return seg1.rightSweepEvent.point.y < seg2.rightSweepEvent.point.y ? 1 : -1;
  return 1;
}
sweepline.checkWhichSegmentHasRightEndpointFirst = checkWhichSegmentHasRightEndpointFirst;
function getSegmentIndex(segment) {
  return Math.min(segment.leftSweepEvent.segmentIndex, segment.rightSweepEvent.segmentIndex);
}
sweepline.getSegmentIndex = getSegmentIndex;
function intersectionOfSegments(seg1, seg2) {
  if (seg1.leftSweepEvent.edgeId === seg2.leftSweepEvent.edgeId) {
    return void 0;
  }
  const seg1Line = new geometry_1$c.PointToPointLine(seg1.leftSweepEvent.point, seg1.rightSweepEvent.point);
  const seg2Line = new geometry_1$c.PointToPointLine(seg2.leftSweepEvent.point, seg2.rightSweepEvent.point);
  return seg1Line.intersection(seg2Line);
}
sweepline.intersectionOfSegments = intersectionOfSegments;
var __decorate$p = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(intersectionFinder, "__esModule", {
  value: true
});
intersectionFinder.IntersectionFinder = intersectionFinder.BY_DESCENDING_X_THEN_DESCENDING_Y = intersectionFinder.BY_X_THEN_DESCENDING_Y = intersectionFinder.BY_DESCENDING_X_THEN_Y = intersectionFinder.BY_X_THEN_Y = intersectionFinder.isIntersectingRoutedPoint = void 0;
const inversify_1$J = require$$0$1;
const tinyqueue_1 = __importDefault$2(require$$1);
const sweepline_1 = sweepline;
function isIntersectingRoutedPoint(routedPoint) {
  return routedPoint !== void 0 && "intersections" in routedPoint && "kind" in routedPoint;
}
intersectionFinder.isIntersectingRoutedPoint = isIntersectingRoutedPoint;
const BY_X_THEN_Y = (a, b) => {
  if (a.intersectionPoint.x === b.intersectionPoint.x) {
    return a.intersectionPoint.y - b.intersectionPoint.y;
  }
  return a.intersectionPoint.x - b.intersectionPoint.x;
};
intersectionFinder.BY_X_THEN_Y = BY_X_THEN_Y;
const BY_DESCENDING_X_THEN_Y = (a, b) => {
  if (a.intersectionPoint.x === b.intersectionPoint.x) {
    return a.intersectionPoint.y - b.intersectionPoint.y;
  }
  return b.intersectionPoint.x - a.intersectionPoint.x;
};
intersectionFinder.BY_DESCENDING_X_THEN_Y = BY_DESCENDING_X_THEN_Y;
const BY_X_THEN_DESCENDING_Y = (a, b) => {
  if (a.intersectionPoint.x === b.intersectionPoint.x) {
    return b.intersectionPoint.y - a.intersectionPoint.y;
  }
  return a.intersectionPoint.x - b.intersectionPoint.x;
};
intersectionFinder.BY_X_THEN_DESCENDING_Y = BY_X_THEN_DESCENDING_Y;
const BY_DESCENDING_X_THEN_DESCENDING_Y = (a, b) => {
  if (a.intersectionPoint.x === b.intersectionPoint.x) {
    return b.intersectionPoint.y - a.intersectionPoint.y;
  }
  return b.intersectionPoint.x - a.intersectionPoint.x;
};
intersectionFinder.BY_DESCENDING_X_THEN_DESCENDING_Y = BY_DESCENDING_X_THEN_DESCENDING_Y;
let IntersectionFinder = class IntersectionFinder2 {
  /**
   * Finds all intersections in the specified `routing` and replaces the `RoutedPoints` that are
   * intersecting by adding intersection information to routing points (@see `IntersectingRoutedPoints`).
   * @param routing the edge routing to find intersections for and update.
   */
  apply(routing2) {
    const intersections = this.find(routing2);
    this.addToRouting(intersections, routing2);
  }
  /**
   * Finds the intersections in the specified `routing` and returns them.
   * @param routing the edge routing to find intersections for and update.
   * @returns the identified intersections.
   */
  find(routing2) {
    const eventQueue = new tinyqueue_1.default(void 0, sweepline_1.checkWhichEventIsLeft);
    routing2.routes.forEach((route, routeId) => {
      if (this.isSupportedRoute(route)) {
        (0, sweepline_1.addRoute)(routeId, route, eventQueue);
      }
    });
    return (0, sweepline_1.runSweep)(eventQueue);
  }
  /**
   * Specifies whether or not a specific route should be included in this intersection search or not.
   *
   * As this intersection finder only supports linear line segments, this method only returns `true`
   * for routes that only contain routed points, which are either 'source', 'target' or 'linear'.
   */
  isSupportedRoute(route) {
    return route.find((point) => point.kind !== "source" && point.kind !== "target" && point.kind !== "linear") === void 0;
  }
  addToRouting(intersections, routing2) {
    for (const intersection2 of intersections) {
      const routable1 = routing2.get(intersection2.routable1);
      const routable2 = routing2.get(intersection2.routable2);
      this.addIntersectionToRoutedPoint(intersection2, routable1, intersection2.segmentIndex1);
      this.addIntersectionToRoutedPoint(intersection2, routable2, intersection2.segmentIndex2);
    }
  }
  addIntersectionToRoutedPoint(intersection2, routedPoint, segmentIndex) {
    if (routedPoint && routedPoint.length > segmentIndex) {
      const segment = routedPoint[segmentIndex + 1];
      if (isIntersectingRoutedPoint(segment)) {
        segment.intersections.push(intersection2);
      } else {
        const intersectingRoutedPoint = Object.assign(Object.assign({}, segment), {
          intersections: [intersection2]
        });
        routedPoint[segmentIndex + 1] = intersectingRoutedPoint;
      }
    }
  }
};
intersectionFinder.IntersectionFinder = IntersectionFinder;
intersectionFinder.IntersectionFinder = IntersectionFinder = __decorate$p([(0, inversify_1$J.injectable)()], IntersectionFinder);
var junctionFinder = {};
var __decorate$o = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(junctionFinder, "__esModule", {
  value: true
});
junctionFinder.JunctionFinder = void 0;
const inversify_1$I = require$$0$1;
const sgraph_1$2 = sgraph;
let JunctionFinder = class JunctionFinder2 {
  constructor() {
    this.edgesMap = /* @__PURE__ */ new Map();
    this.sourcesMap = /* @__PURE__ */ new Map();
    this.targetsMap = /* @__PURE__ */ new Map();
  }
  apply(routing2, parent) {
    this.findJunctions(routing2, parent);
  }
  findJunctions(routing2, parent) {
    const edges = Array.from(parent.index.all().filter((child) => child instanceof sgraph_1$2.SEdgeImpl));
    edges.forEach((edge) => {
      this.edgesMap.set(edge.id, edge);
      const sameSources = this.sourcesMap.get(edge.sourceId);
      if (sameSources) {
        sameSources.add(edge.id);
      } else {
        this.sourcesMap.set(edge.sourceId, /* @__PURE__ */ new Set([edge.id]));
      }
      const sameTargets = this.targetsMap.get(edge.targetId);
      if (sameTargets) {
        sameTargets.add(edge.id);
      } else {
        this.targetsMap.set(edge.targetId, /* @__PURE__ */ new Set([edge.id]));
      }
    });
    routing2.routes.forEach((route, routeId) => {
      const edge = this.edgesMap.get(routeId);
      if (!edge) {
        return;
      }
      this.findJunctionPointsWithSameSource(edge, route, routing2);
      this.findJunctionPointsWithSameTarget(edge, route, routing2);
    });
  }
  /**
   * Finds the junction points of routes with the same source
   */
  findJunctionPointsWithSameSource(edge, route, routing2) {
    const sourcesSet = this.sourcesMap.get(edge.sourceId);
    if (!sourcesSet) {
      return;
    }
    const otherRoutesIds = Array.from(sourcesSet).filter((id2) => id2 !== edge.id);
    const otherRoutes = otherRoutesIds.map((id2) => routing2.get(id2)).filter((r) => r !== void 0);
    for (const otherRoute of otherRoutes) {
      const junctionIndex = this.getJunctionIndex(route, otherRoute);
      if (junctionIndex === -1 || junctionIndex === 0) {
        continue;
      }
      this.setJunctionPoints(route, otherRoute, junctionIndex);
    }
  }
  /**
   * Finds the junction points of routes with the same target
   */
  findJunctionPointsWithSameTarget(edge, route, routing2) {
    const targetsSet = this.targetsMap.get(edge.targetId);
    if (!targetsSet) {
      return;
    }
    const otherRoutesIds = Array.from(targetsSet).filter((id2) => id2 !== edge.id);
    const otherRoutes = otherRoutesIds.map((id2) => routing2.get(id2)).filter((r) => r !== void 0);
    route.reverse();
    for (const otherRoute of otherRoutes) {
      otherRoute.reverse();
      const junctionIndex = this.getJunctionIndex(route, otherRoute);
      if (junctionIndex === -1 || junctionIndex === 0) {
        continue;
      }
      this.setJunctionPoints(route, otherRoute, junctionIndex);
      otherRoute.reverse();
    }
    route.reverse();
  }
  /**
   * Set the junction points of two routes according to the segments direction.
   * If the segments have different directions, the junction point is the previous common point.
   * If the segments have the same direction, the junction point is the point with the greatest or lowest value axis value depending on the direction.
   */
  setJunctionPoints(route, otherRoute, junctionIndex) {
    const firstSegmentDirection = this.getSegmentDirection(route[junctionIndex - 1], route[junctionIndex]);
    const secondSegmentDirection = this.getSegmentDirection(otherRoute[junctionIndex - 1], otherRoute[junctionIndex]);
    if (firstSegmentDirection !== secondSegmentDirection) {
      this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
    } else {
      if (firstSegmentDirection === "left" || firstSegmentDirection === "right") {
        if (route[junctionIndex].y !== otherRoute[junctionIndex].y) {
          this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
          return;
        }
        route[junctionIndex].isJunction = firstSegmentDirection === "left" ? route[junctionIndex].x > otherRoute[junctionIndex].x : route[junctionIndex].x < otherRoute[junctionIndex].x;
        otherRoute[junctionIndex].isJunction = firstSegmentDirection === "left" ? otherRoute[junctionIndex].x > route[junctionIndex].x : otherRoute[junctionIndex].x < route[junctionIndex].x;
      } else {
        if (route[junctionIndex].x !== otherRoute[junctionIndex].x) {
          this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
          return;
        }
        route[junctionIndex].isJunction = firstSegmentDirection === "up" ? route[junctionIndex].y > otherRoute[junctionIndex].y : route[junctionIndex].y < otherRoute[junctionIndex].y;
        otherRoute[junctionIndex].isJunction = firstSegmentDirection === "up" ? otherRoute[junctionIndex].y > route[junctionIndex].y : otherRoute[junctionIndex].y < route[junctionIndex].y;
      }
    }
  }
  /**
   * Set the previous point as a junction point.
   * This is used when two segments have the same direction but the other axis is different.
   * For example if the routes are going in opposite directions, or if the route don't split orthogonally.
   */
  setPreviousPointAsJunction(route, sameSourceRoute, junctionIndex) {
    route[junctionIndex - 1].isJunction = true;
    sameSourceRoute[junctionIndex - 1].isJunction = true;
  }
  /**
   * Get the main direction of a segment.
   * The main direction is the axis with the greatest difference between the two points.
   */
  getSegmentDirection(firstPoint, secondPoint) {
    const dX = secondPoint.x - firstPoint.x;
    const dY = secondPoint.y - firstPoint.y;
    let mainDirection = "horizontal";
    if (Math.abs(dX) < Math.abs(dY)) {
      mainDirection = "vertical";
    }
    if (mainDirection === "horizontal") {
      if (dX > 0) {
        return "right";
      } else {
        return "left";
      }
    } else {
      if (dY > 0) {
        return "down";
      } else {
        return "up";
      }
    }
  }
  /**
   * Finds the index where two routes diverge.
   * Returns -1 if no divergence can be found.
   */
  getJunctionIndex(firstRoute, secondRoute) {
    let idx = 0;
    while (idx < firstRoute.length && idx < secondRoute.length) {
      if (firstRoute[idx].x !== secondRoute[idx].x || firstRoute[idx].y !== secondRoute[idx].y) {
        return idx;
      }
      idx++;
    }
    return -1;
  }
};
junctionFinder.JunctionFinder = JunctionFinder;
junctionFinder.JunctionFinder = JunctionFinder = __decorate$o([(0, inversify_1$I.injectable)()], JunctionFinder);
var move = {};
var __decorate$n = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$e = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$6 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MoveCommand_1;
Object.defineProperty(move, "__esModule", {
  value: true
});
move.LocationPostprocessor = move.MoveMouseListener = move.MorphEdgesAnimation = move.MoveAnimation = move.MoveCommand = void 0;
const inversify_1$H = require$$0$1;
const geometry_1$b = geometry$1;
const actions_1$b = actions;
const animation_1$3 = animation;
const command_1$7 = command;
const smodel_1$7 = smodel;
const smodel_utils_1$6 = smodelUtils;
const types_1$t = types;
const mouse_tool_1$4 = mouseTool;
const vnode_utils_1$5 = vnodeUtils;
const sgraph_1$1 = sgraph;
const commit_model_1$1 = commitModel;
const model_1$h = model$g;
const create_on_drag_1 = createOnDrag;
const edit_routing_1$1 = editRouting;
const reconnect_1 = reconnect;
const model_2$6 = model$a;
const routing_1$4 = routing;
const model_3$5 = model$b;
const model_4$3 = model$c;
const model_5$1 = model$6;
const model_6$1 = model$8;
let MoveCommand = MoveCommand_1 = class MoveCommand2 extends command_1$7.MergeableCommand {
  constructor(action2) {
    super();
    this.action = action2;
    this.resolvedMoves = /* @__PURE__ */ new Map();
    this.edgeMementi = [];
    this.stoppableCommandKey = MoveCommand_1.KIND;
  }
  // stop the execution of the CompoundAnimation started below
  stopExecution() {
    if (this.animation) {
      this.animation.stop();
      this.animation = void 0;
    }
  }
  execute(context) {
    const index = context.root.index;
    const edge2handleMoves = /* @__PURE__ */ new Map();
    const attachedEdgeShifts = /* @__PURE__ */ new Map();
    this.action.moves.forEach((move2) => {
      const element = index.getById(move2.elementId);
      if (element instanceof model_2$6.SRoutingHandleImpl && this.edgeRouterRegistry) {
        const edge = element.parent;
        if (edge instanceof model_2$6.SRoutableElementImpl) {
          const resolvedMove = this.resolveHandleMove(element, edge, move2);
          if (resolvedMove) {
            let movesByEdge = edge2handleMoves.get(edge);
            if (!movesByEdge) {
              movesByEdge = [];
              edge2handleMoves.set(edge, movesByEdge);
            }
            movesByEdge.push(resolvedMove);
          }
        }
      } else if (element && (0, model_6$1.isLocateable)(element)) {
        const resolvedMove = this.resolveElementMove(element, move2);
        if (resolvedMove) {
          this.resolvedMoves.set(resolvedMove.element.id, resolvedMove);
          if (this.edgeRouterRegistry) {
            const handleEdges = (el2) => {
              index.getAttachedElements(el2).forEach((edge) => {
                if (edge instanceof model_2$6.SRoutableElementImpl && !this.isChildOfMovedElements(edge)) {
                  const existingDelta = attachedEdgeShifts.get(edge);
                  const newDelta = geometry_1$b.Point.subtract(resolvedMove.toPosition, resolvedMove.fromPosition);
                  const delta = existingDelta ? geometry_1$b.Point.linear(existingDelta, newDelta, 0.5) : newDelta;
                  attachedEdgeShifts.set(edge, delta);
                }
              });
            };
            const handleEdgesForChildren = (el2) => {
              if ((0, smodel_1$7.isParent)(el2)) {
                el2.children.forEach((childEl) => {
                  if (childEl instanceof smodel_1$7.SModelElementImpl) {
                    if (childEl instanceof model_2$6.SConnectableElementImpl) {
                      handleEdges(childEl);
                    }
                    handleEdgesForChildren(childEl);
                  }
                });
              }
            };
            handleEdgesForChildren(element);
            handleEdges(element);
          }
        }
      }
    });
    this.doMove(edge2handleMoves, attachedEdgeShifts);
    if (this.action.animate) {
      this.undoMove();
      return (this.animation = new animation_1$3.CompoundAnimation(context.root, context, [new MoveAnimation(context.root, this.resolvedMoves, context, false), new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)])).start();
    }
    return context.root;
  }
  resolveHandleMove(handle, edge, move2) {
    let fromPosition = move2.fromPosition;
    if (!fromPosition) {
      const router = this.edgeRouterRegistry.get(edge.routerKind);
      fromPosition = router.getHandlePosition(edge, router.route(edge), handle);
    }
    if (fromPosition)
      return {
        handle,
        fromPosition,
        toPosition: move2.toPosition
      };
    return void 0;
  }
  resolveElementMove(element, move2) {
    const fromPosition = move2.fromPosition || {
      x: element.position.x,
      y: element.position.y
    };
    return {
      element,
      fromPosition,
      toPosition: move2.toPosition
    };
  }
  doMove(edge2move, attachedEdgeShifts) {
    this.resolvedMoves.forEach((res) => {
      res.element.position = res.toPosition;
    });
    edge2move.forEach((moves, edge) => {
      const router = this.edgeRouterRegistry.get(edge.routerKind);
      const before = router.takeSnapshot(edge);
      router.applyHandleMoves(edge, moves);
      const after = router.takeSnapshot(edge);
      this.edgeMementi.push({
        edge,
        before,
        after
      });
    });
    attachedEdgeShifts.forEach((delta, edge) => {
      if (!edge2move.get(edge)) {
        const router = this.edgeRouterRegistry.get(edge.routerKind);
        const before = router.takeSnapshot(edge);
        if (this.isAttachedEdge(edge)) {
          edge.routingPoints = edge.routingPoints.map((rp) => geometry_1$b.Point.add(rp, delta));
        } else {
          const updateHandles = (0, model_4$3.isSelectable)(edge) && edge.selected;
          router.cleanupRoutingPoints(edge, edge.routingPoints, updateHandles, this.action.finished);
        }
        const after = router.takeSnapshot(edge);
        this.edgeMementi.push({
          edge,
          before,
          after
        });
      }
    });
  }
  isChildOfMovedElements(el2) {
    const parent = el2.parent;
    if (Array.from(this.resolvedMoves.values()).map((rm) => rm.element.id).includes(parent.id)) {
      return true;
    }
    if (parent instanceof smodel_1$7.SChildElementImpl) {
      return this.isChildOfMovedElements(parent);
    }
    return false;
  }
  // tests if the edge is attached to the moved element directly or to on of their children
  isAttachedEdge(edge) {
    const source = edge.source;
    const target = edge.target;
    const checkMovedElementsAndChildren = (sourceOrTarget) => {
      return Boolean(this.resolvedMoves.get(sourceOrTarget.id)) || this.isChildOfMovedElements(sourceOrTarget);
    };
    return Boolean(source && target && checkMovedElementsAndChildren(source) && checkMovedElementsAndChildren(target));
  }
  undoMove() {
    this.resolvedMoves.forEach((res) => {
      res.element.position = res.fromPosition;
    });
    this.edgeMementi.forEach((memento) => {
      const router = this.edgeRouterRegistry.get(memento.edge.routerKind);
      router.applySnapshot(memento.edge, memento.before);
    });
  }
  undo(context) {
    return new animation_1$3.CompoundAnimation(context.root, context, [new MoveAnimation(context.root, this.resolvedMoves, context, true), new MorphEdgesAnimation(context.root, this.edgeMementi, context, true)]).start();
  }
  redo(context) {
    return new animation_1$3.CompoundAnimation(context.root, context, [new MoveAnimation(context.root, this.resolvedMoves, context, false), new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)]).start();
  }
  merge(other, context) {
    if (!this.action.animate && other instanceof MoveCommand_1) {
      other.resolvedMoves.forEach((otherMove, otherElementId) => {
        const existingMove = this.resolvedMoves.get(otherElementId);
        if (existingMove) {
          existingMove.toPosition = otherMove.toPosition;
        } else {
          this.resolvedMoves.set(otherElementId, otherMove);
        }
      });
      other.edgeMementi.forEach((otherMemento) => {
        const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
        if (existingMemento) {
          existingMemento.after = otherMemento.after;
        } else {
          this.edgeMementi.push(otherMemento);
        }
      });
      return true;
    } else if (other instanceof reconnect_1.ReconnectCommand) {
      const otherMemento = other.memento;
      if (otherMemento) {
        const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
        if (existingMemento) {
          existingMemento.after = otherMemento.after;
        } else {
          this.edgeMementi.push(otherMemento);
        }
      }
      return true;
    }
    return false;
  }
};
move.MoveCommand = MoveCommand;
MoveCommand.KIND = actions_1$b.MoveAction.KIND;
__decorate$n([(0, inversify_1$H.inject)(routing_1$4.EdgeRouterRegistry), (0, inversify_1$H.optional)(), __metadata$e("design:type", routing_1$4.EdgeRouterRegistry)], MoveCommand.prototype, "edgeRouterRegistry", void 0);
move.MoveCommand = MoveCommand = MoveCommand_1 = __decorate$n([(0, inversify_1$H.injectable)(), __param$6(0, (0, inversify_1$H.inject)(types_1$t.TYPES.Action)), __metadata$e("design:paramtypes", [Object])], MoveCommand);
class MoveAnimation extends animation_1$3.Animation {
  constructor(model2, elementMoves, context, reverse = false) {
    super(context);
    this.model = model2;
    this.elementMoves = elementMoves;
    this.reverse = reverse;
  }
  tween(t) {
    this.elementMoves.forEach((elementMove) => {
      if (this.reverse) {
        elementMove.element.position = {
          x: (1 - t) * elementMove.toPosition.x + t * elementMove.fromPosition.x,
          y: (1 - t) * elementMove.toPosition.y + t * elementMove.fromPosition.y
        };
      } else {
        elementMove.element.position = {
          x: (1 - t) * elementMove.fromPosition.x + t * elementMove.toPosition.x,
          y: (1 - t) * elementMove.fromPosition.y + t * elementMove.toPosition.y
        };
      }
    });
    return this.model;
  }
}
move.MoveAnimation = MoveAnimation;
class MorphEdgesAnimation extends animation_1$3.Animation {
  constructor(model2, originalMementi, context, reverse = false) {
    super(context);
    this.model = model2;
    this.reverse = reverse;
    this.expanded = [];
    originalMementi.forEach((edgeMemento) => {
      const start = this.reverse ? edgeMemento.after : edgeMemento.before;
      const end = this.reverse ? edgeMemento.before : edgeMemento.after;
      const startRoute = start.routedPoints;
      const endRoute = end.routedPoints;
      const maxRoutingPoints = Math.max(startRoute.length, endRoute.length);
      this.expanded.push({
        startExpandedRoute: this.growToSize(startRoute, maxRoutingPoints),
        endExpandedRoute: this.growToSize(endRoute, maxRoutingPoints),
        memento: edgeMemento
      });
    });
  }
  midPoint(edgeMemento) {
    const edge = edgeMemento.edge;
    const source = edgeMemento.edge.source;
    const target = edgeMemento.edge.target;
    return geometry_1$b.Point.linear((0, smodel_utils_1$6.translatePoint)(geometry_1$b.Bounds.center(source.bounds), source.parent, edge.parent), (0, smodel_utils_1$6.translatePoint)(geometry_1$b.Bounds.center(target.bounds), target.parent, edge.parent), 0.5);
  }
  start() {
    this.expanded.forEach((morph) => {
      morph.memento.edge.removeAll((e) => e instanceof model_2$6.SRoutingHandleImpl);
    });
    return super.start();
  }
  tween(t) {
    if (t === 1) {
      this.expanded.forEach((morph) => {
        const memento = morph.memento;
        if (this.reverse)
          memento.before.router.applySnapshot(memento.edge, memento.before);
        else
          memento.after.router.applySnapshot(memento.edge, memento.after);
      });
    } else {
      this.expanded.forEach((morph) => {
        const newRoutingPoints = [];
        for (let i = 1; i < morph.startExpandedRoute.length - 1; ++i)
          newRoutingPoints.push(geometry_1$b.Point.linear(morph.startExpandedRoute[i], morph.endExpandedRoute[i], t));
        const closestSnapshot = t < 0.5 ? morph.memento.before : morph.memento.after;
        const newSnapshot = Object.assign(Object.assign({}, closestSnapshot), {
          routingPoints: newRoutingPoints,
          routingHandles: []
        });
        closestSnapshot.router.applySnapshot(morph.memento.edge, newSnapshot);
      });
    }
    return this.model;
  }
  growToSize(route, targetSize) {
    const diff = targetSize - route.length;
    if (diff <= 0)
      return route;
    const result = [];
    result.push(route[0]);
    const deltaDiff = 1 / (diff + 1);
    const deltaSmaller = 1 / (route.length - 1);
    let nextInsertion = 1;
    for (let i = 1; i < route.length; ++i) {
      const pos = deltaSmaller * i;
      let insertions = 0;
      while (pos > (nextInsertion + insertions) * deltaDiff)
        ++insertions;
      nextInsertion += insertions;
      for (let j = 0; j < insertions; ++j) {
        const p2 = geometry_1$b.Point.linear(route[i - 1], route[i], (j + 1) / (insertions + 1));
        result.push(p2);
      }
      result.push(route[i]);
    }
    return result;
  }
}
move.MorphEdgesAnimation = MorphEdgesAnimation;
class MoveMouseListener extends mouse_tool_1$4.MouseListener {
  constructor() {
    super(...arguments);
    this.hasDragged = false;
    this.elementId2startPos = /* @__PURE__ */ new Map();
  }
  mouseDown(target, event) {
    if (event.button === 0) {
      const moveable = (0, smodel_utils_1$6.findParentByFeature)(target, model_6$1.isMoveable);
      const isRoutingHandle = target instanceof model_2$6.SRoutingHandleImpl;
      if (moveable !== void 0 || isRoutingHandle || (0, create_on_drag_1.isCreatingOnDrag)(target)) {
        this.startDragPosition = {
          x: event.pageX,
          y: event.pageY
        };
      } else {
        this.startDragPosition = void 0;
      }
      this.hasDragged = false;
      if ((0, create_on_drag_1.isCreatingOnDrag)(target)) {
        return this.startCreatingOnDrag(target, event);
      } else if (isRoutingHandle) {
        return this.activateRoutingHandle(target, event);
      }
    }
    return [];
  }
  startCreatingOnDrag(target, event) {
    const result = [];
    result.push(actions_1$b.SelectAllAction.create({
      select: false
    }));
    result.push(target.createAction(model_2$6.edgeInProgressID));
    result.push(actions_1$b.SelectAction.create({
      selectedElementsIDs: [model_2$6.edgeInProgressID]
    }));
    result.push(edit_routing_1$1.SwitchEditModeAction.create({
      elementsToActivate: [model_2$6.edgeInProgressID]
    }));
    result.push(actions_1$b.SelectAction.create({
      selectedElementsIDs: [model_2$6.edgeInProgressTargetHandleID]
    }));
    result.push(edit_routing_1$1.SwitchEditModeAction.create({
      elementsToActivate: [model_2$6.edgeInProgressTargetHandleID]
    }));
    return result;
  }
  activateRoutingHandle(target, event) {
    return [edit_routing_1$1.SwitchEditModeAction.create({
      elementsToActivate: [target.id]
    })];
  }
  mouseMove(target, event) {
    const result = [];
    if (event.buttons === 0)
      this.mouseUp(target, event);
    else if (this.startDragPosition) {
      if (this.elementId2startPos.size === 0) {
        this.collectStartPositions(target.root);
      }
      this.hasDragged = true;
      const moveAction = this.getElementMoves(target, event, false);
      if (moveAction)
        result.push(moveAction);
    }
    return result;
  }
  collectStartPositions(root) {
    const selectedElements = new Set(root.index.all().filter((element) => (0, model_4$3.isSelectable)(element) && element.selected));
    selectedElements.forEach((element) => {
      if (!this.isChildOfSelected(selectedElements, element)) {
        if ((0, model_6$1.isMoveable)(element))
          this.elementId2startPos.set(element.id, element.position);
        else if (element instanceof model_2$6.SRoutingHandleImpl) {
          const position = this.getHandlePosition(element);
          if (position)
            this.elementId2startPos.set(element.id, position);
        }
      }
    });
  }
  isChildOfSelected(selectedElements, element) {
    while (element instanceof smodel_1$7.SChildElementImpl) {
      element = element.parent;
      if ((0, model_6$1.isMoveable)(element) && selectedElements.has(element)) {
        return true;
      }
    }
    return false;
  }
  getElementMoves(target, event, isFinished) {
    if (!this.startDragPosition)
      return void 0;
    const elementMoves = [];
    const viewport2 = (0, smodel_utils_1$6.findParentByFeature)(target, model_5$1.isViewport);
    const zoom2 = viewport2 ? viewport2.zoom : 1;
    const delta = {
      x: (event.pageX - this.startDragPosition.x) / zoom2,
      y: (event.pageY - this.startDragPosition.y) / zoom2
    };
    this.elementId2startPos.forEach((startPosition, elementId) => {
      const element = target.root.index.getById(elementId);
      if (element) {
        const move2 = this.createElementMove(element, startPosition, delta, event);
        if (move2) {
          elementMoves.push(move2);
        }
      }
    });
    if (elementMoves.length > 0)
      return actions_1$b.MoveAction.create(elementMoves, {
        animate: false,
        finished: isFinished
      });
    else
      return void 0;
  }
  createElementMove(element, startPosition, delta, event) {
    const toPosition = this.snap({
      x: startPosition.x + delta.x,
      y: startPosition.y + delta.y
    }, element, !event.shiftKey);
    if ((0, model_6$1.isMoveable)(element)) {
      return {
        elementId: element.id,
        elementType: element.type,
        fromPosition: {
          x: element.position.x,
          y: element.position.y
        },
        toPosition
      };
    } else if (element instanceof model_2$6.SRoutingHandleImpl) {
      const point = this.getHandlePosition(element);
      if (point !== void 0) {
        return {
          elementId: element.id,
          elementType: element.type,
          fromPosition: point,
          toPosition
        };
      }
    }
    return void 0;
  }
  snap(position, element, isSnap) {
    if (isSnap && this.snapper)
      return this.snapper.snap(position, element);
    else
      return position;
  }
  getHandlePosition(handle) {
    if (this.edgeRouterRegistry) {
      const parent = handle.parent;
      if (!(parent instanceof model_2$6.SRoutableElementImpl))
        return void 0;
      const router = this.edgeRouterRegistry.get(parent.routerKind);
      const route = router.route(parent);
      return router.getHandlePosition(parent, route, handle);
    }
    return void 0;
  }
  mouseEnter(target, event) {
    if (target instanceof smodel_1$7.SModelRootImpl && event.buttons === 0 && !this.startDragPosition)
      this.mouseUp(target, event);
    return [];
  }
  mouseUp(target, event) {
    const result = [];
    if (this.startDragPosition) {
      const moveAction = this.getElementMoves(target, event, true);
      if (moveAction) {
        result.push(moveAction);
      }
      target.root.index.all().forEach((element) => {
        if (element instanceof model_2$6.SRoutingHandleImpl) {
          result.push(...this.deactivateRoutingHandle(element, target, event));
        }
      });
    }
    if (!result.some((a) => a.kind === actions_1$b.ReconnectAction.KIND)) {
      const edgeInProgress = target.root.index.getById(model_2$6.edgeInProgressID);
      if (edgeInProgress instanceof smodel_1$7.SChildElementImpl) {
        result.push(this.deleteEdgeInProgress(edgeInProgress));
      }
    }
    if (this.hasDragged) {
      result.push(commit_model_1$1.CommitModelAction.create());
    }
    this.hasDragged = false;
    this.startDragPosition = void 0;
    this.elementId2startPos.clear();
    return result;
  }
  deactivateRoutingHandle(element, target, event) {
    const result = [];
    const parent = element.parent;
    if (parent instanceof model_2$6.SRoutableElementImpl && element.danglingAnchor) {
      const handlePos = this.getHandlePosition(element);
      if (handlePos) {
        const handlePosAbs = (0, smodel_utils_1$6.translatePoint)(handlePos, element.parent, element.root);
        const newEnd = (0, model_1$h.findChildrenAtPosition)(target.root, handlePosAbs).find((e) => (0, model_2$6.isConnectable)(e) && e.canConnect(parent, element.kind));
        if (newEnd && this.hasDragged) {
          result.push(actions_1$b.ReconnectAction.create({
            routableId: element.parent.id,
            newSourceId: element.kind === "source" ? newEnd.id : parent.sourceId,
            newTargetId: element.kind === "target" ? newEnd.id : parent.targetId
          }));
        }
      }
    }
    if (element.editMode) {
      result.push(edit_routing_1$1.SwitchEditModeAction.create({
        elementsToDeactivate: [element.id]
      }));
    }
    return result;
  }
  deleteEdgeInProgress(edgeInProgress) {
    const deleteIds = [];
    deleteIds.push(model_2$6.edgeInProgressID);
    edgeInProgress.children.forEach((c) => {
      if (c instanceof model_2$6.SRoutingHandleImpl && c.danglingAnchor)
        deleteIds.push(c.danglingAnchor.id);
    });
    return actions_1$b.DeleteElementAction.create(deleteIds);
  }
  decorate(vnode2, element) {
    return vnode2;
  }
}
move.MoveMouseListener = MoveMouseListener;
__decorate$n([(0, inversify_1$H.inject)(routing_1$4.EdgeRouterRegistry), (0, inversify_1$H.optional)(), __metadata$e("design:type", routing_1$4.EdgeRouterRegistry)], MoveMouseListener.prototype, "edgeRouterRegistry", void 0);
__decorate$n([(0, inversify_1$H.inject)(types_1$t.TYPES.ISnapper), (0, inversify_1$H.optional)(), __metadata$e("design:type", Object)], MoveMouseListener.prototype, "snapper", void 0);
let LocationPostprocessor = class LocationPostprocessor2 {
  decorate(vnode2, element) {
    if ((0, model_3$5.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1$1.SEdgeImpl) {
      return vnode2;
    }
    let translate = "";
    if ((0, model_6$1.isLocateable)(element) && element instanceof smodel_1$7.SChildElementImpl && element.parent !== void 0) {
      const pos = element.position;
      if (pos.x !== 0 || pos.y !== 0) {
        translate = "translate(" + pos.x + ", " + pos.y + ")";
      }
    }
    if ((0, model_1$h.isAlignable)(element)) {
      const ali = element.alignment;
      if (ali.x !== 0 || ali.y !== 0) {
        if (translate.length > 0) {
          translate += " ";
        }
        translate += "translate(" + ali.x + ", " + ali.y + ")";
      }
    }
    if (translate.length > 0) {
      (0, vnode_utils_1$5.setAttr)(vnode2, "transform", translate);
    }
    return vnode2;
  }
  postUpdate() {
  }
};
move.LocationPostprocessor = LocationPostprocessor;
move.LocationPostprocessor = LocationPostprocessor = __decorate$n([(0, inversify_1$H.injectable)()], LocationPostprocessor);
var snap = {};
var __decorate$m = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(snap, "__esModule", {
  value: true
});
snap.CenterGridSnapper = void 0;
const inversify_1$G = require$$0$1;
const model_1$g = model$g;
let CenterGridSnapper = class CenterGridSnapper2 {
  get gridX() {
    return 10;
  }
  get gridY() {
    return 10;
  }
  snap(position, element) {
    if (element && (0, model_1$g.isBoundsAware)(element))
      return {
        x: Math.round((position.x + 0.5 * element.bounds.width) / this.gridX) * this.gridX - 0.5 * element.bounds.width,
        y: Math.round((position.y + 0.5 * element.bounds.height) / this.gridY) * this.gridY - 0.5 * element.bounds.height
      };
    else
      return {
        x: Math.round(position.x / this.gridX) * this.gridX,
        y: Math.round(position.y / this.gridY) * this.gridY
      };
  }
};
snap.CenterGridSnapper = CenterGridSnapper;
snap.CenterGridSnapper = CenterGridSnapper = __decorate$m([(0, inversify_1$G.injectable)()], CenterGridSnapper);
var open$1 = {};
var model$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isOpenable = exports.openFeature = void 0;
  exports.openFeature = Symbol("openFeature");
  function isOpenable(element) {
    return element.hasFeature(exports.openFeature);
  }
  exports.isOpenable = isOpenable;
})(model$2);
Object.defineProperty(open$1, "__esModule", {
  value: true
});
open$1.OpenMouseListener = void 0;
const actions_1$a = actions;
const mouse_tool_1$3 = mouseTool;
const smodel_utils_1$5 = smodelUtils;
const model_1$f = model$2;
class OpenMouseListener extends mouse_tool_1$3.MouseListener {
  doubleClick(target, event) {
    const openableTarget = (0, smodel_utils_1$5.findParentByFeature)(target, model_1$f.isOpenable);
    if (openableTarget !== void 0) {
      return [actions_1$a.OpenAction.create(openableTarget.id)];
    }
    return [];
  }
}
open$1.OpenMouseListener = OpenMouseListener;
var model$1 = {};
Object.defineProperty(model$1, "__esModule", {
  value: true
});
model$1.getModelBounds = model$1.getProjectedBounds = model$1.getProjections = model$1.isProjectable = void 0;
const geometry_1$a = geometry$1;
const object_1 = object;
const smodel_utils_1$4 = smodelUtils;
const model_1$e = model$g;
function isProjectable(arg) {
  return (0, object_1.hasOwnProperty)(arg, "projectionCssClasses");
}
model$1.isProjectable = isProjectable;
function getProjections(parent) {
  let result;
  for (const child of parent.children) {
    if (isProjectable(child) && child.projectionCssClasses.length > 0) {
      const projectedBounds = getProjectedBounds(child);
      if (projectedBounds) {
        const projection = {
          elementId: child.id,
          projectedBounds,
          cssClasses: child.projectionCssClasses
        };
        if (result) {
          result.push(projection);
        } else {
          result = [projection];
        }
      }
    }
    if (child.children.length > 0) {
      const childProj = getProjections(child);
      if (childProj) {
        if (result) {
          result.push(...childProj);
        } else {
          result = childProj;
        }
      }
    }
  }
  return result;
}
model$1.getProjections = getProjections;
function getProjectedBounds(model2) {
  const parent = model2.parent;
  if (model2.projectedBounds) {
    let bounds = model2.projectedBounds;
    if ((0, model_1$e.isBoundsAware)(parent)) {
      bounds = (0, smodel_utils_1$4.transformToRootBounds)(parent, bounds);
    }
    return bounds;
  } else if ((0, model_1$e.isBoundsAware)(model2)) {
    let bounds = model2.bounds;
    bounds = (0, smodel_utils_1$4.transformToRootBounds)(parent, bounds);
    return bounds;
  }
  return void 0;
}
model$1.getProjectedBounds = getProjectedBounds;
const MAX_COORD = 1e9;
function getModelBounds(model2) {
  let minX = MAX_COORD;
  let minY = MAX_COORD;
  let maxX = -MAX_COORD;
  let maxY = -MAX_COORD;
  const bounds = (0, model_1$e.isBoundsAware)(model2) ? model2.bounds : void 0;
  if (bounds && geometry_1$a.Dimension.isValid(bounds)) {
    minX = bounds.x;
    minY = bounds.y;
    maxX = minX + bounds.width;
    maxY = minY + bounds.height;
  } else {
    for (const element of model2.children) {
      if ((0, model_1$e.isBoundsAware)(element)) {
        const b = element.bounds;
        minX = Math.min(minX, b.x);
        minY = Math.min(minY, b.y);
        maxX = Math.max(maxX, b.x + b.width);
        maxY = Math.max(maxY, b.y + b.height);
      }
    }
  }
  minX = Math.min(minX, model2.scroll.x);
  minY = Math.min(minY, model2.scroll.y);
  maxX = Math.max(maxX, model2.scroll.x + model2.canvasBounds.width / model2.zoom);
  maxY = Math.max(maxY, model2.scroll.y + model2.canvasBounds.height / model2.zoom);
  if (minX < maxX && minY < maxY) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  return void 0;
}
model$1.getModelBounds = getModelBounds;
var views$2 = {};
var __decorate$l = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(views$2, "__esModule", {
  value: true
});
views$2.ProjectedViewportView = void 0;
const jsx_1$3 = jsx;
const inversify_1$F = require$$0$1;
const snabbdom_1$1 = require$$0;
const vnode_utils_1$4 = vnodeUtils;
const model_1$d = model$1;
let ProjectedViewportView = class ProjectedViewportView2 {
  render(model2, context, args) {
    const rootNode = (0, jsx_1$3.html)("div", {
      "class-sprotty-root": true
    }, this.renderSvg(model2, context, args), this.renderProjections(model2, context, args));
    (0, vnode_utils_1$4.setAttr)(rootNode, "tabindex", 0);
    return rootNode;
  }
  renderSvg(model2, context, args) {
    const transform = `scale(${model2.zoom}) translate(${-model2.scroll.x},${-model2.scroll.y})`;
    const ns = "http://www.w3.org/2000/svg";
    return (0, snabbdom_1$1.h)("svg", {
      ns
    }, (0, snabbdom_1$1.h)("g", {
      ns,
      attrs: {
        transform
      }
    }, context.renderChildren(model2)));
  }
  renderProjections(model2, context, args) {
    var _a;
    if (model2.zoom <= 0) {
      return [];
    }
    const modelBounds = (0, model_1$d.getModelBounds)(model2);
    if (!modelBounds) {
      return [];
    }
    const projections = (_a = (0, model_1$d.getProjections)(model2)) !== null && _a !== void 0 ? _a : [];
    return [this.renderProjectionBar(projections, model2, modelBounds, "vertical"), this.renderProjectionBar(projections, model2, modelBounds, "horizontal")];
  }
  renderProjectionBar(projections, model2, modelBounds, orientation) {
    const params = {
      modelBounds,
      orientation
    };
    params.factor = orientation === "horizontal" ? model2.canvasBounds.width / modelBounds.width : model2.canvasBounds.height / modelBounds.height;
    params.zoomedFactor = params.factor / model2.zoom;
    return (0, jsx_1$3.html)("div", {
      "class-sprotty-projection-bar": true,
      "class-horizontal": orientation === "horizontal",
      "class-vertical": orientation === "vertical"
    }, this.renderViewport(model2, params), projections.map((p2) => this.renderProjection(p2, model2, params)));
  }
  renderViewport(model2, params) {
    let canvasSize, viewportPos;
    if (params.orientation === "horizontal") {
      canvasSize = model2.canvasBounds.width;
      viewportPos = (model2.scroll.x - params.modelBounds.x) * params.factor;
    } else {
      canvasSize = model2.canvasBounds.height;
      viewportPos = (model2.scroll.y - params.modelBounds.y) * params.factor;
    }
    let viewportSize = canvasSize * params.zoomedFactor;
    if (viewportPos < 0) {
      viewportSize += viewportPos;
      viewportPos = 0;
    } else if (viewportPos > canvasSize) {
      viewportPos = canvasSize;
    }
    if (viewportSize < 0) {
      viewportSize = 0;
    } else if (viewportPos + viewportSize > canvasSize) {
      viewportSize = canvasSize - viewportPos;
    }
    const style = params.orientation === "horizontal" ? {
      left: `${viewportPos}px`,
      width: `${viewportSize}px`
    } : {
      top: `${viewportPos}px`,
      height: `${viewportSize}px`
    };
    return (0, jsx_1$3.html)("div", {
      "class-sprotty-viewport": true,
      style
    });
  }
  renderProjection(projection, model2, params) {
    let canvasSize, projPos, projSize;
    if (params.orientation === "horizontal") {
      canvasSize = model2.canvasBounds.width;
      projPos = (projection.projectedBounds.x - params.modelBounds.x) * params.factor;
      projSize = projection.projectedBounds.width * params.factor;
    } else {
      canvasSize = model2.canvasBounds.height;
      projPos = (projection.projectedBounds.y - params.modelBounds.y) * params.factor;
      projSize = projection.projectedBounds.height * params.factor;
    }
    if (projPos < 0) {
      projSize += projPos;
      projPos = 0;
    } else if (projPos > canvasSize) {
      projPos = canvasSize;
    }
    if (projSize < 0) {
      projSize = 0;
    } else if (projPos + projSize > canvasSize) {
      projSize = canvasSize - projPos;
    }
    const style = params.orientation === "horizontal" ? {
      left: `${projPos}px`,
      width: `${projSize}px`
    } : {
      top: `${projPos}px`,
      height: `${projSize}px`
    };
    const result = (0, jsx_1$3.html)("div", {
      id: `${params.orientation}-projection:${projection.elementId}`,
      "class-sprotty-projection": true,
      style
    });
    projection.cssClasses.forEach((cl) => (0, vnode_utils_1$4.setClass)(result, cl, true));
    return result;
  }
};
views$2.ProjectedViewportView = ProjectedViewportView;
views$2.ProjectedViewportView = ProjectedViewportView = __decorate$l([(0, inversify_1$F.injectable)()], ProjectedViewportView);
var bezierAnchors = {};
var polylineAnchors = {};
var __decorate$k = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(polylineAnchors, "__esModule", {
  value: true
});
polylineAnchors.DiamondAnchor = polylineAnchors.RectangleAnchor = polylineAnchors.EllipseAnchor = void 0;
const anchor_1$4 = anchor;
const geometry_1$9 = geometry;
const inversify_1$E = require$$0$1;
const polyline_edge_router_1$1 = polylineEdgeRouter;
const geometry_2$2 = geometry$1;
let EllipseAnchor = class EllipseAnchor2 {
  get kind() {
    return polyline_edge_router_1$1.PolylineEdgeRouter.KIND + ":" + anchor_1$4.ELLIPTIC_ANCHOR_KIND;
  }
  getAnchor(connectable, refPoint, offset = 0) {
    const bounds = connectable.bounds;
    const c = geometry_2$2.Bounds.center(bounds);
    const dx = c.x - refPoint.x;
    const dy = c.y - refPoint.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const normX = dx / distance || 0;
    const normY = dy / distance || 0;
    return {
      x: c.x - normX * (0.5 * bounds.width + offset),
      y: c.y - normY * (0.5 * bounds.height + offset)
    };
  }
};
polylineAnchors.EllipseAnchor = EllipseAnchor;
polylineAnchors.EllipseAnchor = EllipseAnchor = __decorate$k([(0, inversify_1$E.injectable)()], EllipseAnchor);
let RectangleAnchor = class RectangleAnchor2 {
  get kind() {
    return polyline_edge_router_1$1.PolylineEdgeRouter.KIND + ":" + anchor_1$4.RECTANGULAR_ANCHOR_KIND;
  }
  getAnchor(connectable, refPoint, offset = 0) {
    const bounds = connectable.bounds;
    const c = geometry_2$2.Bounds.center(bounds);
    const finder = new NearestPointFinder(c, refPoint);
    if (!(0, geometry_2$2.almostEquals)(c.y, refPoint.y)) {
      const xTop = this.getXIntersection(bounds.y, c, refPoint);
      if (xTop >= bounds.x && xTop <= bounds.x + bounds.width)
        finder.addCandidate(xTop, bounds.y - offset);
      const xBottom = this.getXIntersection(bounds.y + bounds.height, c, refPoint);
      if (xBottom >= bounds.x && xBottom <= bounds.x + bounds.width)
        finder.addCandidate(xBottom, bounds.y + bounds.height + offset);
    }
    if (!(0, geometry_2$2.almostEquals)(c.x, refPoint.x)) {
      const yLeft = this.getYIntersection(bounds.x, c, refPoint);
      if (yLeft >= bounds.y && yLeft <= bounds.y + bounds.height)
        finder.addCandidate(bounds.x - offset, yLeft);
      const yRight = this.getYIntersection(bounds.x + bounds.width, c, refPoint);
      if (yRight >= bounds.y && yRight <= bounds.y + bounds.height)
        finder.addCandidate(bounds.x + bounds.width + offset, yRight);
    }
    return finder.best;
  }
  getXIntersection(yIntersection, centerPoint, point) {
    const t = (yIntersection - centerPoint.y) / (point.y - centerPoint.y);
    return (point.x - centerPoint.x) * t + centerPoint.x;
  }
  getYIntersection(xIntersection, centerPoint, point) {
    const t = (xIntersection - centerPoint.x) / (point.x - centerPoint.x);
    return (point.y - centerPoint.y) * t + centerPoint.y;
  }
};
polylineAnchors.RectangleAnchor = RectangleAnchor;
polylineAnchors.RectangleAnchor = RectangleAnchor = __decorate$k([(0, inversify_1$E.injectable)()], RectangleAnchor);
class NearestPointFinder {
  constructor(centerPoint, refPoint) {
    this.centerPoint = centerPoint;
    this.refPoint = refPoint;
    this.currentDist = -1;
  }
  addCandidate(x, y) {
    const dx = this.refPoint.x - x;
    const dy = this.refPoint.y - y;
    const dist = dx * dx + dy * dy;
    if (this.currentDist < 0 || dist < this.currentDist) {
      this.currentBest = {
        x,
        y
      };
      this.currentDist = dist;
    }
  }
  get best() {
    if (this.currentBest === void 0)
      return this.centerPoint;
    else
      return this.currentBest;
  }
}
let DiamondAnchor = class DiamondAnchor2 {
  get kind() {
    return polyline_edge_router_1$1.PolylineEdgeRouter.KIND + ":" + anchor_1$4.DIAMOND_ANCHOR_KIND;
  }
  getAnchor(connectable, refPoint, offset) {
    const bounds = connectable.bounds;
    const referenceLine = new geometry_1$9.PointToPointLine(geometry_2$2.Bounds.center(bounds), refPoint);
    const closestDiamondSide = new geometry_1$9.Diamond(bounds).closestSideLine(refPoint);
    const anchorPoint = (0, geometry_1$9.intersection)(closestDiamondSide, referenceLine);
    return geometry_2$2.Point.shiftTowards(anchorPoint, refPoint, offset);
  }
};
polylineAnchors.DiamondAnchor = DiamondAnchor;
polylineAnchors.DiamondAnchor = DiamondAnchor = __decorate$k([(0, inversify_1$E.injectable)()], DiamondAnchor);
var bezierEdgeRouter = {};
var __decorate$j = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$d = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$5 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BezierEdgeRouter_1;
Object.defineProperty(bezierEdgeRouter, "__esModule", {
  value: true
});
bezierEdgeRouter.AddRemoveBezierSegmentCommand = bezierEdgeRouter.AddRemoveBezierSegmentAction = bezierEdgeRouter.BezierMouseListener = bezierEdgeRouter.BezierEdgeRouter = void 0;
const inversify_1$D = require$$0$1;
const geometry_1$8 = geometry$1;
const model_1$c = model$a;
const routing_1$3 = routing;
const abstract_edge_router_1$1 = abstractEdgeRouter;
const mouse_tool_1$2 = mouseTool;
const command_1$6 = command;
const types_1$s = types;
let BezierEdgeRouter = BezierEdgeRouter_1 = class BezierEdgeRouter2 extends abstract_edge_router_1$1.AbstractEdgeRouter {
  get kind() {
    return BezierEdgeRouter_1.KIND;
  }
  route(edge) {
    if (!edge.source || !edge.target)
      return [];
    const rpCount = edge.routingPoints.length;
    const source = edge.source;
    const target = edge.target;
    const result = [];
    result.push({
      kind: "source",
      x: 0,
      y: 0
    });
    if (rpCount === 0) {
      const [h1, h2] = this.createDefaultBezierHandles(source.position, target.position);
      result.push({
        kind: "bezier-control-after",
        x: h1.x,
        y: h1.y,
        pointIndex: 0
      });
      result.push({
        kind: "bezier-control-before",
        x: h2.x,
        y: h2.y,
        pointIndex: 1
      });
      edge.routingPoints.push(h1);
      edge.routingPoints.push(h2);
    } else if (rpCount >= 2) {
      for (let i = 0; i < rpCount; i++) {
        const p2 = edge.routingPoints[i];
        if (i % 3 === 0) {
          result.push({
            kind: "bezier-control-after",
            x: p2.x,
            y: p2.y,
            pointIndex: i
          });
        }
        if ((i + 1) % 3 === 0) {
          result.push({
            kind: "bezier-junction",
            x: p2.x,
            y: p2.y,
            pointIndex: i
          });
        } else if ((i + 2) % 3 === 0) {
          result.push({
            kind: "bezier-control-before",
            x: p2.x,
            y: p2.y,
            pointIndex: i
          });
        }
      }
    }
    result.push({
      kind: "target",
      x: 0,
      y: 0
    });
    const p0 = rpCount > 2 ? edge.routingPoints[2] : target.position;
    const pn = rpCount > 2 ? edge.routingPoints[edge.routingPoints.length - 3] : source.position;
    const sourceAnchor = this.getTranslatedAnchor(source, p0, target.parent, edge, edge.sourceAnchorCorrection);
    const targetAnchor = this.getTranslatedAnchor(target, pn, source.parent, edge, edge.targetAnchorCorrection);
    result[0] = {
      kind: "source",
      x: sourceAnchor.x,
      y: sourceAnchor.y
    };
    result[result.length - 1] = {
      kind: "target",
      x: targetAnchor.x,
      y: targetAnchor.y
    };
    return result;
  }
  createDefaultBezierHandles(relH1, relH2) {
    const h1 = {
      x: relH1.x - BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
      y: relH1.y
    };
    const h2 = {
      x: relH2.x + BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
      y: relH2.y
    };
    return [h1, h2];
  }
  createRoutingHandles(edge) {
    this.route(edge);
    this.rebuildHandles(edge);
  }
  rebuildHandles(edge) {
    this.addHandle(edge, "source", "routing-point", -2);
    this.addHandle(edge, "bezier-control-after", "bezier-routing-point", 0);
    this.addHandle(edge, "bezier-add", "bezier-create-routing-point", 0);
    const rpCount = edge.routingPoints.length;
    if (rpCount > 2) {
      for (let i = 1; i < rpCount - 1; i += 3) {
        this.addHandle(edge, "bezier-control-before", "bezier-routing-point", i);
        this.addHandle(edge, "bezier-add", "bezier-create-routing-point", i + 1);
        this.addHandle(edge, "bezier-junction", "routing-point", i + 1);
        this.addHandle(edge, "bezier-remove", "bezier-remove-routing-point", i + 1);
        this.addHandle(edge, "bezier-control-after", "bezier-routing-point", i + 2);
        this.moveBezierControlPair(edge.routingPoints[i], i, edge);
      }
    }
    this.addHandle(edge, "bezier-control-before", "bezier-routing-point", rpCount - 1);
    this.addHandle(edge, "target", "routing-point", -1);
  }
  getInnerHandlePosition(edge, route, handle) {
    if (handle.kind === "bezier-control-before" || handle.kind === "bezier-junction" || handle.kind === "bezier-control-after") {
      for (let i = 0; i < route.length; i++) {
        const p2 = route[i];
        if (p2.pointIndex === handle.pointIndex && p2.kind === handle.kind)
          return p2;
      }
    } else if (handle.kind === "bezier-add") {
      const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
      return {
        x: ctrlPoint.x,
        y: ctrlPoint.y + 12.5
      };
    } else if (handle.kind === "bezier-remove") {
      const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
      return {
        x: ctrlPoint.x,
        y: ctrlPoint.y - 12.5
      };
    }
    return void 0;
  }
  findBezierControl(edge, route, handleIndex) {
    let result = {
      x: route[0].x,
      y: route[0].y
    };
    if (handleIndex > 0) {
      for (const rp of route) {
        if (rp.pointIndex !== void 0 && rp.pointIndex === handleIndex && rp.kind === "bezier-junction") {
          result = {
            x: rp.x,
            y: rp.y
          };
          break;
        }
      }
    }
    return result;
  }
  applyHandleMoves(edge, moves) {
    moves.forEach((move2) => {
      const handle = move2.handle;
      let orgPosition = {
        x: 0,
        y: 0
      };
      let relativePos, newControlPos, ctrlPointIndex;
      const moveToPos = move2.toPosition;
      switch (handle.kind) {
        case "bezier-control-before":
        case "bezier-control-after":
          this.moveBezierControlPair(moveToPos, move2.handle.pointIndex, edge);
          break;
        case "bezier-junction":
          const index = handle.pointIndex;
          if (index >= 0 && index < edge.routingPoints.length) {
            ctrlPointIndex = index - 1;
            orgPosition = edge.routingPoints[index];
            relativePos = edge.routingPoints[ctrlPointIndex];
            newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
            edge.routingPoints[index] = moveToPos;
            this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
          }
          break;
        case "source":
          ctrlPointIndex = 0;
          relativePos = edge.routingPoints[ctrlPointIndex];
          if (!(edge.source instanceof model_1$c.SDanglingAnchorImpl)) {
            const anchor2 = new model_1$c.SDanglingAnchorImpl();
            anchor2.id = edge.id + "_dangling-source";
            anchor2.original = edge.source;
            anchor2.position = move2.toPosition;
            handle.root.add(anchor2);
            handle.danglingAnchor = anchor2;
            edge.sourceId = anchor2.id;
            if (edge.source)
              orgPosition = edge.source.position;
          } else if (handle.danglingAnchor) {
            orgPosition = handle.danglingAnchor.position;
            handle.danglingAnchor.position = moveToPos;
          }
          newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
          this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
          break;
        case "target":
          ctrlPointIndex = edge.routingPoints.length - 1;
          relativePos = edge.routingPoints[ctrlPointIndex];
          if (!(edge.target instanceof model_1$c.SDanglingAnchorImpl)) {
            const anchor2 = new model_1$c.SDanglingAnchorImpl();
            anchor2.id = edge.id + "_dangling-target";
            anchor2.original = edge.target;
            anchor2.position = moveToPos;
            handle.root.add(anchor2);
            handle.danglingAnchor = anchor2;
            edge.targetId = anchor2.id;
            if (edge.target)
              orgPosition = edge.target.position;
          } else if (handle.danglingAnchor) {
            orgPosition = handle.danglingAnchor.position;
            handle.danglingAnchor.position = moveToPos;
          }
          newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
          this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
          break;
      }
    });
  }
  applyInnerHandleMoves(edge, moves) {
  }
  getOptions(edge) {
    return {
      minimalPointDistance: 2,
      standardDistance: 0.1,
      selfEdgeOffset: 20
    };
  }
  calcRelativeMove(oldPos, newPos, relativePoint) {
    return {
      x: relativePoint.x - (oldPos.x - newPos.x),
      y: relativePoint.y - (oldPos.y - newPos.y)
    };
  }
  createNewBezierSegment(index, edge) {
    const routingPoints = edge.routingPoints;
    let bezierJunctionPos, start, end;
    if (routingPoints.length === 2) {
      start = routingPoints[index < 0 ? 0 : index];
      end = routingPoints[routingPoints.length - 1];
      bezierJunctionPos = (0, geometry_1$8.centerOfLine)(start, end);
    } else {
      start = routingPoints[index];
      end = routingPoints[index + 2];
      bezierJunctionPos = (0, geometry_1$8.centerOfLine)(start, end);
    }
    const [h1, h2] = this.createDefaultBezierHandles(bezierJunctionPos, bezierJunctionPos);
    routingPoints.splice(index + 1, 0, h1);
    routingPoints.splice(index + 2, 0, bezierJunctionPos);
    routingPoints.splice(index + 3, 0, h2);
    this.moveBezierControlPair(h1, index + 1, edge);
    edge.removeAll((c) => c instanceof model_1$c.SRoutingHandleImpl);
    this.rebuildHandles(edge);
  }
  removeBezierSegment(index, edge) {
    const routingPoints = edge.routingPoints;
    routingPoints.splice(index - 1, 3);
    edge.removeAll((c) => c instanceof model_1$c.SRoutingHandleImpl);
    this.rebuildHandles(edge);
  }
  moveBezierControlPair(newPos, ctrlPointIndex, edge) {
    if (ctrlPointIndex >= 0 && ctrlPointIndex < edge.routingPoints.length) {
      const before = ctrlPointIndex - 1;
      const after = ctrlPointIndex + 1;
      if (before < 0 || after === edge.routingPoints.length) {
        edge.routingPoints[ctrlPointIndex] = newPos;
      } else {
        if (ctrlPointIndex % 3 === 0) {
          this.setBezierMirror(edge, newPos, ctrlPointIndex, false);
        } else if ((ctrlPointIndex + 2) % 3 === 0) {
          this.setBezierMirror(edge, newPos, ctrlPointIndex, true);
        }
      }
    }
  }
  setBezierMirror(edge, newPos, pointIndex, before) {
    edge.routingPoints[pointIndex] = newPos;
    const jct = edge.routingPoints[before ? pointIndex + 1 : pointIndex - 1];
    edge.routingPoints[before ? pointIndex + 2 : pointIndex - 2] = {
      x: jct.x - (newPos.x - jct.x),
      y: jct.y - (newPos.y - jct.y)
    };
  }
};
bezierEdgeRouter.BezierEdgeRouter = BezierEdgeRouter;
BezierEdgeRouter.KIND = "bezier";
BezierEdgeRouter.DEFAULT_BEZIER_HANDLE_OFFSET = 25;
bezierEdgeRouter.BezierEdgeRouter = BezierEdgeRouter = BezierEdgeRouter_1 = __decorate$j([(0, inversify_1$D.injectable)()], BezierEdgeRouter);
class BezierMouseListener extends mouse_tool_1$2.MouseListener {
  mouseDown(target, event) {
    const result = [];
    if (target instanceof model_1$c.SRoutingHandleImpl && (target.kind === "bezier-add" || target.kind === "bezier-remove")) {
      if (target.type === "bezier-create-routing-point") {
        result.push(AddRemoveBezierSegmentAction.create("add", target.id));
      } else if (target.type === "bezier-remove-routing-point") {
        result.push(AddRemoveBezierSegmentAction.create("remove", target.id));
      }
    }
    return result;
  }
}
bezierEdgeRouter.BezierMouseListener = BezierMouseListener;
var AddRemoveBezierSegmentAction;
(function(AddRemoveBezierSegmentAction2) {
  AddRemoveBezierSegmentAction2.KIND = "addRemoveBezierSegment";
  function create2(actionTask, targetId) {
    return {
      kind: AddRemoveBezierSegmentAction2.KIND,
      actionTask,
      targetId
    };
  }
  AddRemoveBezierSegmentAction2.create = create2;
})(AddRemoveBezierSegmentAction || (bezierEdgeRouter.AddRemoveBezierSegmentAction = AddRemoveBezierSegmentAction = {}));
let AddRemoveBezierSegmentCommand = class AddRemoveBezierSegmentCommand2 extends command_1$6.Command {
  constructor(action2, edgeRouterRegistry) {
    super();
    this.action = action2;
    this.edgeRouterRegistry = edgeRouterRegistry;
  }
  execute(context) {
    const index = context.root.index;
    const target = index.getById(this.action.targetId);
    if (this.edgeRouterRegistry && target instanceof model_1$c.SRoutingHandleImpl) {
      const raw = this.edgeRouterRegistry.get(target.parent.routerKind);
      if (raw instanceof BezierEdgeRouter) {
        const router = raw;
        for (const child of context.root.children) {
          if (child.id === target.parent.id) {
            if (this.action.actionTask === "add") {
              router.createNewBezierSegment(target.pointIndex, child);
            } else if (this.action.actionTask === "remove") {
              router.removeBezierSegment(target.pointIndex, child);
            }
            break;
          }
        }
      }
    }
    return context.root;
  }
  undo(context) {
    throw new Error("Method not implemented.");
  }
  redo(context) {
    throw new Error("Method not implemented.");
  }
};
bezierEdgeRouter.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand;
AddRemoveBezierSegmentCommand.KIND = AddRemoveBezierSegmentAction.KIND;
bezierEdgeRouter.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand = __decorate$j([(0, inversify_1$D.injectable)(), __param$5(0, (0, inversify_1$D.inject)(types_1$s.TYPES.Action)), __param$5(1, (0, inversify_1$D.inject)(routing_1$3.EdgeRouterRegistry)), __metadata$d("design:paramtypes", [Object, routing_1$3.EdgeRouterRegistry])], AddRemoveBezierSegmentCommand);
var __decorate$i = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(bezierAnchors, "__esModule", {
  value: true
});
bezierAnchors.BezierDiamondAnchor = bezierAnchors.BezierRectangleAnchor = bezierAnchors.BezierEllipseAnchor = void 0;
const anchor_1$3 = anchor;
const inversify_1$C = require$$0$1;
const polyline_anchors_1$1 = polylineAnchors;
const bezier_edge_router_1$1 = bezierEdgeRouter;
let BezierEllipseAnchor = class BezierEllipseAnchor2 extends polyline_anchors_1$1.EllipseAnchor {
  get kind() {
    return bezier_edge_router_1$1.BezierEdgeRouter.KIND + ":" + anchor_1$3.ELLIPTIC_ANCHOR_KIND;
  }
};
bezierAnchors.BezierEllipseAnchor = BezierEllipseAnchor;
bezierAnchors.BezierEllipseAnchor = BezierEllipseAnchor = __decorate$i([(0, inversify_1$C.injectable)()], BezierEllipseAnchor);
let BezierRectangleAnchor = class BezierRectangleAnchor2 extends polyline_anchors_1$1.RectangleAnchor {
  get kind() {
    return bezier_edge_router_1$1.BezierEdgeRouter.KIND + ":" + anchor_1$3.RECTANGULAR_ANCHOR_KIND;
  }
};
bezierAnchors.BezierRectangleAnchor = BezierRectangleAnchor;
bezierAnchors.BezierRectangleAnchor = BezierRectangleAnchor = __decorate$i([(0, inversify_1$C.injectable)()], BezierRectangleAnchor);
let BezierDiamondAnchor = class BezierDiamondAnchor2 extends polyline_anchors_1$1.DiamondAnchor {
  get kind() {
    return bezier_edge_router_1$1.BezierEdgeRouter.KIND + ":" + anchor_1$3.DIAMOND_ANCHOR_KIND;
  }
};
bezierAnchors.BezierDiamondAnchor = BezierDiamondAnchor;
bezierAnchors.BezierDiamondAnchor = BezierDiamondAnchor = __decorate$i([(0, inversify_1$C.injectable)()], BezierDiamondAnchor);
var manhattanAnchors = {};
var manhattanEdgeRouter = {};
Object.defineProperty(manhattanEdgeRouter, "__esModule", {
  value: true
});
manhattanEdgeRouter.ManhattanEdgeRouter = void 0;
const geometry_1$7 = geometry$1;
const smodel_utils_1$3 = smodelUtils;
const abstract_edge_router_1 = abstractEdgeRouter;
const model_1$b = model$a;
class ManhattanEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
  get kind() {
    return ManhattanEdgeRouter.KIND;
  }
  getOptions(edge) {
    return {
      standardDistance: 20,
      minimalPointDistance: 3,
      selfEdgeOffset: 0.25
    };
  }
  route(edge) {
    if (!edge.source || !edge.target)
      return [];
    const routedCorners = this.createRoutedCorners(edge);
    const sourceRefPoint = routedCorners[0] || (0, smodel_utils_1$3.translatePoint)(geometry_1$7.Bounds.center(edge.target.bounds), edge.target.parent, edge.parent);
    const sourceAnchor = this.getTranslatedAnchor(edge.source, sourceRefPoint, edge.parent, edge, edge.sourceAnchorCorrection);
    const targetRefPoint = routedCorners[routedCorners.length - 1] || (0, smodel_utils_1$3.translatePoint)(geometry_1$7.Bounds.center(edge.source.bounds), edge.source.parent, edge.parent);
    const targetAnchor = this.getTranslatedAnchor(edge.target, targetRefPoint, edge.parent, edge, edge.targetAnchorCorrection);
    if (!sourceAnchor || !targetAnchor)
      return [];
    const routedPoints = [];
    routedPoints.push(Object.assign({
      kind: "source"
    }, sourceAnchor));
    routedCorners.forEach((corner) => routedPoints.push(corner));
    routedPoints.push(Object.assign({
      kind: "target"
    }, targetAnchor));
    return routedPoints;
  }
  createRoutedCorners(edge) {
    const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
    const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
    if (edge.routingPoints.length > 0) {
      const routingPointsCopy = edge.routingPoints.slice();
      this.cleanupRoutingPoints(edge, routingPointsCopy, false, true);
      if (routingPointsCopy.length > 0)
        return routingPointsCopy.map((routingPoint, index) => {
          return Object.assign({
            kind: "linear",
            pointIndex: index
          }, routingPoint);
        });
    }
    const options = this.getOptions(edge);
    const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
    return corners.map((corner) => {
      return Object.assign({
        kind: "linear"
      }, corner);
    });
  }
  createRoutingHandles(edge) {
    const routedPoints = this.route(edge);
    this.commitRoute(edge, routedPoints);
    if (routedPoints.length > 0) {
      this.addHandle(edge, "source", "routing-point", -2);
      for (let i = 0; i < routedPoints.length - 1; ++i)
        this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i - 1);
      this.addHandle(edge, "target", "routing-point", routedPoints.length - 2);
    }
  }
  getInnerHandlePosition(edge, route, handle) {
    const fraction = this.getFraction(handle.kind);
    if (fraction !== void 0) {
      const {
        start,
        end
      } = this.findRouteSegment(edge, route, handle.pointIndex);
      if (start !== void 0 && end !== void 0)
        return geometry_1$7.Point.linear(start, end, fraction);
    }
    return void 0;
  }
  getFraction(kind) {
    switch (kind) {
      case "manhattan-50%":
        return 0.5;
      default:
        return void 0;
    }
  }
  applyInnerHandleMoves(edge, moves) {
    const route = this.route(edge);
    const routingPoints = edge.routingPoints;
    const minimalPointDistance = this.getOptions(edge).minimalPointDistance;
    moves.forEach((move2) => {
      const handle = move2.handle;
      const index = handle.pointIndex;
      const correctedX = this.correctX(routingPoints, index, move2.toPosition.x, minimalPointDistance);
      const correctedY = this.correctY(routingPoints, index, move2.toPosition.y, minimalPointDistance);
      switch (handle.kind) {
        case "manhattan-50%":
          if (index < 0) {
            if (routingPoints.length === 0) {
              routingPoints.push({
                x: correctedX,
                y: correctedY
              });
              handle.pointIndex = 0;
            } else if ((0, geometry_1$7.almostEquals)(route[0].x, route[1].x)) {
              this.alignX(routingPoints, 0, correctedX);
            } else {
              this.alignY(routingPoints, 0, correctedY);
            }
          } else if (index < routingPoints.length - 1) {
            if ((0, geometry_1$7.almostEquals)(routingPoints[index].x, routingPoints[index + 1].x)) {
              this.alignX(routingPoints, index, correctedX);
              this.alignX(routingPoints, index + 1, correctedX);
            } else {
              this.alignY(routingPoints, index, correctedY);
              this.alignY(routingPoints, index + 1, correctedY);
            }
          } else {
            if ((0, geometry_1$7.almostEquals)(route[route.length - 2].x, route[route.length - 1].x)) {
              this.alignX(routingPoints, routingPoints.length - 1, correctedX);
            } else {
              this.alignY(routingPoints, routingPoints.length - 1, correctedY);
            }
          }
          break;
      }
    });
  }
  correctX(routingPoints, index, x, minimalPointDistance) {
    if (index > 0 && Math.abs(x - routingPoints[index - 1].x) < minimalPointDistance)
      return routingPoints[index - 1].x;
    else if (index < routingPoints.length - 2 && Math.abs(x - routingPoints[index + 2].x) < minimalPointDistance)
      return routingPoints[index + 2].x;
    else
      return x;
  }
  alignX(routingPoints, index, x) {
    if (index >= 0 && index < routingPoints.length)
      routingPoints[index] = {
        x,
        y: routingPoints[index].y
      };
  }
  correctY(routingPoints, index, y, minimalPointDistance) {
    if (index > 0 && Math.abs(y - routingPoints[index - 1].y) < minimalPointDistance)
      return routingPoints[index - 1].y;
    else if (index < routingPoints.length - 2 && Math.abs(y - routingPoints[index + 2].y) < minimalPointDistance)
      return routingPoints[index + 2].y;
    else
      return y;
  }
  alignY(routingPoints, index, y) {
    if (index >= 0 && index < routingPoints.length)
      routingPoints[index] = {
        x: routingPoints[index].x,
        y
      };
  }
  cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
    const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
    const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
    if (this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors))
      return;
    for (let i = 0; i < routingPoints.length; ++i)
      if (geometry_1$7.Bounds.includes(sourceAnchors.bounds, routingPoints[i])) {
        routingPoints.splice(0, 1);
        if (updateHandles) {
          this.removeHandle(edge, -1);
        }
      } else {
        break;
      }
    for (let i = routingPoints.length - 1; i >= 0; --i)
      if (geometry_1$7.Bounds.includes(targetAnchors.bounds, routingPoints[i])) {
        routingPoints.splice(i, 1);
        if (updateHandles) {
          this.removeHandle(edge, i);
        }
      } else {
        break;
      }
    if (routingPoints.length >= 2) {
      const options = this.getOptions(edge);
      for (let i = routingPoints.length - 2; i >= 0; --i) {
        if (geometry_1$7.Point.manhattanDistance(routingPoints[i], routingPoints[i + 1]) < options.minimalPointDistance) {
          routingPoints.splice(i, 2);
          --i;
          if (updateHandles) {
            this.removeHandle(edge, i - 1);
            this.removeHandle(edge, i);
          }
        }
      }
    }
    if (addRoutingPoints) {
      this.addAdditionalCorner(edge, routingPoints, sourceAnchors, targetAnchors, updateHandles);
      this.addAdditionalCorner(edge, routingPoints, targetAnchors, sourceAnchors, updateHandles);
      this.manhattanify(edge, routingPoints);
    }
  }
  removeHandle(edge, pointIndex) {
    const toBeRemoved = [];
    edge.children.forEach((child) => {
      if (child instanceof model_1$b.SRoutingHandleImpl) {
        if (child.pointIndex > pointIndex)
          --child.pointIndex;
        else if (child.pointIndex === pointIndex)
          toBeRemoved.push(child);
      }
    });
    toBeRemoved.forEach((child) => edge.remove(child));
  }
  addAdditionalCorner(edge, routingPoints, currentAnchors, otherAnchors, updateHandles) {
    if (routingPoints.length === 0)
      return;
    const refPoint = currentAnchors.kind === "source" ? routingPoints[0] : routingPoints[routingPoints.length - 1];
    const index = currentAnchors.kind === "source" ? 0 : routingPoints.length;
    const shiftIndex = index - (currentAnchors.kind === "source" ? 1 : 0);
    let isHorizontal;
    if (routingPoints.length > 1) {
      isHorizontal = index === 0 ? (0, geometry_1$7.almostEquals)(routingPoints[0].x, routingPoints[1].x) : (0, geometry_1$7.almostEquals)(routingPoints[routingPoints.length - 1].x, routingPoints[routingPoints.length - 2].x);
    } else {
      const nearestSide = otherAnchors.getNearestSide(refPoint);
      isHorizontal = nearestSide === abstract_edge_router_1.Side.TOP || nearestSide === abstract_edge_router_1.Side.BOTTOM;
    }
    if (isHorizontal) {
      if (refPoint.y < currentAnchors.get(abstract_edge_router_1.Side.TOP).y || refPoint.y > currentAnchors.get(abstract_edge_router_1.Side.BOTTOM).y) {
        const newPoint = {
          x: currentAnchors.get(abstract_edge_router_1.Side.TOP).x,
          y: refPoint.y
        };
        routingPoints.splice(index, 0, newPoint);
        if (updateHandles) {
          edge.children.forEach((child) => {
            if (child instanceof model_1$b.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
              ++child.pointIndex;
          });
          this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
        }
      }
    } else {
      if (refPoint.x < currentAnchors.get(abstract_edge_router_1.Side.LEFT).x || refPoint.x > currentAnchors.get(abstract_edge_router_1.Side.RIGHT).x) {
        const newPoint = {
          x: refPoint.x,
          y: currentAnchors.get(abstract_edge_router_1.Side.LEFT).y
        };
        routingPoints.splice(index, 0, newPoint);
        if (updateHandles) {
          edge.children.forEach((child) => {
            if (child instanceof model_1$b.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
              ++child.pointIndex;
          });
          this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
        }
      }
    }
  }
  /**
   * Add artificial routing points to keep all angles rectilinear.
   *
   * This makes edge morphing look a lot smoother, where RP positions are interpolated
   * linearly probably resulting in non-rectilinear angles. We don't add handles for
   * these additional RPs.
   */
  manhattanify(edge, routingPoints) {
    for (let i = 1; i < routingPoints.length; ++i) {
      const isVertical = Math.abs(routingPoints[i - 1].x - routingPoints[i].x) < 1;
      const isHorizontal = Math.abs(routingPoints[i - 1].y - routingPoints[i].y) < 1;
      if (!isVertical && !isHorizontal) {
        routingPoints.splice(i, 0, {
          x: routingPoints[i - 1].x,
          y: routingPoints[i].y
        });
        ++i;
      }
    }
  }
  calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
    const selfEdge = super.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
    if (selfEdge.length > 0)
      return selfEdge;
    const bestAnchors = this.getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options);
    const sourceSide = bestAnchors.source;
    const targetSide = bestAnchors.target;
    const corners = [];
    const startPoint = sourceAnchors.get(sourceSide);
    let endPoint = targetAnchors.get(targetSide);
    switch (sourceSide) {
      case abstract_edge_router_1.Side.RIGHT:
        switch (targetSide) {
          case abstract_edge_router_1.Side.BOTTOM:
            corners.push({
              x: endPoint.x,
              y: startPoint.y
            });
            break;
          case abstract_edge_router_1.Side.TOP:
            corners.push({
              x: endPoint.x,
              y: startPoint.y
            });
            break;
          case abstract_edge_router_1.Side.RIGHT:
            corners.push({
              x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance,
              y: startPoint.y
            });
            corners.push({
              x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance,
              y: endPoint.y
            });
            break;
          case abstract_edge_router_1.Side.LEFT:
            if (endPoint.y !== startPoint.y) {
              corners.push({
                x: (startPoint.x + endPoint.x) / 2,
                y: startPoint.y
              });
              corners.push({
                x: (startPoint.x + endPoint.x) / 2,
                y: endPoint.y
              });
            }
            break;
        }
        break;
      case abstract_edge_router_1.Side.LEFT:
        switch (targetSide) {
          case abstract_edge_router_1.Side.BOTTOM:
            corners.push({
              x: endPoint.x,
              y: startPoint.y
            });
            break;
          case abstract_edge_router_1.Side.TOP:
            corners.push({
              x: endPoint.x,
              y: startPoint.y
            });
            break;
          default:
            endPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
            if (endPoint.y !== startPoint.y) {
              corners.push({
                x: (startPoint.x + endPoint.x) / 2,
                y: startPoint.y
              });
              corners.push({
                x: (startPoint.x + endPoint.x) / 2,
                y: endPoint.y
              });
            }
            break;
        }
        break;
      case abstract_edge_router_1.Side.TOP:
        switch (targetSide) {
          case abstract_edge_router_1.Side.RIGHT:
            if (endPoint.x - startPoint.x > 0) {
              corners.push({
                x: startPoint.x,
                y: startPoint.y - options.standardDistance
              });
              corners.push({
                x: endPoint.x + 1.5 * options.standardDistance,
                y: startPoint.y - options.standardDistance
              });
              corners.push({
                x: endPoint.x + 1.5 * options.standardDistance,
                y: endPoint.y
              });
            } else {
              corners.push({
                x: startPoint.x,
                y: endPoint.y
              });
            }
            break;
          case abstract_edge_router_1.Side.LEFT:
            if (endPoint.x - startPoint.x < 0) {
              corners.push({
                x: startPoint.x,
                y: startPoint.y - options.standardDistance
              });
              corners.push({
                x: endPoint.x - 1.5 * options.standardDistance,
                y: startPoint.y - options.standardDistance
              });
              corners.push({
                x: endPoint.x - 1.5 * options.standardDistance,
                y: endPoint.y
              });
            } else {
              corners.push({
                x: startPoint.x,
                y: endPoint.y
              });
            }
            break;
          case abstract_edge_router_1.Side.TOP:
            corners.push({
              x: startPoint.x,
              y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance
            });
            corners.push({
              x: endPoint.x,
              y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance
            });
            break;
          case abstract_edge_router_1.Side.BOTTOM:
            if (endPoint.x !== startPoint.x) {
              corners.push({
                x: startPoint.x,
                y: (startPoint.y + endPoint.y) / 2
              });
              corners.push({
                x: endPoint.x,
                y: (startPoint.y + endPoint.y) / 2
              });
            }
            break;
        }
        break;
      case abstract_edge_router_1.Side.BOTTOM:
        switch (targetSide) {
          case abstract_edge_router_1.Side.RIGHT:
            if (endPoint.x - startPoint.x > 0) {
              corners.push({
                x: startPoint.x,
                y: startPoint.y + options.standardDistance
              });
              corners.push({
                x: endPoint.x + 1.5 * options.standardDistance,
                y: startPoint.y + options.standardDistance
              });
              corners.push({
                x: endPoint.x + 1.5 * options.standardDistance,
                y: endPoint.y
              });
            } else {
              corners.push({
                x: startPoint.x,
                y: endPoint.y
              });
            }
            break;
          case abstract_edge_router_1.Side.LEFT:
            if (endPoint.x - startPoint.x < 0) {
              corners.push({
                x: startPoint.x,
                y: startPoint.y + options.standardDistance
              });
              corners.push({
                x: endPoint.x - 1.5 * options.standardDistance,
                y: startPoint.y + options.standardDistance
              });
              corners.push({
                x: endPoint.x - 1.5 * options.standardDistance,
                y: endPoint.y
              });
            } else {
              corners.push({
                x: startPoint.x,
                y: endPoint.y
              });
            }
            break;
          default:
            endPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
            if (endPoint.x !== startPoint.x) {
              corners.push({
                x: startPoint.x,
                y: (startPoint.y + endPoint.y) / 2
              });
              corners.push({
                x: endPoint.x,
                y: (startPoint.y + endPoint.y) / 2
              });
            }
            break;
        }
        break;
    }
    return corners;
  }
  getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options) {
    let sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
    let targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
    if (targetPoint.x - sourcePoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.RIGHT,
        target: abstract_edge_router_1.Side.LEFT
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (sourcePoint.x - targetPoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.LEFT,
        target: abstract_edge_router_1.Side.RIGHT
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    if (sourcePoint.y - targetPoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.TOP,
        target: abstract_edge_router_1.Side.BOTTOM
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
    if (targetPoint.y - sourcePoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.BOTTOM,
        target: abstract_edge_router_1.Side.TOP
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
    if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.RIGHT,
        target: abstract_edge_router_1.Side.TOP
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.RIGHT,
        target: abstract_edge_router_1.Side.BOTTOM
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.LEFT,
        target: abstract_edge_router_1.Side.BOTTOM
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
    if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.LEFT,
        target: abstract_edge_router_1.Side.TOP
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.TOP,
        target: abstract_edge_router_1.Side.RIGHT
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
    if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.TOP,
        target: abstract_edge_router_1.Side.LEFT
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.BOTTOM,
        target: abstract_edge_router_1.Side.RIGHT
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
    if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
      return {
        source: abstract_edge_router_1.Side.BOTTOM,
        target: abstract_edge_router_1.Side.LEFT
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
      if (sourcePoint.y - targetPoint.y < 0) {
        if (Math.abs(sourcePoint.x - targetPoint.x) > (sourceAnchors.bounds.width + options.standardDistance) / 2)
          return {
            source: abstract_edge_router_1.Side.TOP,
            target: abstract_edge_router_1.Side.TOP
          };
      } else {
        if (Math.abs(sourcePoint.x - targetPoint.x) > targetAnchors.bounds.width / 2)
          return {
            source: abstract_edge_router_1.Side.TOP,
            target: abstract_edge_router_1.Side.TOP
          };
      }
    }
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
      if (sourcePoint.x - targetPoint.x > 0) {
        if (Math.abs(sourcePoint.y - targetPoint.y) > (sourceAnchors.bounds.height + options.standardDistance) / 2)
          return {
            source: abstract_edge_router_1.Side.RIGHT,
            target: abstract_edge_router_1.Side.RIGHT
          };
      } else if (Math.abs(sourcePoint.y - targetPoint.y) > targetAnchors.bounds.height / 2)
        return {
          source: abstract_edge_router_1.Side.RIGHT,
          target: abstract_edge_router_1.Side.RIGHT
        };
    }
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint))
      return {
        source: abstract_edge_router_1.Side.TOP,
        target: abstract_edge_router_1.Side.RIGHT
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint))
      return {
        source: abstract_edge_router_1.Side.TOP,
        target: abstract_edge_router_1.Side.LEFT
      };
    sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint))
      return {
        source: abstract_edge_router_1.Side.BOTTOM,
        target: abstract_edge_router_1.Side.RIGHT
      };
    targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
    if (!geometry_1$7.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1$7.Bounds.includes(sourceAnchors.bounds, targetPoint))
      return {
        source: abstract_edge_router_1.Side.BOTTOM,
        target: abstract_edge_router_1.Side.LEFT
      };
    return {
      source: abstract_edge_router_1.Side.RIGHT,
      target: abstract_edge_router_1.Side.BOTTOM
    };
  }
}
manhattanEdgeRouter.ManhattanEdgeRouter = ManhattanEdgeRouter;
ManhattanEdgeRouter.KIND = "manhattan";
var __decorate$h = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ManhattanRectangularAnchor_1, ManhattanDiamondAnchor_1, ManhattanEllipticAnchor_1;
Object.defineProperty(manhattanAnchors, "__esModule", {
  value: true
});
manhattanAnchors.ManhattanEllipticAnchor = manhattanAnchors.ManhattanDiamondAnchor = manhattanAnchors.ManhattanRectangularAnchor = void 0;
const geometry_1$6 = geometry$1;
const geometry_2$1 = geometry;
const anchor_1$2 = anchor;
const manhattan_edge_router_1$1 = manhattanEdgeRouter;
const inversify_1$B = require$$0$1;
let ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = class ManhattanRectangularAnchor2 {
  get kind() {
    return ManhattanRectangularAnchor_1.KIND;
  }
  getAnchor(connectable, refPoint, offset) {
    const b = connectable.bounds;
    if (b.width <= 0 || b.height <= 0) {
      return b;
    }
    const bounds = {
      x: b.x - offset,
      y: b.y - offset,
      width: b.width + 2 * offset,
      height: b.height + 2 * offset
    };
    if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
      if (refPoint.y < bounds.y + 0.5 * bounds.height)
        return {
          x: refPoint.x,
          y: bounds.y
        };
      else
        return {
          x: refPoint.x,
          y: bounds.y + bounds.height
        };
    }
    if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
      if (refPoint.x < bounds.x + 0.5 * bounds.width)
        return {
          x: bounds.x,
          y: refPoint.y
        };
      else
        return {
          x: bounds.x + bounds.width,
          y: refPoint.y
        };
    }
    return geometry_1$6.Bounds.center(bounds);
  }
};
manhattanAnchors.ManhattanRectangularAnchor = ManhattanRectangularAnchor;
ManhattanRectangularAnchor.KIND = manhattan_edge_router_1$1.ManhattanEdgeRouter.KIND + ":" + anchor_1$2.RECTANGULAR_ANCHOR_KIND;
manhattanAnchors.ManhattanRectangularAnchor = ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = __decorate$h([(0, inversify_1$B.injectable)()], ManhattanRectangularAnchor);
let ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = class ManhattanDiamondAnchor2 {
  get kind() {
    return ManhattanDiamondAnchor_1.KIND;
  }
  getAnchor(connectable, refPoint, offset = 0) {
    const b = connectable.bounds;
    if (b.width <= 0 || b.height <= 0) {
      return b;
    }
    const bounds = {
      x: b.x - offset,
      y: b.y - offset,
      width: b.width + 2 * offset,
      height: b.height + 2 * offset
    };
    const c = geometry_1$6.Bounds.center(bounds);
    let outline = void 0;
    let refLine = void 0;
    if (refPoint.x >= bounds.x && refPoint.x <= bounds.x + bounds.width) {
      if (bounds.x + 0.5 * bounds.width >= refPoint.x) {
        refLine = new geometry_2$1.PointToPointLine(refPoint, {
          x: refPoint.x,
          y: c.y
        });
        if (refPoint.y < c.y)
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y
          });
        else
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y + bounds.height
          });
      } else {
        refLine = new geometry_2$1.PointToPointLine(refPoint, {
          x: refPoint.x,
          y: c.y
        });
        if (refPoint.y < c.y)
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x + bounds.width,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y
          });
        else
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x + bounds.width,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y + bounds.height
          });
      }
    } else if (refPoint.y >= bounds.y && refPoint.y <= bounds.y + bounds.height) {
      if (bounds.y + 0.5 * bounds.height >= refPoint.y) {
        refLine = new geometry_2$1.PointToPointLine(refPoint, {
          x: c.x,
          y: refPoint.y
        });
        if (refPoint.x < c.x)
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y
          });
        else
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x + bounds.width,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y
          });
      } else {
        refLine = new geometry_2$1.PointToPointLine(refPoint, {
          x: c.x,
          y: refPoint.y
        });
        if (refPoint.x < c.x)
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y + bounds.height
          });
        else
          outline = new geometry_2$1.PointToPointLine({
            x: bounds.x + bounds.width,
            y: c.y
          }, {
            x: c.x,
            y: bounds.y + bounds.height
          });
      }
    }
    if (!!refLine && !!outline)
      return (0, geometry_2$1.intersection)(outline, refLine);
    else
      return c;
  }
};
manhattanAnchors.ManhattanDiamondAnchor = ManhattanDiamondAnchor;
ManhattanDiamondAnchor.KIND = manhattan_edge_router_1$1.ManhattanEdgeRouter.KIND + ":" + anchor_1$2.DIAMOND_ANCHOR_KIND;
manhattanAnchors.ManhattanDiamondAnchor = ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = __decorate$h([(0, inversify_1$B.injectable)()], ManhattanDiamondAnchor);
let ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = class ManhattanEllipticAnchor2 {
  get kind() {
    return ManhattanEllipticAnchor_1.KIND;
  }
  getAnchor(connectable, refPoint, offset = 0) {
    const b = connectable.bounds;
    if (b.width <= 0 || b.height <= 0) {
      return b;
    }
    const bounds = {
      x: b.x - offset,
      y: b.y - offset,
      width: b.width + 2 * offset,
      height: b.height + 2 * offset
    };
    const c = geometry_1$6.Bounds.center(bounds);
    const refRelative = geometry_1$6.Point.subtract(refPoint, c);
    let x = c.x;
    let y = c.y;
    if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
      x += refRelative.x;
      const dy = 0.5 * bounds.height * Math.sqrt(1 - refRelative.x * refRelative.x / (0.25 * bounds.width * bounds.width));
      if (refRelative.y < 0)
        y -= dy;
      else
        y += dy;
    } else if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
      y += refRelative.y;
      const dx = 0.5 * bounds.width * Math.sqrt(1 - refRelative.y * refRelative.y / (0.25 * bounds.height * bounds.height));
      if (refRelative.x < 0)
        x -= dx;
      else
        x += dx;
    }
    return {
      x,
      y
    };
  }
};
manhattanAnchors.ManhattanEllipticAnchor = ManhattanEllipticAnchor;
ManhattanEllipticAnchor.KIND = manhattan_edge_router_1$1.ManhattanEdgeRouter.KIND + ":" + anchor_1$2.ELLIPTIC_ANCHOR_KIND;
manhattanAnchors.ManhattanEllipticAnchor = ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = __decorate$h([(0, inversify_1$B.injectable)()], ManhattanEllipticAnchor);
var views$1 = {};
var __decorate$g = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(views$1, "__esModule", {
  value: true
});
views$1.RoutableView = void 0;
const inversify_1$A = require$$0$1;
const model_1$a = model$a;
let RoutableView = class RoutableView2 {
  /**
   * Check whether the given model element is in the current viewport. Use this method
   * in your `render` implementation to skip rendering in case the element is not visible.
   * This can greatly enhance performance for large models.
   */
  isVisible(model2, route, context) {
    if (context.targetKind === "hidden") {
      return true;
    }
    if (route.length === 0) {
      return true;
    }
    const ab = (0, model_1$a.getAbsoluteRouteBounds)(model2, route);
    const canvasBounds = model2.root.canvasBounds;
    return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
  }
};
views$1.RoutableView = RoutableView;
views$1.RoutableView = RoutableView = __decorate$g([(0, inversify_1$A.injectable)()], RoutableView);
var select = {};
var requestCommand = {};
var __decorate$f = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$c = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(requestCommand, "__esModule", {
  value: true
});
requestCommand.ModelRequestCommand = void 0;
const inversify_1$z = require$$0$1;
const types_1$r = types;
const command_1$5 = command;
let ModelRequestCommand = class ModelRequestCommand2 extends command_1$5.SystemCommand {
  execute(context) {
    const result = this.retrieveResult(context);
    this.actionDispatcher.dispatch(result);
    return {
      model: context.root,
      modelChanged: false
    };
  }
  undo(context) {
    return {
      model: context.root,
      modelChanged: false
    };
  }
  redo(context) {
    return {
      model: context.root,
      modelChanged: false
    };
  }
};
requestCommand.ModelRequestCommand = ModelRequestCommand;
__decorate$f([(0, inversify_1$z.inject)(types_1$r.TYPES.IActionDispatcher), __metadata$c("design:type", Object)], ModelRequestCommand.prototype, "actionDispatcher", void 0);
requestCommand.ModelRequestCommand = ModelRequestCommand = __decorate$f([(0, inversify_1$z.injectable)()], ModelRequestCommand);
var scroll = {};
var __decorate$e = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$b = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(scroll, "__esModule", {
  value: true
});
scroll.findViewportScrollbar = scroll.ScrollMouseListener = void 0;
const inversify_1$y = require$$0$1;
const actions_1$9 = actions;
const geometry_1$5 = geometry$1;
const smodel_1$6 = smodel;
const mouse_tool_1$1 = mouseTool;
const smodel_utils_1$2 = smodelUtils;
const model_1$9 = model$6;
const model_2$5 = model$8;
const model_3$4 = model$a;
const model_4$2 = model$1;
const browser_1$2 = browser;
const types_1$q = types;
class ScrollMouseListener extends mouse_tool_1$1.MouseListener {
  constructor() {
    super(...arguments);
    this.scrollbarMouseDownDelay = 200;
  }
  mouseDown(target, event) {
    const moveable = (0, smodel_utils_1$2.findParentByFeature)(target, model_2$5.isMoveable);
    if (moveable === void 0 && !(target instanceof model_3$4.SRoutingHandleImpl)) {
      const viewport2 = (0, smodel_utils_1$2.findParentByFeature)(target, model_1$9.isViewport);
      if (viewport2) {
        this.lastScrollPosition = {
          x: event.pageX,
          y: event.pageY
        };
        this.scrollbar = this.getScrollbar(event);
        if (this.scrollbar) {
          window.clearTimeout(this.scrollbarMouseDownTimeout);
          return this.moveScrollBar(viewport2, event, this.scrollbar, true).map((action2) => new Promise((resolve2) => {
            this.scrollbarMouseDownTimeout = window.setTimeout(() => resolve2(action2), this.scrollbarMouseDownDelay);
          }));
        }
      } else {
        this.lastScrollPosition = void 0;
        this.scrollbar = void 0;
      }
    }
    return [];
  }
  mouseMove(target, event) {
    if (event.buttons === 0) {
      return this.mouseUp(target, event);
    }
    if (this.scrollbar) {
      window.clearTimeout(this.scrollbarMouseDownTimeout);
      const viewport2 = (0, smodel_utils_1$2.findParentByFeature)(target, model_1$9.isViewport);
      if (viewport2) {
        return this.moveScrollBar(viewport2, event, this.scrollbar);
      }
    }
    if (this.lastScrollPosition) {
      const viewport2 = (0, smodel_utils_1$2.findParentByFeature)(target, model_1$9.isViewport);
      if (viewport2) {
        return this.dragCanvas(viewport2, event, this.lastScrollPosition);
      }
    }
    return [];
  }
  mouseEnter(target, event) {
    if (target instanceof smodel_1$6.SModelRootImpl && event.buttons === 0) {
      this.mouseUp(target, event);
    }
    return [];
  }
  mouseUp(target, event) {
    this.lastScrollPosition = void 0;
    this.scrollbar = void 0;
    return [];
  }
  doubleClick(target, event) {
    const viewport2 = (0, smodel_utils_1$2.findParentByFeature)(target, model_1$9.isViewport);
    if (viewport2) {
      const scrollbar = this.getScrollbar(event);
      if (scrollbar) {
        window.clearTimeout(this.scrollbarMouseDownTimeout);
        const targetElement = this.findClickTarget(scrollbar, event);
        let elementId;
        if (targetElement && targetElement.id.startsWith("horizontal-projection:")) {
          elementId = targetElement.id.substring("horizontal-projection:".length);
        } else if (targetElement && targetElement.id.startsWith("vertical-projection:")) {
          elementId = targetElement.id.substring("vertical-projection:".length);
        }
        if (elementId) {
          return [actions_1$9.CenterAction.create([elementId], {
            animate: true,
            retainZoom: true
          })];
        }
      }
    }
    return [];
  }
  dragCanvas(model2, event, lastScrollPosition) {
    let dx = (event.pageX - lastScrollPosition.x) / model2.zoom;
    if (dx > 0 && (0, geometry_1$5.almostEquals)(model2.scroll.x, this.viewerOptions.horizontalScrollLimits.min) || dx < 0 && (0, geometry_1$5.almostEquals)(model2.scroll.x, this.viewerOptions.horizontalScrollLimits.max - model2.canvasBounds.width / model2.zoom)) {
      dx = 0;
    }
    let dy = (event.pageY - lastScrollPosition.y) / model2.zoom;
    if (dy > 0 && (0, geometry_1$5.almostEquals)(model2.scroll.y, this.viewerOptions.verticalScrollLimits.min) || dy < 0 && (0, geometry_1$5.almostEquals)(model2.scroll.y, this.viewerOptions.verticalScrollLimits.max - model2.canvasBounds.height / model2.zoom)) {
      dy = 0;
    }
    if (dx === 0 && dy === 0) {
      return [];
    }
    const newViewport = {
      scroll: {
        x: model2.scroll.x - dx,
        y: model2.scroll.y - dy
      },
      zoom: model2.zoom
    };
    this.lastScrollPosition = {
      x: event.pageX,
      y: event.pageY
    };
    return [actions_1$9.SetViewportAction.create(model2.id, newViewport, {
      animate: false
    })];
  }
  moveScrollBar(model2, event, scrollbar, animate = false) {
    const modelBounds = (0, model_4$2.getModelBounds)(model2);
    if (!modelBounds || model2.zoom <= 0) {
      return [];
    }
    const scrollbarRect = scrollbar.getBoundingClientRect();
    let newScroll;
    if (this.getScrollbarOrientation(scrollbar) === "horizontal") {
      if (scrollbarRect.width <= 0) {
        return [];
      }
      const viewportSize = model2.canvasBounds.width / (model2.zoom * modelBounds.width) * scrollbarRect.width;
      let position = event.clientX - scrollbarRect.x - viewportSize / 2;
      if (position < 0) {
        position = 0;
      } else if (position > scrollbarRect.width - viewportSize) {
        position = scrollbarRect.width - viewportSize;
      }
      newScroll = {
        x: modelBounds.x + position / scrollbarRect.width * modelBounds.width,
        y: model2.scroll.y
      };
      if (newScroll.x < this.viewerOptions.horizontalScrollLimits.min) {
        newScroll.x = this.viewerOptions.horizontalScrollLimits.min;
      } else if (newScroll.x > this.viewerOptions.horizontalScrollLimits.max - model2.canvasBounds.width / model2.zoom) {
        newScroll.x = this.viewerOptions.horizontalScrollLimits.max - model2.canvasBounds.width / model2.zoom;
      }
      if ((0, geometry_1$5.almostEquals)(newScroll.x, model2.scroll.x)) {
        return [];
      }
    } else {
      if (scrollbarRect.height <= 0) {
        return [];
      }
      const viewportSize = model2.canvasBounds.height / (model2.zoom * modelBounds.height) * scrollbarRect.height;
      let position = event.clientY - scrollbarRect.y - viewportSize / 2;
      if (position < 0) {
        position = 0;
      } else if (position > scrollbarRect.height - viewportSize) {
        position = scrollbarRect.height - viewportSize;
      }
      newScroll = {
        x: model2.scroll.x,
        y: modelBounds.y + position / scrollbarRect.height * modelBounds.height
      };
      if (newScroll.y < this.viewerOptions.verticalScrollLimits.min) {
        newScroll.y = this.viewerOptions.verticalScrollLimits.min;
      } else if (newScroll.y > this.viewerOptions.verticalScrollLimits.max - model2.canvasBounds.height / model2.zoom) {
        newScroll.y = this.viewerOptions.verticalScrollLimits.max - model2.canvasBounds.height / model2.zoom;
      }
      if ((0, geometry_1$5.almostEquals)(newScroll.y, model2.scroll.y)) {
        return [];
      }
    }
    return [actions_1$9.SetViewportAction.create(model2.id, {
      scroll: newScroll,
      zoom: model2.zoom
    }, {
      animate
    })];
  }
  getScrollbar(event) {
    return findViewportScrollbar(event);
  }
  getScrollbarOrientation(scrollbar) {
    if (scrollbar.classList.contains("horizontal")) {
      return "horizontal";
    } else {
      return "vertical";
    }
  }
  findClickTarget(scrollbar, event) {
    const matching = Array.from(scrollbar.children).filter((child) => child.id && child.classList.contains("sprotty-projection") && (0, browser_1$2.hitsMouseEvent)(child, event));
    if (matching.length > 0) {
      return matching[matching.length - 1];
    }
    return void 0;
  }
}
scroll.ScrollMouseListener = ScrollMouseListener;
__decorate$e([(0, inversify_1$y.inject)(types_1$q.TYPES.ViewerOptions), __metadata$b("design:type", Object)], ScrollMouseListener.prototype, "viewerOptions", void 0);
function findViewportScrollbar(event) {
  let element = event.target;
  while (element) {
    if (element.classList && element.classList.contains("sprotty-projection-bar")) {
      return element;
    }
    element = element.parentElement;
  }
  return void 0;
}
scroll.findViewportScrollbar = findViewportScrollbar;
var __decorate$d = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$a = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$4 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(select, "__esModule", {
  value: true
});
select.SelectKeyboardListener = select.GetSelectionCommand = select.SelectMouseListener = select.SelectAllCommand = select.SelectCommand = void 0;
const inversify_1$x = require$$0$1;
const actions_1$8 = actions;
const command_1$4 = command;
const request_command_1$1 = requestCommand;
const smodel_1$5 = smodel;
const smodel_utils_1$1 = smodelUtils;
const types_1$p = types;
const key_tool_1$2 = keyTool;
const mouse_tool_1 = mouseTool;
const vnode_utils_1$3 = vnodeUtils;
const browser_1$1 = browser;
const iterable_1 = iterable;
const keyboard_1$2 = keyboard;
const button_handler_1$2 = buttonHandler;
const model_1$8 = model$f;
const edit_routing_1 = editRouting;
const model_2$4 = model$a;
const model_3$3 = model$a;
const scroll_1$1 = scroll;
const model_4$1 = model$c;
let SelectCommand = class SelectCommand2 extends command_1$4.Command {
  constructor(action2) {
    super();
    this.action = action2;
    this.selected = [];
    this.deselected = [];
  }
  execute(context) {
    const model2 = context.root;
    this.action.selectedElementsIDs.forEach((id2) => {
      const element = model2.index.getById(id2);
      if (element instanceof smodel_1$5.SChildElementImpl && (0, model_4$1.isSelectable)(element)) {
        this.selected.push(element);
      }
    });
    this.action.deselectedElementsIDs.forEach((id2) => {
      const element = model2.index.getById(id2);
      if (element instanceof smodel_1$5.SChildElementImpl && (0, model_4$1.isSelectable)(element)) {
        this.deselected.push(element);
      }
    });
    return this.redo(context);
  }
  undo(context) {
    for (const element of this.selected) {
      element.selected = false;
    }
    for (const element of this.deselected) {
      element.selected = true;
    }
    return context.root;
  }
  redo(context) {
    for (const element of this.deselected) {
      element.selected = false;
    }
    for (const element of this.selected) {
      element.selected = true;
    }
    return context.root;
  }
};
select.SelectCommand = SelectCommand;
SelectCommand.KIND = actions_1$8.SelectAction.KIND;
select.SelectCommand = SelectCommand = __decorate$d([(0, inversify_1$x.injectable)(), __param$4(0, (0, inversify_1$x.inject)(types_1$p.TYPES.Action)), __metadata$a("design:paramtypes", [Object])], SelectCommand);
let SelectAllCommand = class SelectAllCommand2 extends command_1$4.Command {
  constructor(action2) {
    super();
    this.action = action2;
    this.previousSelection = {};
  }
  execute(context) {
    this.selectAll(context.root, this.action.select);
    return context.root;
  }
  selectAll(element, newState) {
    if ((0, model_4$1.isSelectable)(element)) {
      this.previousSelection[element.id] = element.selected;
      element.selected = newState;
    }
    for (const child of element.children) {
      this.selectAll(child, newState);
    }
  }
  undo(context) {
    const index = context.root.index;
    Object.keys(this.previousSelection).forEach((id2) => {
      const element = index.getById(id2);
      if (element !== void 0 && (0, model_4$1.isSelectable)(element))
        element.selected = this.previousSelection[id2];
    });
    return context.root;
  }
  redo(context) {
    this.selectAll(context.root, this.action.select);
    return context.root;
  }
};
select.SelectAllCommand = SelectAllCommand;
SelectAllCommand.KIND = actions_1$8.SelectAllAction.KIND;
select.SelectAllCommand = SelectAllCommand = __decorate$d([(0, inversify_1$x.injectable)(), __param$4(0, (0, inversify_1$x.inject)(types_1$p.TYPES.Action)), __metadata$a("design:paramtypes", [Object])], SelectAllCommand);
class SelectMouseListener extends mouse_tool_1.MouseListener {
  constructor() {
    super(...arguments);
    this.wasSelected = false;
    this.hasDragged = false;
    this.isMouseDown = false;
  }
  mouseDown(target, event) {
    if (event.button !== 0) {
      return [];
    }
    this.isMouseDown = true;
    const buttonHandled = this.handleButton(target, event);
    if (buttonHandled) {
      return buttonHandled;
    }
    const selectableTarget = (0, smodel_utils_1$1.findParentByFeature)(target, model_4$1.isSelectable);
    if (selectableTarget !== void 0 || target instanceof smodel_1$5.SModelRootImpl) {
      this.hasDragged = false;
    }
    if (selectableTarget !== void 0) {
      let deselectedElements = [];
      if (!(0, browser_1$1.isCtrlOrCmd)(event)) {
        deselectedElements = this.collectElementsToDeselect(target, selectableTarget);
      }
      if (!selectableTarget.selected) {
        this.wasSelected = false;
        return this.handleSelectTarget(selectableTarget, deselectedElements, event);
      } else if ((0, browser_1$1.isCtrlOrCmd)(event)) {
        this.wasSelected = false;
        return this.handleDeselectTarget(selectableTarget, event);
      } else {
        this.wasSelected = true;
      }
    }
    return [];
  }
  collectElementsToDeselect(target, selectableTarget) {
    return (0, iterable_1.toArray)(target.root.index.all().filter((element) => (0, model_4$1.isSelectable)(element) && element.selected && !(selectableTarget instanceof model_2$4.SRoutingHandleImpl && element === selectableTarget.parent)));
  }
  handleButton(target, event) {
    if (this.buttonHandlerRegistry !== void 0 && target instanceof model_1$8.SButtonImpl && target.enabled) {
      const buttonHandler2 = this.buttonHandlerRegistry.get(target.type);
      if (buttonHandler2 !== void 0) {
        return buttonHandler2.buttonPressed(target);
      }
    }
    return void 0;
  }
  handleSelectTarget(selectableTarget, deselectedElements, event) {
    const result = [];
    result.push(actions_1$8.SelectAction.create({
      selectedElementsIDs: [selectableTarget.id],
      deselectedElementsIDs: deselectedElements.map((e) => e.id)
    }));
    result.push(actions_1$8.BringToFrontAction.create([selectableTarget.id]));
    const routableDeselect = deselectedElements.filter((e) => e instanceof model_3$3.SRoutableElementImpl).map((e) => e.id);
    if (selectableTarget instanceof model_3$3.SRoutableElementImpl) {
      result.push(edit_routing_1.SwitchEditModeAction.create({
        elementsToActivate: [selectableTarget.id],
        elementsToDeactivate: routableDeselect
      }));
    } else if (routableDeselect.length > 0) {
      result.push(edit_routing_1.SwitchEditModeAction.create({
        elementsToDeactivate: routableDeselect
      }));
    }
    return result;
  }
  handleDeselectTarget(selectableTarget, event) {
    const result = [];
    result.push(actions_1$8.SelectAction.create({
      selectedElementsIDs: [],
      deselectedElementsIDs: [selectableTarget.id]
    }));
    if (selectableTarget instanceof model_3$3.SRoutableElementImpl) {
      result.push(edit_routing_1.SwitchEditModeAction.create({
        elementsToDeactivate: [selectableTarget.id]
      }));
    }
    return result;
  }
  handleDeselectAll(deselectedElements, event) {
    const result = [];
    result.push(actions_1$8.SelectAction.create({
      selectedElementsIDs: [],
      deselectedElementsIDs: deselectedElements.map((e) => e.id)
    }));
    const routableDeselect = deselectedElements.filter((e) => e instanceof model_3$3.SRoutableElementImpl).map((e) => e.id);
    if (routableDeselect.length > 0) {
      result.push(edit_routing_1.SwitchEditModeAction.create({
        elementsToDeactivate: routableDeselect
      }));
    }
    return result;
  }
  mouseMove(target, event) {
    this.hasDragged = this.isMouseDown;
    return [];
  }
  mouseUp(target, event) {
    if (event.button === 0) {
      if (!this.hasDragged) {
        const selectableTarget = (0, smodel_utils_1$1.findParentByFeature)(target, model_4$1.isSelectable);
        if (selectableTarget !== void 0) {
          if (this.wasSelected) {
            return [actions_1$8.SelectAction.create({
              selectedElementsIDs: [selectableTarget.id],
              deselectedElementsIDs: []
            })];
          }
        } else if (target instanceof smodel_1$5.SModelRootImpl && !(0, scroll_1$1.findViewportScrollbar)(event) || !(target instanceof smodel_1$5.SModelRootImpl)) {
          return this.handleDeselectAll(this.collectElementsToDeselect(target, void 0), event);
        }
      }
    }
    this.isMouseDown = false;
    this.hasDragged = false;
    return [];
  }
  decorate(vnode2, element) {
    const selectableTarget = (0, smodel_utils_1$1.findParentByFeature)(element, model_4$1.isSelectable);
    if (selectableTarget !== void 0) {
      (0, vnode_utils_1$3.setClass)(vnode2, "selected", selectableTarget.selected);
    }
    return vnode2;
  }
}
select.SelectMouseListener = SelectMouseListener;
__decorate$d([(0, inversify_1$x.inject)(button_handler_1$2.ButtonHandlerRegistry), (0, inversify_1$x.optional)(), __metadata$a("design:type", button_handler_1$2.ButtonHandlerRegistry)], SelectMouseListener.prototype, "buttonHandlerRegistry", void 0);
let GetSelectionCommand = class GetSelectionCommand2 extends request_command_1$1.ModelRequestCommand {
  constructor(action2) {
    super();
    this.action = action2;
    this.previousSelection = {};
  }
  retrieveResult(context) {
    const selection = context.root.index.all().filter((e) => (0, model_4$1.isSelectable)(e) && e.selected).map((e) => e.id);
    return actions_1$8.SelectionResult.create((0, iterable_1.toArray)(selection), this.action.requestId);
  }
};
select.GetSelectionCommand = GetSelectionCommand;
GetSelectionCommand.KIND = actions_1$8.GetSelectionAction.KIND;
select.GetSelectionCommand = GetSelectionCommand = __decorate$d([(0, inversify_1$x.injectable)(), __param$4(0, (0, inversify_1$x.inject)(types_1$p.TYPES.Action)), __metadata$a("design:paramtypes", [Object])], GetSelectionCommand);
class SelectKeyboardListener extends key_tool_1$2.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$2.matchesKeystroke)(event, "KeyA", "ctrlCmd")) {
      return [actions_1$8.SelectAllAction.create()];
    }
    return [];
  }
}
select.SelectKeyboardListener = SelectKeyboardListener;
var undoRedo = {};
Object.defineProperty(undoRedo, "__esModule", {
  value: true
});
undoRedo.UndoRedoKeyListener = void 0;
const actions_1$7 = actions;
const keyboard_1$1 = keyboard;
const key_tool_1$1 = keyTool;
const browser_1 = browser;
class UndoRedoKeyListener extends key_tool_1$1.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1$1.matchesKeystroke)(event, "KeyZ", "ctrlCmd"))
      return [actions_1$7.UndoAction.create()];
    if ((0, keyboard_1$1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, browser_1.isMac)() && (0, keyboard_1$1.matchesKeystroke)(event, "KeyY", "ctrlCmd"))
      return [actions_1$7.RedoAction.create()];
    return [];
  }
}
undoRedo.UndoRedoKeyListener = UndoRedoKeyListener;
var modelMatching = {};
Object.defineProperty(modelMatching, "__esModule", {
  value: true
});
modelMatching.applyMatches = modelMatching.ModelMatcher = modelMatching.forEachMatch = void 0;
const smodel_1$4 = smodel;
const sprotty_protocol_1$1 = lib;
function forEachMatch(matchResult, callback) {
  Object.keys(matchResult).forEach((id2) => callback(id2, matchResult[id2]));
}
modelMatching.forEachMatch = forEachMatch;
class ModelMatcher {
  match(left, right) {
    const result = {};
    this.matchLeft(left, result);
    this.matchRight(right, result);
    return result;
  }
  matchLeft(element, result, parentId) {
    let match = result[element.id];
    if (match !== void 0) {
      match.left = element;
      match.leftParentId = parentId;
    } else {
      match = {
        left: element,
        leftParentId: parentId
      };
      result[element.id] = match;
    }
    if ((0, smodel_1$4.isParent)(element)) {
      for (const child of element.children) {
        this.matchLeft(child, result, element.id);
      }
    }
  }
  matchRight(element, result, parentId) {
    let match = result[element.id];
    if (match !== void 0) {
      match.right = element;
      match.rightParentId = parentId;
    } else {
      match = {
        right: element,
        rightParentId: parentId
      };
      result[element.id] = match;
    }
    if ((0, smodel_1$4.isParent)(element)) {
      for (const child of element.children) {
        this.matchRight(child, result, element.id);
      }
    }
  }
}
modelMatching.ModelMatcher = ModelMatcher;
function applyMatches(root, matches, index) {
  if (root instanceof smodel_1$4.SModelRootImpl) {
    index = root.index;
  } else if (index === void 0) {
    index = new sprotty_protocol_1$1.SModelIndex();
    index.add(root);
  }
  for (const match of matches) {
    let newElementInserted = false;
    if (match.left !== void 0 && match.leftParentId !== void 0) {
      const parent = index.getById(match.leftParentId);
      if (parent !== void 0 && parent.children !== void 0) {
        const i = parent.children.indexOf(match.left);
        if (i >= 0) {
          if (match.right !== void 0 && match.leftParentId === match.rightParentId) {
            parent.children.splice(i, 1, match.right);
            newElementInserted = true;
          } else {
            parent.children.splice(i, 1);
          }
        }
        index.remove(match.left);
      }
    }
    if (!newElementInserted && match.right !== void 0 && match.rightParentId !== void 0) {
      const parent = index.getById(match.rightParentId);
      if (parent !== void 0) {
        if (parent.children === void 0)
          parent.children = [];
        parent.children.push(match.right);
      }
    }
  }
}
modelMatching.applyMatches = applyMatches;
var updateModel = {};
var resize = {};
Object.defineProperty(resize, "__esModule", {
  value: true
});
resize.ResizeAnimation = void 0;
const animation_1$2 = animation;
class ResizeAnimation extends animation_1$2.Animation {
  constructor(model2, elementResizes, context, reverse = false) {
    super(context);
    this.model = model2;
    this.elementResizes = elementResizes;
    this.reverse = reverse;
  }
  tween(t) {
    this.elementResizes.forEach((elementResize) => {
      const element = elementResize.element;
      const newDimension = this.reverse ? {
        width: (1 - t) * elementResize.toDimension.width + t * elementResize.fromDimension.width,
        height: (1 - t) * elementResize.toDimension.height + t * elementResize.fromDimension.height
      } : {
        width: (1 - t) * elementResize.fromDimension.width + t * elementResize.toDimension.width,
        height: (1 - t) * elementResize.fromDimension.height + t * elementResize.toDimension.height
      };
      element.bounds = {
        x: element.bounds.x,
        y: element.bounds.y,
        width: newDimension.width,
        height: newDimension.height
      };
    });
    return this.model;
  }
}
resize.ResizeAnimation = ResizeAnimation;
var __decorate$c = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$9 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$3 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(updateModel, "__esModule", {
  value: true
});
updateModel.UpdateModelCommand = void 0;
const inversify_1$w = require$$0$1;
const actions_1$6 = actions;
const geometry_1$4 = geometry$1;
const animation_1$1 = animation;
const command_1$3 = command;
const fade_1$1 = fade;
const smodel_1$3 = smodel;
const move_1$2 = move;
const model_1$7 = model$e;
const model_2$3 = model$8;
const model_3$2 = model$g;
const viewport_root_1 = viewportRoot;
const model_4 = model$c;
const model_matching_1$1 = modelMatching;
const resize_1 = resize;
const types_1$o = types;
const model_5 = model$6;
const routing_1$2 = routing;
const model_6 = model$a;
const smodel_utils_1 = smodelUtils;
let UpdateModelCommand = class UpdateModelCommand2 extends command_1$3.Command {
  constructor(action2) {
    super();
    this.action = action2;
  }
  execute(context) {
    let newRoot;
    if (this.action.newRoot !== void 0) {
      newRoot = context.modelFactory.createRoot(this.action.newRoot);
    } else {
      newRoot = context.modelFactory.createRoot(context.root);
      if (this.action.matches !== void 0)
        this.applyMatches(newRoot, this.action.matches, context);
    }
    this.oldRoot = context.root;
    this.newRoot = newRoot;
    return this.performUpdate(this.oldRoot, this.newRoot, context);
  }
  performUpdate(oldRoot, newRoot, context) {
    if ((this.action.animate === void 0 || this.action.animate) && oldRoot.id === newRoot.id) {
      let matchResult;
      if (this.action.matches === void 0) {
        const matcher = new model_matching_1$1.ModelMatcher();
        matchResult = matcher.match(oldRoot, newRoot);
      } else {
        matchResult = this.convertToMatchResult(this.action.matches, oldRoot, newRoot);
      }
      const animationOrRoot = this.computeAnimation(newRoot, matchResult, context);
      if (animationOrRoot instanceof animation_1$1.Animation)
        return animationOrRoot.start();
      else
        return animationOrRoot;
    } else {
      if (oldRoot.type === newRoot.type && geometry_1$4.Dimension.isValid(oldRoot.canvasBounds))
        newRoot.canvasBounds = oldRoot.canvasBounds;
      if ((0, model_5.isViewport)(oldRoot) && (0, model_5.isViewport)(newRoot)) {
        newRoot.zoom = oldRoot.zoom;
        newRoot.scroll = oldRoot.scroll;
      }
      return newRoot;
    }
  }
  applyMatches(root, matches, context) {
    const index = root.index;
    for (const match of matches) {
      if (match.left !== void 0) {
        const element = index.getById(match.left.id);
        if (element instanceof smodel_1$3.SChildElementImpl)
          element.parent.remove(element);
      }
    }
    for (const match of matches) {
      if (match.right !== void 0) {
        const element = context.modelFactory.createElement(match.right);
        let parent;
        if (match.rightParentId !== void 0)
          parent = index.getById(match.rightParentId);
        if (parent instanceof smodel_1$3.SParentElementImpl)
          parent.add(element);
        else
          root.add(element);
      }
    }
  }
  convertToMatchResult(matches, leftRoot, rightRoot) {
    const result = {};
    for (const match of matches) {
      const converted = {};
      let id2 = void 0;
      if (match.left !== void 0) {
        id2 = match.left.id;
        converted.left = leftRoot.index.getById(id2);
        converted.leftParentId = match.leftParentId;
      }
      if (match.right !== void 0) {
        id2 = match.right.id;
        converted.right = rightRoot.index.getById(id2);
        converted.rightParentId = match.rightParentId;
      }
      if (id2 !== void 0)
        result[id2] = converted;
    }
    return result;
  }
  computeAnimation(newRoot, matchResult, context) {
    const animationData = {
      fades: []
    };
    (0, model_matching_1$1.forEachMatch)(matchResult, (id2, match) => {
      if (match.left !== void 0 && match.right !== void 0) {
        this.updateElement(match.left, match.right, animationData);
      } else if (match.right !== void 0) {
        const right = match.right;
        if ((0, model_1$7.isFadeable)(right)) {
          right.opacity = 0;
          animationData.fades.push({
            element: right,
            type: "in"
          });
        }
      } else if (match.left instanceof smodel_1$3.SChildElementImpl) {
        const left = match.left;
        if ((0, model_1$7.isFadeable)(left) && match.leftParentId !== void 0) {
          if (!(0, smodel_utils_1.containsSome)(newRoot, left)) {
            const parent = newRoot.index.getById(match.leftParentId);
            if (parent instanceof smodel_1$3.SParentElementImpl) {
              const leftCopy = context.modelFactory.createElement(left);
              parent.add(leftCopy);
              animationData.fades.push({
                element: leftCopy,
                type: "out"
              });
            }
          }
        }
      }
    });
    const animations = this.createAnimations(animationData, newRoot, context);
    if (animations.length >= 2) {
      return new animation_1$1.CompoundAnimation(newRoot, context, animations);
    } else if (animations.length === 1) {
      return animations[0];
    } else {
      return newRoot;
    }
  }
  updateElement(left, right, animationData) {
    if ((0, model_2$3.isLocateable)(left) && (0, model_2$3.isLocateable)(right)) {
      const leftPos = left.position;
      const rightPos = right.position;
      if (!(0, geometry_1$4.almostEquals)(leftPos.x, rightPos.x) || !(0, geometry_1$4.almostEquals)(leftPos.y, rightPos.y)) {
        if (animationData.moves === void 0)
          animationData.moves = [];
        animationData.moves.push({
          element: right,
          fromPosition: leftPos,
          toPosition: rightPos
        });
        right.position = leftPos;
      }
    }
    if ((0, model_3$2.isSizeable)(left) && (0, model_3$2.isSizeable)(right)) {
      if (!geometry_1$4.Dimension.isValid(right.bounds)) {
        right.bounds = {
          x: right.bounds.x,
          y: right.bounds.y,
          width: left.bounds.width,
          height: left.bounds.height
        };
      } else if (!(0, geometry_1$4.almostEquals)(left.bounds.width, right.bounds.width) || !(0, geometry_1$4.almostEquals)(left.bounds.height, right.bounds.height)) {
        if (animationData.resizes === void 0)
          animationData.resizes = [];
        animationData.resizes.push({
          element: right,
          fromDimension: {
            width: left.bounds.width,
            height: left.bounds.height
          },
          toDimension: {
            width: right.bounds.width,
            height: right.bounds.height
          }
        });
      }
    }
    if (left instanceof model_6.SRoutableElementImpl && right instanceof model_6.SRoutableElementImpl && this.edgeRouterRegistry) {
      if (animationData.edgeMementi === void 0)
        animationData.edgeMementi = [];
      animationData.edgeMementi.push({
        edge: right,
        before: this.takeSnapshot(left),
        after: this.takeSnapshot(right)
      });
    }
    if ((0, model_4.isSelectable)(left) && (0, model_4.isSelectable)(right)) {
      right.selected = left.selected;
    }
    if (left instanceof smodel_1$3.SModelRootImpl && right instanceof smodel_1$3.SModelRootImpl) {
      right.canvasBounds = left.canvasBounds;
    }
    if (left instanceof viewport_root_1.ViewportRootElementImpl && right instanceof viewport_root_1.ViewportRootElementImpl) {
      right.scroll = left.scroll;
      right.zoom = left.zoom;
    }
  }
  takeSnapshot(edge) {
    const router = this.edgeRouterRegistry.get(edge.routerKind);
    return router.takeSnapshot(edge);
  }
  createAnimations(data, root, context) {
    const animations = [];
    if (data.fades.length > 0) {
      animations.push(new fade_1$1.FadeAnimation(root, data.fades, context, true));
    }
    if (data.moves !== void 0 && data.moves.length > 0) {
      const movesMap = /* @__PURE__ */ new Map();
      for (const move2 of data.moves) {
        movesMap.set(move2.element.id, move2);
      }
      animations.push(new move_1$2.MoveAnimation(root, movesMap, context, false));
    }
    if (data.resizes !== void 0 && data.resizes.length > 0) {
      const resizesMap = /* @__PURE__ */ new Map();
      for (const resize2 of data.resizes) {
        resizesMap.set(resize2.element.id, resize2);
      }
      animations.push(new resize_1.ResizeAnimation(root, resizesMap, context, false));
    }
    if (data.edgeMementi !== void 0 && data.edgeMementi.length > 0) {
      animations.push(new move_1$2.MorphEdgesAnimation(root, data.edgeMementi, context, false));
    }
    return animations;
  }
  undo(context) {
    return this.performUpdate(this.newRoot, this.oldRoot, context);
  }
  redo(context) {
    return this.performUpdate(this.oldRoot, this.newRoot, context);
  }
};
updateModel.UpdateModelCommand = UpdateModelCommand;
UpdateModelCommand.KIND = actions_1$6.UpdateModelAction.KIND;
__decorate$c([(0, inversify_1$w.inject)(routing_1$2.EdgeRouterRegistry), (0, inversify_1$w.optional)(), __metadata$9("design:type", routing_1$2.EdgeRouterRegistry)], UpdateModelCommand.prototype, "edgeRouterRegistry", void 0);
updateModel.UpdateModelCommand = UpdateModelCommand = __decorate$c([(0, inversify_1$w.injectable)(), __param$3(0, (0, inversify_1$w.inject)(types_1$o.TYPES.Action)), __metadata$9("design:paramtypes", [Object])], UpdateModelCommand);
var centerFit = {};
var viewport = {};
var __decorate$b = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$8 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$2 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SetViewportCommand_1;
Object.defineProperty(viewport, "__esModule", {
  value: true
});
viewport.ViewportAnimation = viewport.GetViewportCommand = viewport.SetViewportCommand = void 0;
const inversify_1$v = require$$0$1;
const actions_1$5 = actions;
const geometry_1$3 = geometry$1;
const command_1$2 = command;
const animation_1 = animation;
const model_1$6 = model$6;
const types_1$n = types;
const request_command_1 = requestCommand;
let SetViewportCommand = SetViewportCommand_1 = class SetViewportCommand2 extends command_1$2.MergeableCommand {
  constructor(action2) {
    super();
    this.action = action2;
    this.newViewport = action2.newViewport;
  }
  execute(context) {
    const model2 = context.root;
    const element = model2.index.getById(this.action.elementId);
    if (element && (0, model_1$6.isViewport)(element)) {
      this.element = element;
      this.oldViewport = {
        scroll: this.element.scroll,
        zoom: this.element.zoom
      };
      const {
        zoomLimits,
        horizontalScrollLimits,
        verticalScrollLimits
      } = this.viewerOptions;
      this.newViewport = (0, model_1$6.limitViewport)(this.newViewport, model2.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
      return this.setViewport(element, this.oldViewport, this.newViewport, context);
    }
    return context.root;
  }
  setViewport(element, oldViewport, newViewport, context) {
    if (element && (0, model_1$6.isViewport)(element)) {
      if (this.action.animate) {
        return new ViewportAnimation(element, oldViewport, newViewport, context).start();
      } else {
        element.scroll = newViewport.scroll;
        element.zoom = newViewport.zoom;
      }
    }
    return context.root;
  }
  undo(context) {
    return this.setViewport(this.element, this.newViewport, this.oldViewport, context);
  }
  redo(context) {
    return this.setViewport(this.element, this.oldViewport, this.newViewport, context);
  }
  merge(command2, context) {
    if (!this.action.animate && command2 instanceof SetViewportCommand_1 && this.element === command2.element) {
      this.newViewport = command2.newViewport;
      return true;
    }
    return false;
  }
};
viewport.SetViewportCommand = SetViewportCommand;
SetViewportCommand.KIND = actions_1$5.SetViewportAction.KIND;
__decorate$b([(0, inversify_1$v.inject)(types_1$n.TYPES.ViewerOptions), __metadata$8("design:type", Object)], SetViewportCommand.prototype, "viewerOptions", void 0);
viewport.SetViewportCommand = SetViewportCommand = SetViewportCommand_1 = __decorate$b([(0, inversify_1$v.injectable)(), __param$2(0, (0, inversify_1$v.inject)(types_1$n.TYPES.Action)), __metadata$8("design:paramtypes", [Object])], SetViewportCommand);
let GetViewportCommand = class GetViewportCommand2 extends request_command_1.ModelRequestCommand {
  constructor(action2) {
    super();
    this.action = action2;
  }
  retrieveResult(context) {
    const elem = context.root;
    let viewport2;
    if ((0, model_1$6.isViewport)(elem)) {
      viewport2 = {
        scroll: elem.scroll,
        zoom: elem.zoom
      };
    } else {
      viewport2 = {
        scroll: geometry_1$3.Point.ORIGIN,
        zoom: 1
      };
    }
    return actions_1$5.ViewportResult.create(viewport2, elem.canvasBounds, this.action.requestId);
  }
};
viewport.GetViewportCommand = GetViewportCommand;
GetViewportCommand.KIND = actions_1$5.GetViewportAction.KIND;
viewport.GetViewportCommand = GetViewportCommand = __decorate$b([__param$2(0, (0, inversify_1$v.inject)(types_1$n.TYPES.Action)), __metadata$8("design:paramtypes", [Object])], GetViewportCommand);
class ViewportAnimation extends animation_1.Animation {
  constructor(element, oldViewport, newViewport, context) {
    super(context);
    this.element = element;
    this.oldViewport = oldViewport;
    this.newViewport = newViewport;
    this.context = context;
    this.zoomFactor = Math.log(newViewport.zoom / oldViewport.zoom);
  }
  tween(t, context) {
    this.element.scroll = {
      x: (1 - t) * this.oldViewport.scroll.x + t * this.newViewport.scroll.x,
      y: (1 - t) * this.oldViewport.scroll.y + t * this.newViewport.scroll.y
    };
    this.element.zoom = this.oldViewport.zoom * Math.exp(t * this.zoomFactor);
    return context.root;
  }
}
viewport.ViewportAnimation = ViewportAnimation;
var __decorate$a = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$7 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param$1 = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(centerFit, "__esModule", {
  value: true
});
centerFit.CenterKeyboardListener = centerFit.FitToScreenCommand = centerFit.CenterCommand = centerFit.BoundsAwareViewportCommand = void 0;
const actions_1$4 = actions;
const geometry_1$2 = geometry$1;
const keyboard_1 = keyboard;
const smodel_1$2 = smodel;
const command_1$1 = command;
const key_tool_1 = keyTool;
const model_1$5 = model$g;
const model_2$2 = model$c;
const viewport_1$2 = viewport;
const model_3$1 = model$6;
const inversify_1$u = require$$0$1;
const types_1$m = types;
let BoundsAwareViewportCommand = class BoundsAwareViewportCommand2 extends command_1$1.Command {
  constructor(animate) {
    super();
    this.animate = animate;
  }
  initialize(model2) {
    if (!(0, model_3$1.isViewport)(model2)) {
      return;
    }
    this.oldViewport = {
      scroll: model2.scroll,
      zoom: model2.zoom
    };
    const allBounds = [];
    this.getElementIds().forEach((id2) => {
      const element = model2.index.getById(id2);
      if (element && (0, model_1$5.isBoundsAware)(element)) {
        allBounds.push(this.boundsInViewport(element, element.bounds, model2));
      }
    });
    if (allBounds.length === 0) {
      model2.index.all().forEach((element) => {
        if ((0, model_2$2.isSelectable)(element) && element.selected && (0, model_1$5.isBoundsAware)(element)) {
          allBounds.push(this.boundsInViewport(element, element.bounds, model2));
        }
      });
    }
    if (allBounds.length === 0) {
      model2.index.all().forEach((element) => {
        if ((0, model_1$5.isBoundsAware)(element)) {
          allBounds.push(this.boundsInViewport(element, element.bounds, model2));
        }
      });
    }
    if (allBounds.length !== 0) {
      const bounds = allBounds.reduce((b0, b1) => geometry_1$2.Bounds.combine(b0, b1));
      if (geometry_1$2.Dimension.isValid(bounds)) {
        const newViewport = this.getNewViewport(bounds, model2);
        if (newViewport) {
          const {
            zoomLimits,
            horizontalScrollLimits,
            verticalScrollLimits
          } = this.viewerOptions;
          this.newViewport = (0, model_3$1.limitViewport)(newViewport, model2.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
        }
      }
    }
  }
  boundsInViewport(element, bounds, viewport2) {
    if (element instanceof smodel_1$2.SChildElementImpl && element.parent !== viewport2)
      return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport2);
    else
      return bounds;
  }
  execute(context) {
    this.initialize(context.root);
    return this.redo(context);
  }
  undo(context) {
    const model2 = context.root;
    if ((0, model_3$1.isViewport)(model2) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
      if (this.animate)
        return new viewport_1$2.ViewportAnimation(model2, this.newViewport, this.oldViewport, context).start();
      else {
        model2.scroll = this.oldViewport.scroll;
        model2.zoom = this.oldViewport.zoom;
      }
    }
    return model2;
  }
  redo(context) {
    const model2 = context.root;
    if ((0, model_3$1.isViewport)(model2) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
      if (this.animate) {
        return new viewport_1$2.ViewportAnimation(model2, this.oldViewport, this.newViewport, context).start();
      } else {
        model2.scroll = this.newViewport.scroll;
        model2.zoom = this.newViewport.zoom;
      }
    }
    return model2;
  }
  equal(vp1, vp2) {
    return (0, geometry_1$2.almostEquals)(vp1.zoom, vp2.zoom) && (0, geometry_1$2.almostEquals)(vp1.scroll.x, vp2.scroll.x) && (0, geometry_1$2.almostEquals)(vp1.scroll.y, vp2.scroll.y);
  }
};
centerFit.BoundsAwareViewportCommand = BoundsAwareViewportCommand;
__decorate$a([(0, inversify_1$u.inject)(types_1$m.TYPES.ViewerOptions), __metadata$7("design:type", Object)], BoundsAwareViewportCommand.prototype, "viewerOptions", void 0);
centerFit.BoundsAwareViewportCommand = BoundsAwareViewportCommand = __decorate$a([(0, inversify_1$u.injectable)(), __metadata$7("design:paramtypes", [Boolean])], BoundsAwareViewportCommand);
let CenterCommand = class CenterCommand2 extends BoundsAwareViewportCommand {
  constructor(action2) {
    super(action2.animate);
    this.action = action2;
  }
  getElementIds() {
    return this.action.elementIds;
  }
  getNewViewport(bounds, model2) {
    if (!geometry_1$2.Dimension.isValid(model2.canvasBounds)) {
      return void 0;
    }
    let zoom2 = 1;
    if (this.action.retainZoom && (0, model_3$1.isViewport)(model2)) {
      zoom2 = model2.zoom;
    } else if (this.action.zoomScale) {
      zoom2 = this.action.zoomScale;
    }
    const c = geometry_1$2.Bounds.center(bounds);
    return {
      scroll: {
        x: c.x - 0.5 * model2.canvasBounds.width / zoom2,
        y: c.y - 0.5 * model2.canvasBounds.height / zoom2
      },
      zoom: zoom2
    };
  }
};
centerFit.CenterCommand = CenterCommand;
CenterCommand.KIND = actions_1$4.CenterAction.KIND;
centerFit.CenterCommand = CenterCommand = __decorate$a([__param$1(0, (0, inversify_1$u.inject)(types_1$m.TYPES.Action)), __metadata$7("design:paramtypes", [Object])], CenterCommand);
let FitToScreenCommand = class FitToScreenCommand2 extends BoundsAwareViewportCommand {
  constructor(action2) {
    super(action2.animate);
    this.action = action2;
  }
  getElementIds() {
    return this.action.elementIds;
  }
  getNewViewport(bounds, model2) {
    if (!geometry_1$2.Dimension.isValid(model2.canvasBounds)) {
      return void 0;
    }
    const c = geometry_1$2.Bounds.center(bounds);
    const delta = this.action.padding === void 0 ? 0 : 2 * this.action.padding;
    let zoom2 = Math.min(model2.canvasBounds.width / (bounds.width + delta), model2.canvasBounds.height / (bounds.height + delta));
    if (this.action.maxZoom !== void 0)
      zoom2 = Math.min(zoom2, this.action.maxZoom);
    if (zoom2 === Infinity) {
      zoom2 = 1;
    }
    return {
      scroll: {
        x: c.x - 0.5 * model2.canvasBounds.width / zoom2,
        y: c.y - 0.5 * model2.canvasBounds.height / zoom2
      },
      zoom: zoom2
    };
  }
};
centerFit.FitToScreenCommand = FitToScreenCommand;
FitToScreenCommand.KIND = actions_1$4.FitToScreenAction.KIND;
centerFit.FitToScreenCommand = FitToScreenCommand = __decorate$a([__param$1(0, (0, inversify_1$u.inject)(types_1$m.TYPES.Action)), __metadata$7("design:paramtypes", [Object])], FitToScreenCommand);
class CenterKeyboardListener extends key_tool_1.KeyListener {
  keyDown(element, event) {
    if ((0, keyboard_1.matchesKeystroke)(event, "KeyC", "ctrlCmd", "shift"))
      return [actions_1$4.CenterAction.create([])];
    if ((0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrlCmd", "shift"))
      return [actions_1$4.FitToScreenAction.create([])];
    return [];
  }
}
centerFit.CenterKeyboardListener = CenterKeyboardListener;
var zorder = {};
var __decorate$9 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$6 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __param = commonjsGlobal && commonjsGlobal.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
Object.defineProperty(zorder, "__esModule", {
  value: true
});
zorder.BringToFrontCommand = void 0;
const inversify_1$t = require$$0$1;
const actions_1$3 = actions;
const types_1$l = types;
const smodel_1$1 = smodel;
const command_1 = command;
const model_1$4 = model$a;
let BringToFrontCommand = class BringToFrontCommand2 extends command_1.Command {
  constructor(action2) {
    super();
    this.action = action2;
    this.selected = [];
  }
  execute(context) {
    const model2 = context.root;
    this.action.elementIDs.forEach((id2) => {
      const element = model2.index.getById(id2);
      if (element instanceof model_1$4.SRoutableElementImpl) {
        if (element.source)
          this.addToSelection(element.source);
        if (element.target)
          this.addToSelection(element.target);
      }
      if (element instanceof smodel_1$1.SChildElementImpl) {
        this.addToSelection(element);
      }
      this.includeConnectedEdges(element);
    });
    return this.redo(context);
  }
  includeConnectedEdges(element) {
    if (element instanceof model_1$4.SConnectableElementImpl) {
      element.incomingEdges.forEach((edge) => this.addToSelection(edge));
      element.outgoingEdges.forEach((edge) => this.addToSelection(edge));
    }
    if (element instanceof smodel_1$1.SParentElementImpl) {
      for (const child of element.children) {
        this.includeConnectedEdges(child);
      }
    }
  }
  addToSelection(element) {
    this.selected.push({
      element,
      index: element.parent.children.indexOf(element)
    });
  }
  undo(context) {
    for (let i = this.selected.length - 1; i >= 0; i--) {
      const selection = this.selected[i];
      const element = selection.element;
      element.parent.move(element, selection.index);
    }
    return context.root;
  }
  redo(context) {
    for (let i = 0; i < this.selected.length; i++) {
      this.bringToFront(this.selected[i]);
    }
    return context.root;
  }
  bringToFront(selection) {
    const element = selection.element;
    const childrenLength = element.parent.children.length;
    element.parent.move(element, childrenLength - 1);
  }
};
zorder.BringToFrontCommand = BringToFrontCommand;
BringToFrontCommand.KIND = actions_1$3.BringToFrontAction.KIND;
zorder.BringToFrontCommand = BringToFrontCommand = __decorate$9([(0, inversify_1$t.injectable)(), __param(0, (0, inversify_1$t.inject)(types_1$l.TYPES.Action)), __metadata$6("design:paramtypes", [Object])], BringToFrontCommand);
var di_config$j = {};
Object.defineProperty(di_config$j, "__esModule", {
  value: true
});
const inversify_1$s = require$$0$1;
const types_1$k = types;
const bounds_manipulation_1$1 = boundsManipulation;
const hidden_bounds_updater_1 = hiddenBoundsUpdater;
const layout_1 = layout;
const command_registration_1$9 = commandRegistration;
const hbox_layout_1 = hboxLayout;
const vbox_layout_1 = vboxLayout;
const stack_layout_1 = stackLayout;
const boundsModule = new inversify_1$s.ContainerModule((bind, _unbind, isBound) => {
  (0, command_registration_1$9.configureCommand)({
    bind,
    isBound
  }, bounds_manipulation_1$1.SetBoundsCommand);
  (0, command_registration_1$9.configureCommand)({
    bind,
    isBound
  }, bounds_manipulation_1$1.RequestBoundsCommand);
  bind(hidden_bounds_updater_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
  bind(types_1$k.TYPES.HiddenVNodePostprocessor).toService(hidden_bounds_updater_1.HiddenBoundsUpdater);
  bind(types_1$k.TYPES.Layouter).to(layout_1.Layouter).inSingletonScope();
  bind(types_1$k.TYPES.LayoutRegistry).to(layout_1.LayoutRegistry).inSingletonScope();
  (0, layout_1.configureLayout)({
    bind,
    isBound
  }, vbox_layout_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouter);
  (0, layout_1.configureLayout)({
    bind,
    isBound
  }, hbox_layout_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouter);
  (0, layout_1.configureLayout)({
    bind,
    isBound
  }, stack_layout_1.StackLayouter.KIND, stack_layout_1.StackLayouter);
});
di_config$j.default = boundsModule;
var di_config$i = {};
Object.defineProperty(di_config$i, "__esModule", {
  value: true
});
const inversify_1$r = require$$0$1;
const button_handler_1$1 = buttonHandler;
const buttonModule = new inversify_1$r.ContainerModule((bind) => {
  bind(button_handler_1$1.ButtonHandlerRegistry).toSelf().inSingletonScope();
});
di_config$i.default = buttonModule;
var di_config$h = {};
Object.defineProperty(di_config$h, "__esModule", {
  value: true
});
const inversify_1$q = require$$0$1;
const types_1$j = types;
const action_providers_1 = actionProviders;
const command_palette_1 = commandPalette;
const commandPaletteModule = new inversify_1$q.ContainerModule((bind) => {
  bind(command_palette_1.CommandPalette).toSelf().inSingletonScope();
  bind(types_1$j.TYPES.IUIExtension).toService(command_palette_1.CommandPalette);
  bind(command_palette_1.CommandPaletteKeyListener).toSelf().inSingletonScope();
  bind(types_1$j.TYPES.KeyListener).toService(command_palette_1.CommandPaletteKeyListener);
  bind(action_providers_1.CommandPaletteActionProviderRegistry).toSelf().inSingletonScope();
  bind(types_1$j.TYPES.ICommandPaletteActionProviderRegistry).toService(action_providers_1.CommandPaletteActionProviderRegistry);
});
di_config$h.default = commandPaletteModule;
var di_config$g = {};
Object.defineProperty(di_config$g, "__esModule", {
  value: true
});
const inversify_1$p = require$$0$1;
const menu_providers_1 = menuProviders;
const mouse_listener_1 = mouseListener;
const types_1$i = types;
const contextMenuModule = new inversify_1$p.ContainerModule((bind) => {
  bind(types_1$i.TYPES.IContextMenuServiceProvider).toProvider((ctx) => {
    return () => {
      return new Promise((resolve2, reject) => {
        if (ctx.container.isBound(types_1$i.TYPES.IContextMenuService)) {
          resolve2(ctx.container.get(types_1$i.TYPES.IContextMenuService));
        } else {
          reject();
        }
      });
    };
  });
  bind(mouse_listener_1.ContextMenuMouseListener).toSelf().inSingletonScope();
  bind(types_1$i.TYPES.MouseListener).toService(mouse_listener_1.ContextMenuMouseListener);
  bind(types_1$i.TYPES.IContextMenuProviderRegistry).to(menu_providers_1.ContextMenuProviderRegistry);
});
di_config$g.default = contextMenuModule;
var di_config$f = {};
Object.defineProperty(di_config$f, "__esModule", {
  value: true
});
const view_1 = view;
const inversify_1$o = require$$0$1;
const model_1$3 = model$3;
const views_1$2 = views$3;
const types_1$h = types;
const decoration_placer_1 = decorationPlacer;
const decorationModule = new inversify_1$o.ContainerModule((bind, _unbind, isBound) => {
  (0, view_1.configureModelElement)({
    bind,
    isBound
  }, "marker", model_1$3.SIssueMarkerImpl, views_1$2.IssueMarkerView);
  bind(decoration_placer_1.DecorationPlacer).toSelf().inSingletonScope();
  bind(types_1$h.TYPES.IVNodePostprocessor).toService(decoration_placer_1.DecorationPlacer);
});
di_config$f.default = decorationModule;
var di_config$e = {};
Object.defineProperty(di_config$e, "__esModule", {
  value: true
});
const inversify_1$n = require$$0$1;
const types_1$g = types;
const intersection_finder_1$1 = intersectionFinder;
const edgeIntersectionModule = new inversify_1$n.ContainerModule((bind) => {
  bind(intersection_finder_1$1.IntersectionFinder).toSelf().inSingletonScope();
  bind(types_1$g.TYPES.IEdgeRoutePostprocessor).toService(intersection_finder_1$1.IntersectionFinder);
});
di_config$e.default = edgeIntersectionModule;
var di_config$d = {};
var junctionPostprocessor = {};
var __decorate$8 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(junctionPostprocessor, "__esModule", {
  value: true
});
junctionPostprocessor.JunctionPostProcessor = void 0;
const inversify_1$m = require$$0$1;
const types_1$f = types;
let JunctionPostProcessor = class JunctionPostProcessor2 {
  decorate(vnode2, element) {
    return vnode2;
  }
  postUpdate(cause) {
    const baseDiv = this.viewerOptions.baseDiv;
    const svg2 = document.querySelector(`#${baseDiv} > svg > g`);
    if (svg2) {
      const junctionGroups = Array.from(document.querySelectorAll("g.sprotty-junction"));
      junctionGroups.forEach((junctionGroup) => {
        junctionGroup.remove();
      });
      svg2.append(...junctionGroups);
    }
  }
};
junctionPostprocessor.JunctionPostProcessor = JunctionPostProcessor;
__decorate$8([(0, inversify_1$m.inject)(types_1$f.TYPES.ViewerOptions), __metadata$5("design:type", Object)], JunctionPostProcessor.prototype, "viewerOptions", void 0);
junctionPostprocessor.JunctionPostProcessor = JunctionPostProcessor = __decorate$8([(0, inversify_1$m.injectable)()], JunctionPostProcessor);
Object.defineProperty(di_config$d, "__esModule", {
  value: true
});
const inversify_1$l = require$$0$1;
const types_1$e = types;
const junction_finder_1 = junctionFinder;
const junction_postprocessor_1 = junctionPostprocessor;
const edgeJunctionModule = new inversify_1$l.ContainerModule((bind) => {
  bind(junction_finder_1.JunctionFinder).toSelf().inSingletonScope();
  bind(types_1$e.TYPES.IEdgeRoutePostprocessor).toService(junction_finder_1.JunctionFinder);
  bind(junction_postprocessor_1.JunctionPostProcessor).toSelf().inSingletonScope();
  bind(types_1$e.TYPES.IVNodePostprocessor).toService(junction_postprocessor_1.JunctionPostProcessor);
});
di_config$d.default = edgeJunctionModule;
var di_config$c = {};
Object.defineProperty(di_config$c, "__esModule", {
  value: true
});
const inversify_1$k = require$$0$1;
const button_handler_1 = buttonHandler;
const expand_1 = expand;
const expandModule = new inversify_1$k.ContainerModule((bind, _unbind, isBound) => {
  (0, button_handler_1.configureButtonHandler)({
    bind,
    isBound
  }, expand_1.ExpandButtonHandler.TYPE, expand_1.ExpandButtonHandler);
});
di_config$c.default = expandModule;
var di_config$b = {};
Object.defineProperty(di_config$b, "__esModule", {
  value: true
});
const inversify_1$j = require$$0$1;
const types_1$d = types;
const export_1 = _export;
const svg_exporter_1$2 = svgExporter;
const command_registration_1$8 = commandRegistration;
const exportSvgModule = new inversify_1$j.ContainerModule((bind, _unbind, isBound) => {
  bind(export_1.ExportSvgKeyListener).toSelf().inSingletonScope();
  bind(types_1$d.TYPES.KeyListener).toService(export_1.ExportSvgKeyListener);
  bind(export_1.ExportSvgPostprocessor).toSelf().inSingletonScope();
  bind(types_1$d.TYPES.HiddenVNodePostprocessor).toService(export_1.ExportSvgPostprocessor);
  (0, command_registration_1$8.configureCommand)({
    bind,
    isBound
  }, export_1.ExportSvgCommand);
  bind(types_1$d.TYPES.SvgExporter).to(svg_exporter_1$2.SvgExporter).inSingletonScope();
});
di_config$b.default = exportSvgModule;
var di_config$a = {};
Object.defineProperty(di_config$a, "__esModule", {
  value: true
});
const inversify_1$i = require$$0$1;
const types_1$c = types;
const fade_1 = fade;
const fadeModule = new inversify_1$i.ContainerModule((bind) => {
  bind(fade_1.ElementFader).toSelf().inSingletonScope();
  bind(types_1$c.TYPES.IVNodePostprocessor).toService(fade_1.ElementFader);
});
di_config$a.default = fadeModule;
var di_config$9 = {};
var popupPositionUpdater = {};
var __decorate$7 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(popupPositionUpdater, "__esModule", {
  value: true
});
popupPositionUpdater.PopupPositionUpdater = void 0;
const inversify_1$h = require$$0$1;
const types_1$b = types;
let PopupPositionUpdater = class PopupPositionUpdater2 {
  decorate(vnode2, element) {
    return vnode2;
  }
  postUpdate() {
    const popupDiv = document.getElementById(this.options.popupDiv);
    if (popupDiv !== null && typeof window !== "undefined") {
      const boundingClientRect = popupDiv.getBoundingClientRect();
      if (window.innerHeight < boundingClientRect.height + boundingClientRect.top) {
        popupDiv.style.top = window.pageYOffset + window.innerHeight - boundingClientRect.height - 5 + "px";
      }
      if (window.innerWidth < boundingClientRect.left + boundingClientRect.width) {
        popupDiv.style.left = window.pageXOffset + window.innerWidth - boundingClientRect.width - 5 + "px";
      }
      if (boundingClientRect.left < 0) {
        popupDiv.style.left = "0px";
      }
      if (boundingClientRect.top < 0) {
        popupDiv.style.top = "0px";
      }
    }
  }
};
popupPositionUpdater.PopupPositionUpdater = PopupPositionUpdater;
__decorate$7([(0, inversify_1$h.inject)(types_1$b.TYPES.ViewerOptions), __metadata$4("design:type", Object)], PopupPositionUpdater.prototype, "options", void 0);
popupPositionUpdater.PopupPositionUpdater = PopupPositionUpdater = __decorate$7([(0, inversify_1$h.injectable)()], PopupPositionUpdater);
Object.defineProperty(di_config$9, "__esModule", {
  value: true
});
const inversify_1$g = require$$0$1;
const types_1$a = types;
const hover_1 = hover;
const popup_position_updater_1 = popupPositionUpdater;
const command_registration_1$7 = commandRegistration;
const action_handler_1 = actionHandler$1;
const center_fit_1$1 = centerFit;
const viewport_1$1 = viewport;
const move_1$1 = move;
const hoverModule = new inversify_1$g.ContainerModule((bind, _unbind, isBound) => {
  bind(popup_position_updater_1.PopupPositionUpdater).toSelf().inSingletonScope();
  bind(types_1$a.TYPES.PopupVNodePostprocessor).toService(popup_position_updater_1.PopupPositionUpdater);
  bind(hover_1.HoverMouseListener).toSelf().inSingletonScope();
  bind(types_1$a.TYPES.MouseListener).toService(hover_1.HoverMouseListener);
  bind(hover_1.PopupHoverMouseListener).toSelf().inSingletonScope();
  bind(types_1$a.TYPES.PopupMouseListener).toService(hover_1.PopupHoverMouseListener);
  bind(hover_1.HoverKeyListener).toSelf().inSingletonScope();
  bind(types_1$a.TYPES.KeyListener).toService(hover_1.HoverKeyListener);
  bind(types_1$a.TYPES.HoverState).toConstantValue({
    mouseOverTimer: void 0,
    mouseOutTimer: void 0,
    popupOpen: false,
    previousPopupElement: void 0
  });
  bind(hover_1.ClosePopupActionHandler).toSelf().inSingletonScope();
  const context = {
    bind,
    isBound
  };
  (0, command_registration_1$7.configureCommand)(context, hover_1.HoverFeedbackCommand);
  (0, command_registration_1$7.configureCommand)(context, hover_1.SetPopupModelCommand);
  (0, action_handler_1.configureActionHandler)(context, hover_1.SetPopupModelCommand.KIND, hover_1.ClosePopupActionHandler);
  (0, action_handler_1.configureActionHandler)(context, center_fit_1$1.FitToScreenCommand.KIND, hover_1.ClosePopupActionHandler);
  (0, action_handler_1.configureActionHandler)(context, center_fit_1$1.CenterCommand.KIND, hover_1.ClosePopupActionHandler);
  (0, action_handler_1.configureActionHandler)(context, viewport_1$1.SetViewportCommand.KIND, hover_1.ClosePopupActionHandler);
  (0, action_handler_1.configureActionHandler)(context, move_1$1.MoveCommand.KIND, hover_1.ClosePopupActionHandler);
});
di_config$9.default = hoverModule;
var di_config$8 = {};
Object.defineProperty(di_config$8, "__esModule", {
  value: true
});
const inversify_1$f = require$$0$1;
const types_1$9 = types;
const move_1 = move;
const command_registration_1$6 = commandRegistration;
const moveModule = new inversify_1$f.ContainerModule((bind, _unbind, isBound) => {
  bind(move_1.MoveMouseListener).toSelf().inSingletonScope();
  bind(types_1$9.TYPES.MouseListener).toService(move_1.MoveMouseListener);
  (0, command_registration_1$6.configureCommand)({
    bind,
    isBound
  }, move_1.MoveCommand);
  bind(move_1.LocationPostprocessor).toSelf().inSingletonScope();
  bind(types_1$9.TYPES.IVNodePostprocessor).toService(move_1.LocationPostprocessor);
  bind(types_1$9.TYPES.HiddenVNodePostprocessor).toService(move_1.LocationPostprocessor);
});
di_config$8.default = moveModule;
var di_config$7 = {};
Object.defineProperty(di_config$7, "__esModule", {
  value: true
});
const inversify_1$e = require$$0$1;
const types_1$8 = types;
const open_1 = open$1;
const openModule = new inversify_1$e.ContainerModule((bind) => {
  bind(open_1.OpenMouseListener).toSelf().inSingletonScope();
  bind(types_1$8.TYPES.MouseListener).toService(open_1.OpenMouseListener);
});
di_config$7.default = openModule;
var di_config$6 = {};
Object.defineProperty(di_config$6, "__esModule", {
  value: true
});
const inversify_1$d = require$$0$1;
const types_1$7 = types;
const manhattan_edge_router_1 = manhattanEdgeRouter;
const polyline_edge_router_1 = polylineEdgeRouter;
const manhattan_anchors_1 = manhattanAnchors;
const polyline_anchors_1 = polylineAnchors;
const anchor_1$1 = anchor;
const routing_1$1 = routing;
const bezier_edge_router_1 = bezierEdgeRouter;
const bezier_anchors_1 = bezierAnchors;
const command_registration_1$5 = commandRegistration;
const routingModule = new inversify_1$d.ContainerModule((bind, _unbind, isBound) => {
  bind(routing_1$1.EdgeRouterRegistry).toSelf().inSingletonScope();
  bind(anchor_1$1.AnchorComputerRegistry).toSelf().inSingletonScope();
  bind(manhattan_edge_router_1.ManhattanEdgeRouter).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IEdgeRouter).toService(manhattan_edge_router_1.ManhattanEdgeRouter);
  bind(manhattan_anchors_1.ManhattanEllipticAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanEllipticAnchor);
  bind(manhattan_anchors_1.ManhattanRectangularAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanRectangularAnchor);
  bind(manhattan_anchors_1.ManhattanDiamondAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanDiamondAnchor);
  bind(polyline_edge_router_1.PolylineEdgeRouter).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IEdgeRouter).toService(polyline_edge_router_1.PolylineEdgeRouter);
  bind(polyline_anchors_1.EllipseAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(polyline_anchors_1.EllipseAnchor);
  bind(polyline_anchors_1.RectangleAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(polyline_anchors_1.RectangleAnchor);
  bind(polyline_anchors_1.DiamondAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(polyline_anchors_1.DiamondAnchor);
  bind(bezier_edge_router_1.BezierEdgeRouter).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IEdgeRouter).toService(bezier_edge_router_1.BezierEdgeRouter);
  bind(bezier_anchors_1.BezierEllipseAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierEllipseAnchor);
  bind(bezier_anchors_1.BezierRectangleAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierRectangleAnchor);
  bind(bezier_anchors_1.BezierDiamondAnchor).toSelf().inSingletonScope();
  bind(types_1$7.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierDiamondAnchor);
  (0, command_registration_1$5.configureCommand)({
    bind,
    isBound
  }, bezier_edge_router_1.AddRemoveBezierSegmentCommand);
});
di_config$6.default = routingModule;
var di_config$5 = {};
Object.defineProperty(di_config$5, "__esModule", {
  value: true
});
const inversify_1$c = require$$0$1;
const types_1$6 = types;
const select_1 = select;
const command_registration_1$4 = commandRegistration;
const selectModule = new inversify_1$c.ContainerModule((bind, _unbind, isBound) => {
  (0, command_registration_1$4.configureCommand)({
    bind,
    isBound
  }, select_1.SelectCommand);
  (0, command_registration_1$4.configureCommand)({
    bind,
    isBound
  }, select_1.SelectAllCommand);
  (0, command_registration_1$4.configureCommand)({
    bind,
    isBound
  }, select_1.GetSelectionCommand);
  bind(select_1.SelectKeyboardListener).toSelf().inSingletonScope();
  bind(types_1$6.TYPES.KeyListener).toService(select_1.SelectKeyboardListener);
  bind(select_1.SelectMouseListener).toSelf().inSingletonScope();
  bind(types_1$6.TYPES.MouseListener).toService(select_1.SelectMouseListener);
});
di_config$5.default = selectModule;
var di_config$4 = {};
Object.defineProperty(di_config$4, "__esModule", {
  value: true
});
const inversify_1$b = require$$0$1;
const types_1$5 = types;
const undo_redo_1 = undoRedo;
const undoRedoModule = new inversify_1$b.ContainerModule((bind) => {
  bind(undo_redo_1.UndoRedoKeyListener).toSelf().inSingletonScope();
  bind(types_1$5.TYPES.KeyListener).toService(undo_redo_1.UndoRedoKeyListener);
});
di_config$4.default = undoRedoModule;
var di_config$3 = {};
Object.defineProperty(di_config$3, "__esModule", {
  value: true
});
const inversify_1$a = require$$0$1;
const command_registration_1$3 = commandRegistration;
const update_model_1$1 = updateModel;
const updateModule = new inversify_1$a.ContainerModule((bind, _unbind, isBound) => {
  (0, command_registration_1$3.configureCommand)({
    bind,
    isBound
  }, update_model_1$1.UpdateModelCommand);
});
di_config$3.default = updateModule;
var di_config$2 = {};
Object.defineProperty(di_config$2, "__esModule", {
  value: true
});
const inversify_1$9 = require$$0$1;
const types_1$4 = types;
const center_fit_1 = centerFit;
const viewport_1 = viewport;
const scroll_1 = scroll;
const zoom_1 = zoom;
const command_registration_1$2 = commandRegistration;
const viewportModule = new inversify_1$9.ContainerModule((bind, _unbind, isBound) => {
  (0, command_registration_1$2.configureCommand)({
    bind,
    isBound
  }, center_fit_1.CenterCommand);
  (0, command_registration_1$2.configureCommand)({
    bind,
    isBound
  }, center_fit_1.FitToScreenCommand);
  (0, command_registration_1$2.configureCommand)({
    bind,
    isBound
  }, viewport_1.SetViewportCommand);
  (0, command_registration_1$2.configureCommand)({
    bind,
    isBound
  }, viewport_1.GetViewportCommand);
  bind(center_fit_1.CenterKeyboardListener).toSelf().inSingletonScope();
  bind(types_1$4.TYPES.KeyListener).toService(center_fit_1.CenterKeyboardListener);
  bind(scroll_1.ScrollMouseListener).toSelf().inSingletonScope();
  bind(zoom_1.ZoomMouseListener).toSelf().inSingletonScope();
  bind(types_1$4.TYPES.MouseListener).toService(scroll_1.ScrollMouseListener);
  bind(types_1$4.TYPES.MouseListener).toService(zoom_1.ZoomMouseListener);
});
di_config$2.default = viewportModule;
var di_config$1 = {};
Object.defineProperty(di_config$1, "__esModule", {
  value: true
});
const inversify_1$8 = require$$0$1;
const command_registration_1$1 = commandRegistration;
const zorder_1 = zorder;
const zorderModule = new inversify_1$8.ContainerModule((bind, _unbind, isBound) => {
  (0, command_registration_1$1.configureCommand)({
    bind,
    isBound
  }, zorder_1.BringToFrontCommand);
});
di_config$1.default = zorderModule;
var views = {};
var __decorate$6 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(views, "__esModule", {
  value: true
});
views.SBezierControlHandleView = views.SBezierCreateHandleView = views.SCompartmentView = views.SLabelView = views.SRoutingHandleView = views.BezierCurveEdgeView = views.PolylineEdgeViewWithGapsOnIntersections = views.JumpingPolylineEdgeView = views.PolylineEdgeView = views.SGraphView = void 0;
const inversify_1$7 = require$$0$1;
const geometry_1$1 = geometry$1;
const model_utils_1$1 = modelUtils;
const vnode_utils_1$2 = vnodeUtils;
const views_1$1 = views$5;
const intersection_finder_1 = intersectionFinder;
const model_1$2 = model$b;
const model_2$1 = model$a;
const routing_1 = routing;
const views_2 = views$1;
const jsx_1$2 = jsx;
const geometry_2 = geometry;
let SGraphView = class SGraphView2 {
  render(model2, context) {
    const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model2);
    const transform = `scale(${model2.zoom}) translate(${-model2.scroll.x},${-model2.scroll.y})`;
    return (0, jsx_1$2.svg)("svg", {
      "class-sprotty-graph": true
    }, (0, jsx_1$2.svg)("g", {
      transform
    }, context.renderChildren(model2, {
      edgeRouting
    })));
  }
};
views.SGraphView = SGraphView;
__decorate$6([(0, inversify_1$7.inject)(routing_1.EdgeRouterRegistry), __metadata$3("design:type", routing_1.EdgeRouterRegistry)], SGraphView.prototype, "edgeRouterRegistry", void 0);
views.SGraphView = SGraphView = __decorate$6([(0, inversify_1$7.injectable)()], SGraphView);
let PolylineEdgeView = class PolylineEdgeView2 extends views_2.RoutableView {
  render(edge, context, args) {
    const route = this.edgeRouterRegistry.route(edge, args);
    if (route.length === 0) {
      return this.renderDanglingEdge("Cannot compute route", edge, context);
    }
    if (!this.isVisible(edge, route, context)) {
      if (edge.children.length === 0) {
        return void 0;
      }
      return (0, jsx_1$2.svg)("g", null, context.renderChildren(edge, {
        route
      }));
    }
    return (0, jsx_1$2.svg)("g", {
      "class-sprotty-edge": true,
      "class-mouseover": edge.hoverFeedback
    }, this.renderLine(edge, route, context, args), this.renderAdditionals(edge, route, context), this.renderJunctionPoints(edge, route, context, args), context.renderChildren(edge, {
      route
    }));
  }
  renderJunctionPoints(edge, route, context, args) {
    const radius = 5;
    const junctionPoints = [];
    for (let i = 1; i < route.length; i++) {
      if (route[i].isJunction) {
        junctionPoints.push((0, jsx_1$2.svg)("circle", {
          cx: route[i].x,
          cy: route[i].y,
          r: radius
        }));
      }
    }
    if (junctionPoints.length > 0) {
      return (0, jsx_1$2.svg)("g", {
        "class-sprotty-junction": true
      }, junctionPoints);
    }
    return void 0;
  }
  renderLine(edge, segments, context, args) {
    const firstPoint = segments[0];
    let path = `M ${firstPoint.x},${firstPoint.y}`;
    for (let i = 1; i < segments.length; i++) {
      const p2 = segments[i];
      path += ` L ${p2.x},${p2.y}`;
    }
    return (0, jsx_1$2.svg)("path", {
      d: path
    });
  }
  renderAdditionals(edge, segments, context) {
    return [];
  }
  renderDanglingEdge(message, edge, context) {
    return (0, jsx_1$2.svg)("text", {
      "class-sprotty-edge-dangling": true,
      title: message
    }, "?");
  }
};
views.PolylineEdgeView = PolylineEdgeView;
__decorate$6([(0, inversify_1$7.inject)(routing_1.EdgeRouterRegistry), __metadata$3("design:type", routing_1.EdgeRouterRegistry)], PolylineEdgeView.prototype, "edgeRouterRegistry", void 0);
views.PolylineEdgeView = PolylineEdgeView = __decorate$6([(0, inversify_1$7.injectable)()], PolylineEdgeView);
let JumpingPolylineEdgeView = class JumpingPolylineEdgeView2 extends PolylineEdgeView {
  constructor() {
    super(...arguments);
    this.jumpOffsetBefore = 5;
    this.jumpOffsetAfter = 5;
    this.skipOffsetBefore = 3;
    this.skipOffsetAfter = 2;
  }
  renderLine(edge, segments, context, args) {
    let path = "";
    for (let i = 0; i < segments.length; i++) {
      const p2 = segments[i];
      if (i === 0) {
        path = `M ${p2.x},${p2.y}`;
      }
      if ((0, intersection_finder_1.isIntersectingRoutedPoint)(p2)) {
        path += this.intersectionPath(edge, segments, p2, args);
      }
      if (i !== 0) {
        path += ` L ${p2.x},${p2.y}`;
      }
    }
    return (0, jsx_1$2.svg)("path", {
      d: path
    });
  }
  /**
   * Returns a path that takes the intersections into account by drawing a line jump or a gap for intersections on that path.
   */
  intersectionPath(edge, segments, intersectingPoint, args) {
    if (intersectingPoint.intersections.length < 1) {
      return "";
    }
    const segment = this.getLineSegment(edge, intersectingPoint.intersections[0], args, segments);
    const intersections = this.getIntersectionsSortedBySegmentDirection(segment, intersectingPoint);
    let path = "";
    for (const intersection2 of intersections) {
      const otherLineSegment = this.getOtherLineSegment(edge, intersection2, args);
      if (otherLineSegment === void 0) {
        continue;
      }
      const currentLineSegment = this.getLineSegment(edge, intersection2, args, segments);
      const intersectionPoint = intersection2.intersectionPoint;
      if (this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment)) {
        path += this.createJumpPath(intersectionPoint, currentLineSegment);
      } else if (this.shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment)) {
        path += this.createGapPath(intersectionPoint, currentLineSegment);
      }
    }
    return path;
  }
  /**
   * Returns the intersections sorted by the direction of the `lineSegment`.
   *
   * The coordinate system goes from left to right and top to bottom.
   * Thus, x increases to the right and y increases downwards.
   *
   * We need to draw the intersections in the order of the direction of the line segment.
   * To draw a line pointing north, we need to order intersections by Y in a descending order.
   * To draw a line pointing south, we need to order intersections by Y in an ascending order.
   */
  getIntersectionsSortedBySegmentDirection(lineSegment, intersectingPoint) {
    switch (lineSegment.direction) {
      case "north":
      case "north-east":
        return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_DESCENDING_Y);
      case "south":
      case "south-east":
      case "east":
        return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_Y);
      case "south-west":
      case "west":
        return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_Y);
      case "north-west":
        return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_DESCENDING_Y);
    }
  }
  /**
   * Whether or not to draw a line jump on an intersection for the `currentLineSegment`.
   * This should usually be inverse of `shouldDrawLineGapOnIntersection()`.
   */
  shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
    return Math.abs(currentLineSegment.slopeOrMax) < Math.abs(otherLineSegment.slopeOrMax);
  }
  /**
   * Whether or not to draw a line gap on an intersection for the `currentLineSegment`.
   * This should usually be inverse of `shouldDrawLineJumpOnIntersection()`.
   */
  shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
    return !this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment);
  }
  getLineSegment(edge, intersection2, args, segments) {
    const route = segments ? segments : this.edgeRouterRegistry.route(edge, args);
    const index = intersection2.routable1 === edge.id ? intersection2.segmentIndex1 : intersection2.segmentIndex2;
    return new geometry_2.PointToPointLine(route[index], route[index + 1]);
  }
  getOtherLineSegment(currentEdge, intersection2, args) {
    const otherEdgeId = intersection2.routable1 === currentEdge.id ? intersection2.routable2 : intersection2.routable1;
    const otherEdge = currentEdge.index.getById(otherEdgeId);
    if (!(otherEdge instanceof model_2$1.SRoutableElementImpl)) {
      return void 0;
    }
    return this.getLineSegment(otherEdge, intersection2, args);
  }
  createJumpPath(intersectionPoint, lineSegment) {
    const anchorBefore = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.jumpOffsetBefore);
    const anchorAfter = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.jumpOffsetAfter);
    const rotation = lineSegment.p1.x < lineSegment.p2.x ? 1 : 0;
    return ` L ${anchorBefore.x},${anchorBefore.y} A 1,1 0,0 ${rotation} ${anchorAfter.x},${anchorAfter.y}`;
  }
  createGapPath(intersectionPoint, lineSegment) {
    let offsetBefore;
    let offsetAfter;
    if (intersectionPoint.y < lineSegment.p1.y) {
      offsetBefore = -this.skipOffsetBefore;
      offsetAfter = this.jumpOffsetAfter + this.skipOffsetAfter;
    } else {
      offsetBefore = this.jumpOffsetBefore + this.skipOffsetAfter;
      offsetAfter = -this.skipOffsetBefore;
    }
    const anchorBefore = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p1, offsetBefore);
    const anchorAfter = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p2, offsetAfter);
    return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
  }
};
views.JumpingPolylineEdgeView = JumpingPolylineEdgeView;
views.JumpingPolylineEdgeView = JumpingPolylineEdgeView = __decorate$6([(0, inversify_1$7.injectable)()], JumpingPolylineEdgeView);
let PolylineEdgeViewWithGapsOnIntersections = class PolylineEdgeViewWithGapsOnIntersections2 extends JumpingPolylineEdgeView {
  constructor() {
    super(...arguments);
    this.skipOffsetBefore = 3;
    this.skipOffsetAfter = 3;
  }
  shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
    return false;
  }
  shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
    return Math.abs(currentLineSegment.slopeOrMax) >= Math.abs(otherLineSegment.slopeOrMax);
  }
  createGapPath(intersectionPoint, lineSegment) {
    const anchorBefore = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.skipOffsetBefore);
    const anchorAfter = geometry_1$1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.skipOffsetAfter);
    return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
  }
};
views.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections;
views.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections = __decorate$6([(0, inversify_1$7.injectable)()], PolylineEdgeViewWithGapsOnIntersections);
let BezierCurveEdgeView = class BezierCurveEdgeView2 extends views_2.RoutableView {
  render(edge, context, args) {
    const route = this.edgeRouterRegistry.route(edge, args);
    if (route.length === 0) {
      return this.renderDanglingEdge("Cannot compute route", edge, context);
    }
    if (!this.isVisible(edge, route, context)) {
      if (edge.children.length === 0) {
        return void 0;
      }
      return (0, jsx_1$2.svg)("g", null, context.renderChildren(edge, {
        route
      }));
    }
    return (0, jsx_1$2.svg)("g", {
      "class-sprotty-edge": true,
      "class-mouseover": edge.hoverFeedback
    }, this.renderLine(edge, route, context, args), this.renderAdditionals(edge, route, context), context.renderChildren(edge, {
      route
    }));
  }
  renderLine(edge, segments, context, args) {
    let path = "";
    if (segments.length >= 4) {
      path += this.buildMainSegment(segments);
      const pointsLeft = segments.length - 4;
      if (pointsLeft > 0 && pointsLeft % 3 === 0) {
        for (let i = 4; i < segments.length; i += 3) {
          path += this.addSpline(segments, i);
        }
      }
    }
    return (0, jsx_1$2.svg)("path", {
      d: path
    });
  }
  buildMainSegment(segments) {
    const s = segments[0];
    const h1 = segments[1];
    const h2 = segments[2];
    const t = segments[3];
    return `M${s.x},${s.y} C${h1.x},${h1.y} ${h2.x},${h2.y} ${t.x},${t.y}`;
  }
  addSpline(segments, index) {
    const c = segments[index + 1];
    const p2 = segments[index + 2];
    return ` S${c.x},${c.y} ${p2.x},${p2.y}`;
  }
  renderAdditionals(edge, segments, context) {
    return [];
  }
  renderDanglingEdge(message, edge, context) {
    return (0, jsx_1$2.svg)("text", {
      "class-sprotty-edge-dangling": true,
      title: message
    }, "?");
  }
};
views.BezierCurveEdgeView = BezierCurveEdgeView;
__decorate$6([(0, inversify_1$7.inject)(routing_1.EdgeRouterRegistry), __metadata$3("design:type", routing_1.EdgeRouterRegistry)], BezierCurveEdgeView.prototype, "edgeRouterRegistry", void 0);
views.BezierCurveEdgeView = BezierCurveEdgeView = __decorate$6([(0, inversify_1$7.injectable)()], BezierCurveEdgeView);
let SRoutingHandleView = class SRoutingHandleView2 {
  constructor() {
    this.minimalPointDistance = 10;
  }
  render(handle, context, args) {
    if (args && args.route) {
      if (handle.parent instanceof model_2$1.SRoutableElementImpl) {
        const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
        const theRoute = args.route === void 0 ? this.edgeRouterRegistry.route(handle.parent, args) : args.route;
        const position = router.getHandlePosition(handle.parent, theRoute, handle);
        if (position !== void 0) {
          const node = (0, jsx_1$2.svg)("circle", {
            "class-sprotty-routing-handle": true,
            "class-selected": handle.selected,
            "class-mouseover": handle.hoverFeedback,
            cx: position.x,
            cy: position.y,
            r: this.getRadius()
          });
          (0, vnode_utils_1$2.setAttr)(node, "data-kind", handle.kind);
          return node;
        }
      }
    }
    return (0, jsx_1$2.svg)("g", null);
  }
  getRadius() {
    return 7;
  }
};
views.SRoutingHandleView = SRoutingHandleView;
__decorate$6([(0, inversify_1$7.inject)(routing_1.EdgeRouterRegistry), __metadata$3("design:type", routing_1.EdgeRouterRegistry)], SRoutingHandleView.prototype, "edgeRouterRegistry", void 0);
views.SRoutingHandleView = SRoutingHandleView = __decorate$6([(0, inversify_1$7.injectable)()], SRoutingHandleView);
let SLabelView = class SLabelView2 extends views_1$1.ShapeView {
  render(label, context) {
    if (!(0, model_1$2.isEdgeLayoutable)(label) && !this.isVisible(label, context)) {
      return void 0;
    }
    const vnode2 = (0, jsx_1$2.svg)("text", {
      "class-sprotty-label": true
    }, label.text);
    const subType = (0, model_utils_1$1.getSubType)(label);
    if (subType) {
      (0, vnode_utils_1$2.setAttr)(vnode2, "class", subType);
    }
    return vnode2;
  }
};
views.SLabelView = SLabelView;
views.SLabelView = SLabelView = __decorate$6([(0, inversify_1$7.injectable)()], SLabelView);
let SCompartmentView = class SCompartmentView2 {
  render(compartment, context, args) {
    const translate = `translate(${compartment.bounds.x}, ${compartment.bounds.y})`;
    const vnode2 = (0, jsx_1$2.svg)("g", {
      transform: translate,
      "class-sprotty-comp": "{true}"
    }, context.renderChildren(compartment));
    const subType = (0, model_utils_1$1.getSubType)(compartment);
    if (subType)
      (0, vnode_utils_1$2.setAttr)(vnode2, "class", subType);
    return vnode2;
  }
};
views.SCompartmentView = SCompartmentView;
views.SCompartmentView = SCompartmentView = __decorate$6([(0, inversify_1$7.injectable)()], SCompartmentView);
let SBezierCreateHandleView = class SBezierCreateHandleView2 extends SRoutingHandleView {
  render(handle, context, args) {
    if (args) {
      const theRoute = args.route;
      if (theRoute && handle.parent instanceof model_2$1.SRoutableElementImpl) {
        const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
        const position = router.getHandlePosition(handle.parent, theRoute, handle);
        if (position !== void 0) {
          const translation = "translate(" + position.x + ", " + position.y + ")";
          const textOffsetX = -5.5;
          const textOffsetY = 5.5;
          const text = handle.kind === "bezier-add" ? "+" : "-";
          const node = (0, jsx_1$2.svg)("g", {
            transform: translation,
            "class-sprotty-routing-handle": true,
            "class-selected": handle.selected,
            "class-mouseover": handle.hoverFeedback
          }, (0, jsx_1$2.svg)("circle", {
            r: this.getRadius()
          }), (0, jsx_1$2.svg)("text", {
            x: textOffsetX,
            y: textOffsetY,
            "attrs-text-align": "middle",
            "style-font-family": "monospace",
            "style-pointer-events": "none",
            "style-fill": "white"
          }, text));
          (0, vnode_utils_1$2.setAttr)(node, "data-kind", handle.kind);
          return node;
        }
      }
    }
    return (0, jsx_1$2.svg)("g", null);
  }
};
views.SBezierCreateHandleView = SBezierCreateHandleView;
views.SBezierCreateHandleView = SBezierCreateHandleView = __decorate$6([(0, inversify_1$7.injectable)()], SBezierCreateHandleView);
let SBezierControlHandleView = class SBezierControlHandleView2 extends SRoutingHandleView {
  render(handle, context, args) {
    if (args) {
      const theRoute = args.route;
      if (theRoute && handle.parent instanceof model_2$1.SRoutableElementImpl) {
        const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
        const position = router.getHandlePosition(handle.parent, theRoute, handle);
        if (position !== void 0) {
          let pathEndPos;
          for (let i = 0; i < theRoute.length; i++) {
            const elem = theRoute[i];
            if (elem.kind === position.kind && elem.pointIndex === position.pointIndex) {
              if (handle.kind === "bezier-control-before") {
                pathEndPos = theRoute[i + 1];
              } else {
                pathEndPos = theRoute[i - 1];
              }
              break;
            }
          }
          let node;
          if (pathEndPos) {
            const coords = `M ${position.x}, ${position.y} L ${pathEndPos.x}, ${pathEndPos.y}`;
            node = (0, jsx_1$2.svg)("g", {
              "class-sprotty-routing-handle": true,
              "class-selected": handle.selected,
              "class-mouseover": handle.hoverFeedback
            }, (0, jsx_1$2.svg)("path", {
              d: coords,
              stroke: "grey",
              "style-stroke-width": "2px"
            }), (0, jsx_1$2.svg)("circle", {
              cx: position.x,
              cy: position.y,
              r: this.getRadius()
            }));
          } else {
            node = (0, jsx_1$2.svg)("circle", {
              "class-sprotty-routing-handle": true,
              "class-selected": handle.selected,
              "class-mouseover": handle.hoverFeedback,
              cx: position.x,
              cy: position.y,
              r: this.getRadius()
            });
          }
          (0, vnode_utils_1$2.setAttr)(node, "data-kind", handle.kind);
          return node;
        }
      }
    }
    return (0, jsx_1$2.svg)("g", null);
  }
};
views.SBezierControlHandleView = SBezierControlHandleView;
views.SBezierControlHandleView = SBezierControlHandleView = __decorate$6([(0, inversify_1$7.injectable)()], SBezierControlHandleView);
var modules = {};
var di_config = {};
Object.defineProperty(di_config, "__esModule", {
  value: true
});
const inversify_1$6 = require$$0$1;
const command_registration_1 = commandRegistration;
const types_1$3 = types;
const commit_model_1 = commitModel;
const model_source_1$2 = modelSource;
const modelSourceModule = new inversify_1$6.ContainerModule((bind, _unbind, isBound) => {
  bind(types_1$3.TYPES.ModelSourceProvider).toProvider((context) => {
    return () => {
      return new Promise((resolve2) => {
        resolve2(context.container.get(types_1$3.TYPES.ModelSource));
      });
    };
  });
  (0, command_registration_1.configureCommand)({
    bind,
    isBound
  }, commit_model_1.CommitModelCommand);
  bind(types_1$3.TYPES.IActionHandlerInitializer).toService(types_1$3.TYPES.ModelSource);
  bind(model_source_1$2.ComputedBoundsApplicator).toSelf().inSingletonScope();
});
di_config.default = modelSourceModule;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(modules, "__esModule", {
  value: true
});
modules.loadDefaultModules = void 0;
const di_config_1 = __importDefault$1(di_config$m);
const di_config_2 = __importDefault$1(di_config);
const di_config_3 = __importDefault$1(di_config$j);
const di_config_4 = __importDefault$1(di_config$i);
const di_config_5 = __importDefault$1(di_config$h);
const di_config_6 = __importDefault$1(di_config$g);
const di_config_7 = __importDefault$1(di_config$f);
const di_config_8 = __importDefault$1(di_config$l);
const di_config_9 = di_config$k;
const di_config_10 = __importDefault$1(di_config$c);
const di_config_11 = __importDefault$1(di_config$b);
const di_config_12 = __importDefault$1(di_config$a);
const di_config_13 = __importDefault$1(di_config$9);
const di_config_14 = __importDefault$1(di_config$8);
const di_config_15 = __importDefault$1(di_config$7);
const di_config_16 = __importDefault$1(di_config$6);
const di_config_17 = __importDefault$1(di_config$5);
const di_config_18 = __importDefault$1(di_config$4);
const di_config_19 = __importDefault$1(di_config$3);
const di_config_20 = __importDefault$1(di_config$2);
const di_config_21 = __importDefault$1(di_config$1);
function loadDefaultModules(container, options) {
  const modules2 = [di_config_1.default, di_config_2.default, di_config_3.default, di_config_4.default, di_config_5.default, di_config_6.default, di_config_7.default, di_config_9.edgeEditModule, di_config_8.default, di_config_10.default, di_config_11.default, di_config_12.default, di_config_13.default, di_config_9.labelEditModule, di_config_9.labelEditUiModule, di_config_14.default, di_config_15.default, di_config_16.default, di_config_17.default, di_config_18.default, di_config_19.default, di_config_20.default, di_config_21.default];
  if (options && options.exclude) {
    for (const mod of options.exclude) {
      const index = modules2.indexOf(mod);
      if (index >= 0)
        modules2.splice(index, 1);
    }
  }
  container.load(...modules2);
}
modules.loadDefaultModules = loadDefaultModules;
var genericViews = {};
var virtualize = {};
Object.defineProperty(virtualize, "__esModule", {
  value: true
});
const snabbdom_1 = require$$0;
function buildVNodeData(attrs) {
  const data = {};
  const addData = (memo, name) => {
    if (name !== "style" && name !== "class") {
      const val = unescapeEntities(attrs[name]);
      memo ? memo[name] = val : memo = {
        [name]: val
      };
    }
    return memo;
  };
  const _attrs = Object.keys(attrs).reduce(addData, null);
  if (_attrs) {
    data.attrs = _attrs;
  }
  const style = parseStyle(attrs);
  if (style) {
    data.style = style;
  }
  const classes = parseClass(attrs);
  if (classes) {
    data.class = classes;
  }
  return data;
}
function parseStyle(attrs) {
  const addStyle = (memo, styleProp) => {
    const res = styleProp.split(":");
    const name = transformName(res[0].trim());
    if (name) {
      const val = res[1].replace("!important", "").trim();
      memo ? memo[name] = val : memo = {
        [name]: val
      };
    }
    return memo;
  };
  try {
    return attrs.style.split(";").reduce(addStyle, null);
  } catch (e) {
    return null;
  }
}
function parseClass(attrs) {
  const addClass = (memo, className) => {
    className = className.trim();
    if (className) {
      memo ? memo[className] = true : memo = {
        [className]: true
      };
    }
    return memo;
  };
  try {
    return attrs.class.split(" ").reduce(addClass, null);
  } catch (e) {
    return null;
  }
}
function transformName(name) {
  name = name.replace(/-(\w)/g, function _replace($1, $2) {
    return $2.toUpperCase();
  });
  const firstChar = name.charAt(0).toLowerCase();
  return `${firstChar}${name.substring(1)}`;
}
const entityRegex = new RegExp("&[a-z0-9#]+;", "gi");
let el = null;
function unescapeEntities(text) {
  if (!el) {
    el = document.createElement("div");
  }
  return text.replace(entityRegex, (entity) => {
    if (el === null)
      return "";
    el.innerHTML = entity;
    return el.textContent === null ? "" : el.textContent;
  });
}
function recurse(doc2, func) {
  let node = doc2;
  let parent = null;
  const stack = [];
  const setChild = (n) => {
    const child = n.firstChild;
    if (child !== null) {
      parent = n;
    }
    node = child;
  };
  func(node, parent);
  setChild(node);
  while (true) {
    while (node) {
      stack.push(node);
      func(node, parent);
      setChild(node);
    }
    const _node = stack.pop();
    node = _node ? _node : null;
    if (!stack.length)
      break;
    parent = stack[stack.length - 1];
    if (node) {
      const sibling = node.nextSibling;
      if (sibling == null) {
        parent = stack[stack.length - 1];
      }
      node = sibling;
    }
  }
}
let vdom = null;
const vnodeMap = /* @__PURE__ */ new Map();
let delimited = false;
function toVNode(node, parent) {
  let current;
  if (parent !== null) {
    current = vnodeMap.get(parent);
  }
  switch (node === null || node === void 0 ? void 0 : node.nodeType) {
    case 1: {
      if (current === void 0)
        return;
      current.children = current.children ? current.children : [];
      const children = current.children;
      const attributes = node.attributes;
      const attrs = {};
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (attr) {
          attrs[attr.name] = attr.value;
        }
      }
      const vn = (0, snabbdom_1.h)(node.nodeName, buildVNodeData(attrs));
      children.push(vn);
      vnodeMap.set(node, vn);
      break;
    }
    case 3: {
      const text = node.textContent;
      if (text !== null && current !== void 0) {
        current.children = current.children ? current.children : [];
        const children = current.children;
        const lastData = children.length > 0 ? children[children.length - 1] : null;
        if (!delimited && typeof lastData !== "string" && lastData !== null && lastData.sel === void 0) {
          lastData.text = lastData.text + text;
        } else {
          children.push((0, snabbdom_1.vnode)(void 0, void 0, void 0, text, void 0));
        }
        delimited = false;
      }
      break;
    }
    case 8: {
      delimited = true;
      break;
    }
    case 9: {
      vdom = (0, snabbdom_1.vnode)(void 0, void 0, [], void 0, void 0);
      vnodeMap.set(node, vdom);
      break;
    }
  }
}
function stripVNode(vnodes) {
  const children = vnodes === null || vnodes === void 0 ? void 0 : vnodes.children;
  if (typeof children === "undefined")
    return null;
  if (children.length === 1 && typeof children[0] !== "string")
    return children[0];
  return null;
}
function virtualizeString(html2) {
  var _a, _b;
  const parser = new window.DOMParser();
  if (parser === void 0 || html2 === void 0 || html2 === "")
    return null;
  const doc2 = parser.parseFromString(html2, "application/xml");
  if (((_a = doc2 === null || doc2 === void 0 ? void 0 : doc2.firstChild) === null || _a === void 0 ? void 0 : _a.nodeName) === "parsererror") {
    const error = `${(_b = doc2 === null || doc2 === void 0 ? void 0 : doc2.firstChild) === null || _b === void 0 ? void 0 : _b.textContent}`;
    return (0, snabbdom_1.h)("parsererror", [error]);
  }
  delimited = false;
  vdom = null;
  recurse(doc2, toVNode);
  if (vdom === null)
    return null;
  return stripVNode(vdom);
}
virtualize.default = virtualizeString;
var model = {};
Object.defineProperty(model, "__esModule", {
  value: true
});
model.ForeignObjectElement = model.ForeignObjectElementImpl = model.ShapedPreRenderedElement = model.ShapedPreRenderedElementImpl = model.PreRenderedElement = model.PreRenderedElementImpl = model.HtmlRoot = model.HtmlRootImpl = model.RectangularPort = model.CircularPort = model.DiamondNode = model.RectangularNode = model.CircularNode = void 0;
const geometry_1 = geometry$1;
const smodel_1 = smodel;
const model_1$1 = model$g;
const model_2 = model$8;
const model_3 = model$c;
const sgraph_1 = sgraph;
const anchor_1 = anchor;
class CircularNode extends sgraph_1.SNodeImpl {
  get anchorKind() {
    return anchor_1.ELLIPTIC_ANCHOR_KIND;
  }
}
model.CircularNode = CircularNode;
class RectangularNode extends sgraph_1.SNodeImpl {
  get anchorKind() {
    return anchor_1.RECTANGULAR_ANCHOR_KIND;
  }
}
model.RectangularNode = RectangularNode;
class DiamondNode extends sgraph_1.SNodeImpl {
  get anchorKind() {
    return anchor_1.DIAMOND_ANCHOR_KIND;
  }
}
model.DiamondNode = DiamondNode;
class CircularPort extends sgraph_1.SPortImpl {
  get anchorKind() {
    return anchor_1.ELLIPTIC_ANCHOR_KIND;
  }
}
model.CircularPort = CircularPort;
class RectangularPort extends sgraph_1.SPortImpl {
  get anchorKind() {
    return anchor_1.RECTANGULAR_ANCHOR_KIND;
  }
}
model.RectangularPort = RectangularPort;
class HtmlRootImpl extends smodel_1.SModelRootImpl {
  constructor() {
    super(...arguments);
    this.classes = [];
  }
}
model.HtmlRootImpl = HtmlRootImpl;
model.HtmlRoot = HtmlRootImpl;
class PreRenderedElementImpl extends smodel_1.SChildElementImpl {
}
model.PreRenderedElementImpl = PreRenderedElementImpl;
model.PreRenderedElement = PreRenderedElementImpl;
class ShapedPreRenderedElementImpl extends PreRenderedElementImpl {
  constructor() {
    super(...arguments);
    this.position = geometry_1.Point.ORIGIN;
    this.size = geometry_1.Dimension.EMPTY;
    this.selected = false;
    this.alignment = geometry_1.Point.ORIGIN;
  }
  get bounds() {
    return {
      x: this.position.x,
      y: this.position.y,
      width: this.size.width,
      height: this.size.height
    };
  }
  set bounds(newBounds) {
    this.position = {
      x: newBounds.x,
      y: newBounds.y
    };
    this.size = {
      width: newBounds.width,
      height: newBounds.height
    };
  }
}
model.ShapedPreRenderedElementImpl = ShapedPreRenderedElementImpl;
ShapedPreRenderedElementImpl.DEFAULT_FEATURES = [model_2.moveFeature, model_1$1.boundsFeature, model_3.selectFeature, model_1$1.alignFeature];
model.ShapedPreRenderedElement = ShapedPreRenderedElementImpl;
class ForeignObjectElementImpl extends ShapedPreRenderedElementImpl {
  get bounds() {
    if (geometry_1.Dimension.isValid(this.size)) {
      return {
        x: this.position.x,
        y: this.position.y,
        width: this.size.width,
        height: this.size.height
      };
    } else if ((0, model_1$1.isBoundsAware)(this.parent)) {
      return {
        x: this.position.x,
        y: this.position.y,
        width: this.parent.bounds.width,
        height: this.parent.bounds.height
      };
    }
    return geometry_1.Bounds.EMPTY;
  }
}
model.ForeignObjectElementImpl = ForeignObjectElementImpl;
model.ForeignObjectElement = ForeignObjectElementImpl;
var __decorate$5 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(genericViews, "__esModule", {
  value: true
});
genericViews.ForeignObjectView = genericViews.PreRenderedView = void 0;
const jsx_1$1 = jsx;
const inversify_1$5 = require$$0$1;
const virtualize_1 = __importDefault(virtualize);
const vnode_utils_1$1 = vnodeUtils;
const views_1 = views$5;
const model_1 = model;
let PreRenderedView = class PreRenderedView2 extends views_1.ShapeView {
  render(model2, context) {
    if (model2 instanceof model_1.ShapedPreRenderedElementImpl && !this.isVisible(model2, context)) {
      return void 0;
    }
    const node = (0, virtualize_1.default)(model2.code);
    if (node === null)
      return void 0;
    this.correctNamespace(node);
    return node;
  }
  correctNamespace(node) {
    if (node.sel === "svg" || node.sel === "g")
      (0, vnode_utils_1$1.setNamespace)(node, "http://www.w3.org/2000/svg");
  }
};
genericViews.PreRenderedView = PreRenderedView;
genericViews.PreRenderedView = PreRenderedView = __decorate$5([(0, inversify_1$5.injectable)()], PreRenderedView);
let ForeignObjectView = class ForeignObjectView2 {
  render(model2, context) {
    const foreignObjectContents = (0, virtualize_1.default)(model2.code);
    if (foreignObjectContents === null)
      return void 0;
    const node = (0, jsx_1$1.svg)("g", null, (0, jsx_1$1.svg)("foreignObject", {
      requiredFeatures: "http://www.w3.org/TR/SVG11/feature#Extensibility",
      height: model2.bounds.height,
      width: model2.bounds.width,
      x: 0,
      y: 0
    }, foreignObjectContents), context.renderChildren(model2));
    (0, vnode_utils_1$1.setAttr)(node, "class", model2.type);
    (0, vnode_utils_1$1.setNamespace)(foreignObjectContents, model2.namespace);
    return node;
  }
};
genericViews.ForeignObjectView = ForeignObjectView;
genericViews.ForeignObjectView = ForeignObjectView = __decorate$5([(0, inversify_1$5.injectable)()], ForeignObjectView);
var htmlViews = {};
var __decorate$4 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(htmlViews, "__esModule", {
  value: true
});
htmlViews.HtmlRootView = void 0;
const jsx_1 = jsx;
const inversify_1$4 = require$$0$1;
const vnode_utils_1 = vnodeUtils;
let HtmlRootView = class HtmlRootView2 {
  render(model2, context) {
    const root = (0, jsx_1.html)("div", null, context.renderChildren(model2));
    for (const c of model2.classes) {
      (0, vnode_utils_1.setClass)(root, c, true);
    }
    return root;
  }
};
htmlViews.HtmlRootView = HtmlRootView;
htmlViews.HtmlRootView = HtmlRootView = __decorate$4([(0, inversify_1$4.injectable)()], HtmlRootView);
var diagramServer = {};
var FileSaver_min = { exports: {} };
(function(module, exports) {
  (function(a, b) {
    b();
  })(commonjsGlobal, function() {
    function b(a2, b2) {
      return "undefined" == typeof b2 ? b2 = {
        autoBom: false
      } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = {
        autoBom: !b2
      }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], {
        type: a2.type
      }) : a2;
    }
    function c(a2, b2, c2) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c2);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c2) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h2) {
      var i = f.URL || f.webkitURL, j = document.createElement("a");
      g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h2) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
        i.revokeObjectURL(j.href);
      }, 4e4), setTimeout(function() {
        e(j);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h2) {
      if (g2 = g2 || f2.name || "download", "string" != typeof f2)
        navigator.msSaveOrOpenBlob(b(f2, h2), g2);
      else if (d(f2))
        c(f2, g2, h2);
      else {
        var i = document.createElement("a");
        i.href = f2, i.target = "_blank", setTimeout(function() {
          e(i);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
        return c(b2, d2, e2);
      var h2 = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j || h2 && i || a) && "undefined" != typeof FileReader) {
        var k = new FileReader();
        k.onloadend = function() {
          var a2 = k.result;
          a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k.readAsDataURL(b2);
      } else {
        var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
  });
})(FileSaver_min);
var FileSaver_minExports = FileSaver_min.exports;
var __decorate$3 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(diagramServer, "__esModule", {
  value: true
});
diagramServer.DiagramServerProxy = diagramServer.ServerStatusAction = void 0;
const file_saver_1$1 = FileSaver_minExports;
const inversify_1$3 = require$$0$1;
const actions_1$2 = actions;
const set_model_1 = setModel;
const types_1$2 = types;
const bounds_manipulation_1 = boundsManipulation;
const svg_exporter_1$1 = svgExporter;
const update_model_1 = updateModel;
const model_source_1$1 = modelSource;
class ServerStatusAction {
  constructor() {
    this.kind = ServerStatusAction.KIND;
  }
}
diagramServer.ServerStatusAction = ServerStatusAction;
ServerStatusAction.KIND = "serverStatus";
const receivedFromServerProperty = "__receivedFromServer";
let DiagramServerProxy = class DiagramServerProxy2 extends model_source_1$1.ModelSource {
  constructor() {
    super(...arguments);
    this.currentRoot = {
      type: "NONE",
      id: "ROOT"
    };
  }
  get model() {
    return this.currentRoot;
  }
  initialize(registry2) {
    super.initialize(registry2);
    registry2.register(actions_1$2.ComputedBoundsAction.KIND, this);
    registry2.register(bounds_manipulation_1.RequestBoundsCommand.KIND, this);
    registry2.register(actions_1$2.RequestPopupModelAction.KIND, this);
    registry2.register(actions_1$2.CollapseExpandAction.KIND, this);
    registry2.register(actions_1$2.CollapseExpandAllAction.KIND, this);
    registry2.register(actions_1$2.OpenAction.KIND, this);
    registry2.register(ServerStatusAction.KIND, this);
    if (!this.clientId) {
      this.clientId = this.viewerOptions.baseDiv;
    }
  }
  handle(action2) {
    const forwardToServer = this.handleLocally(action2);
    if (forwardToServer) {
      this.forwardToServer(action2);
    }
  }
  forwardToServer(action2) {
    const message = {
      clientId: this.clientId,
      action: action2
    };
    this.logger.log(this, "sending", message);
    this.sendMessage(message);
  }
  /**
   * Called when a message is received from the remote diagram server.
   */
  messageReceived(data) {
    const object2 = typeof data === "string" ? JSON.parse(data) : data;
    if ((0, actions_1$2.isActionMessage)(object2) && object2.action) {
      if (!object2.clientId || object2.clientId === this.clientId) {
        object2.action[receivedFromServerProperty] = true;
        this.logger.log(this, "receiving", object2);
        this.actionDispatcher.dispatch(object2.action).then(() => {
          this.storeNewModel(object2.action);
        });
      }
    } else {
      this.logger.error(this, "received data is not an action message", object2);
    }
  }
  /**
   * Check whether the given action should be handled locally. Returns true if the action should
   * still be sent to the server, and false if it's only handled locally.
   */
  handleLocally(action2) {
    this.storeNewModel(action2);
    switch (action2.kind) {
      case actions_1$2.ComputedBoundsAction.KIND:
        return this.handleComputedBounds(action2);
      case actions_1$2.RequestModelAction.KIND:
        return this.handleRequestModel(action2);
      case bounds_manipulation_1.RequestBoundsCommand.KIND:
        return false;
      case svg_exporter_1$1.ExportSvgAction.KIND:
        return this.handleExportSvgAction(action2);
      case ServerStatusAction.KIND:
        return this.handleServerStateAction(action2);
    }
    return !action2[receivedFromServerProperty];
  }
  /**
   * Put the new model contained in the given action into the model storage, if there is any.
   */
  storeNewModel(action2) {
    if (action2.kind === set_model_1.SetModelCommand.KIND || action2.kind === update_model_1.UpdateModelCommand.KIND || action2.kind === bounds_manipulation_1.RequestBoundsCommand.KIND) {
      const newRoot = action2.newRoot;
      if (newRoot) {
        this.currentRoot = newRoot;
        if (action2.kind === set_model_1.SetModelCommand.KIND || action2.kind === update_model_1.UpdateModelCommand.KIND) {
          this.lastSubmittedModelType = newRoot.type;
        }
      }
    }
  }
  handleRequestModel(action2) {
    const newOptions = Object.assign({
      needsClientLayout: this.viewerOptions.needsClientLayout,
      needsServerLayout: this.viewerOptions.needsServerLayout
    }, action2.options);
    const newAction = Object.assign(Object.assign({}, action2), {
      options: newOptions
    });
    this.forwardToServer(newAction);
    return false;
  }
  /**
   * If the server requires to compute a layout, the computed bounds are forwarded. Otherwise they
   * are applied to the current model locally and a model update is triggered.
   */
  handleComputedBounds(action2) {
    if (this.viewerOptions.needsServerLayout) {
      return true;
    } else {
      const root = this.currentRoot;
      this.computedBoundsApplicator.apply(root, action2);
      if (root.type === this.lastSubmittedModelType) {
        this.actionDispatcher.dispatch(actions_1$2.UpdateModelAction.create(root));
      } else {
        this.actionDispatcher.dispatch(actions_1$2.SetModelAction.create(root));
      }
      this.lastSubmittedModelType = root.type;
      return false;
    }
  }
  handleExportSvgAction(action2) {
    const blob = new Blob([action2.svg], {
      type: "text/plain;charset=utf-8"
    });
    (0, file_saver_1$1.saveAs)(blob, "diagram.svg");
    return false;
  }
  handleServerStateAction(action2) {
    return false;
  }
  commitModel(newRoot) {
    const previousRoot = this.currentRoot;
    this.currentRoot = newRoot;
    return previousRoot;
  }
};
diagramServer.DiagramServerProxy = DiagramServerProxy;
__decorate$3([(0, inversify_1$3.inject)(types_1$2.TYPES.ILogger), __metadata$2("design:type", Object)], DiagramServerProxy.prototype, "logger", void 0);
__decorate$3([(0, inversify_1$3.inject)(model_source_1$1.ComputedBoundsApplicator), __metadata$2("design:type", model_source_1$1.ComputedBoundsApplicator)], DiagramServerProxy.prototype, "computedBoundsApplicator", void 0);
diagramServer.DiagramServerProxy = DiagramServerProxy = __decorate$3([(0, inversify_1$3.injectable)()], DiagramServerProxy);
var localModelSource = {};
var __decorate$2 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(localModelSource, "__esModule", {
  value: true
});
localModelSource.LocalModelSource = void 0;
const file_saver_1 = FileSaver_minExports;
const inversify_1$2 = require$$0$1;
const actions_1$1 = actions;
const sprotty_protocol_1 = lib;
const model_utils_1 = modelUtils;
const types_1$1 = types;
const smodel_factory_1 = smodelFactory;
const svg_exporter_1 = svgExporter;
const model_matching_1 = modelMatching;
const model_source_1 = modelSource;
let LocalModelSource = class LocalModelSource2 extends model_source_1.ModelSource {
  constructor() {
    super(...arguments);
    this.currentRoot = smodel_factory_1.EMPTY_ROOT;
  }
  get model() {
    return this.currentRoot;
  }
  set model(root) {
    this.setModel(root);
  }
  initialize(registry2) {
    super.initialize(registry2);
    registry2.register(actions_1$1.ComputedBoundsAction.KIND, this);
    registry2.register(actions_1$1.RequestPopupModelAction.KIND, this);
  }
  /**
   * Set the model without incremental update.
   */
  setModel(newRoot) {
    this.currentRoot = newRoot;
    return this.submitModel(newRoot, false);
  }
  commitModel(newRoot) {
    const previousRoot = this.currentRoot;
    this.currentRoot = newRoot;
    return previousRoot;
  }
  /**
   * Apply an incremental update to the model with an animation showing the transition to
   * the new state. If `newRoot` is undefined, the current root is submitted; in that case
   * it is assumed that it has been modified before.
   */
  updateModel(newRoot) {
    if (newRoot === void 0) {
      return this.submitModel(this.currentRoot, true);
    } else {
      this.currentRoot = newRoot;
      return this.submitModel(newRoot, true);
    }
  }
  /**
   * Get the current selection from the model.
   */
  async getSelection() {
    const res = await this.actionDispatcher.request(sprotty_protocol_1.GetSelectionAction.create());
    const result = [];
    this.gatherSelectedElements(this.currentRoot, new Set(res.selectedElementsIDs), result);
    return result;
  }
  gatherSelectedElements(element, selected, result) {
    if (selected.has(element.id)) {
      result.push(element);
    }
    if (element.children) {
      for (const child of element.children) {
        this.gatherSelectedElements(child, selected, result);
      }
    }
  }
  /**
   * Get the current viewport from the model.
   */
  async getViewport() {
    const res = await this.actionDispatcher.request(sprotty_protocol_1.GetViewportAction.create());
    return {
      scroll: res.viewport.scroll,
      zoom: res.viewport.zoom,
      canvasBounds: res.canvasBounds
    };
  }
  /**
   * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
   * `ComputedBoundsAction`, otherwise call `doSubmitModel()` directly.
   */
  async submitModel(newRoot, update, cause) {
    if (this.viewerOptions.needsClientLayout) {
      const computedBounds = await this.actionDispatcher.request(actions_1$1.RequestBoundsAction.create(newRoot));
      const index = this.computedBoundsApplicator.apply(this.currentRoot, computedBounds);
      await this.doSubmitModel(newRoot, true, cause, index);
    } else {
      await this.doSubmitModel(newRoot, update, cause);
    }
  }
  /**
   * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
   * `update` argument. If available, the model layout engine is invoked first.
   */
  async doSubmitModel(newRoot, update, cause, index) {
    if (this.layoutEngine !== void 0) {
      try {
        const layoutResult = this.layoutEngine.layout(newRoot, index);
        if (layoutResult instanceof Promise)
          newRoot = await layoutResult;
        else if (layoutResult !== void 0)
          newRoot = layoutResult;
      } catch (error) {
        this.logger.error(this, error.toString(), error.stack);
      }
    }
    const lastSubmittedModelType = this.lastSubmittedModelType;
    this.lastSubmittedModelType = newRoot.type;
    if (cause && cause.kind === actions_1$1.RequestModelAction.KIND && cause.requestId) {
      const request = cause;
      await this.actionDispatcher.dispatch(actions_1$1.SetModelAction.create(newRoot, request.requestId));
    } else if (update && newRoot.type === lastSubmittedModelType) {
      const input = Array.isArray(update) ? update : newRoot;
      await this.actionDispatcher.dispatch(actions_1$1.UpdateModelAction.create(input, {
        animate: true,
        cause
      }));
    } else {
      await this.actionDispatcher.dispatch(actions_1$1.SetModelAction.create(newRoot));
    }
  }
  /**
   * Modify the current model with an array of matches.
   */
  applyMatches(matches) {
    const root = this.currentRoot;
    (0, model_matching_1.applyMatches)(root, matches);
    return this.submitModel(root, matches);
  }
  /**
   * Modify the current model by adding new elements.
   */
  addElements(elements) {
    const matches = [];
    for (const e of elements) {
      const anye = e;
      if (typeof anye.element === "object" && typeof anye.parentId === "string") {
        matches.push({
          right: anye.element,
          rightParentId: anye.parentId
        });
      } else if (typeof anye.id === "string") {
        matches.push({
          right: anye,
          rightParentId: this.currentRoot.id
        });
      }
    }
    return this.applyMatches(matches);
  }
  /**
   * Modify the current model by removing elements.
   */
  removeElements(elements) {
    const matches = [];
    const index = new model_utils_1.SModelIndex();
    index.add(this.currentRoot);
    for (const e of elements) {
      const anye = e;
      if (anye.elementId !== void 0 && anye.parentId !== void 0) {
        const element = index.getById(anye.elementId);
        if (element !== void 0) {
          matches.push({
            left: element,
            leftParentId: anye.parentId
          });
        }
      } else {
        const element = index.getById(anye);
        if (element !== void 0) {
          matches.push({
            left: element,
            leftParentId: this.currentRoot.id
          });
        }
      }
    }
    return this.applyMatches(matches);
  }
  // ----- Methods for handling incoming actions ----------------------------
  handle(action2) {
    switch (action2.kind) {
      case actions_1$1.RequestModelAction.KIND:
        this.handleRequestModel(action2);
        break;
      case actions_1$1.ComputedBoundsAction.KIND:
        this.computedBoundsApplicator.apply(this.currentRoot, action2);
        break;
      case actions_1$1.RequestPopupModelAction.KIND:
        this.handleRequestPopupModel(action2);
        break;
      case svg_exporter_1.ExportSvgAction.KIND:
        this.handleExportSvgAction(action2);
        break;
    }
  }
  handleRequestModel(action2) {
    this.submitModel(this.currentRoot, false, action2);
  }
  handleRequestPopupModel(action2) {
    if (this.popupModelProvider !== void 0) {
      const element = (0, model_utils_1.findElement)(this.currentRoot, action2.elementId);
      const popupRoot = this.popupModelProvider.getPopupModel(action2, element);
      if (popupRoot !== void 0) {
        popupRoot.canvasBounds = action2.bounds;
        this.actionDispatcher.dispatch(actions_1$1.SetPopupModelAction.create(popupRoot, action2.requestId));
      }
    }
  }
  handleExportSvgAction(action2) {
    const blob = new Blob([action2.svg], {
      type: "text/plain;charset=utf-8"
    });
    (0, file_saver_1.saveAs)(blob, "diagram.svg");
  }
};
localModelSource.LocalModelSource = LocalModelSource;
__decorate$2([(0, inversify_1$2.inject)(types_1$1.TYPES.ILogger), __metadata$1("design:type", Object)], LocalModelSource.prototype, "logger", void 0);
__decorate$2([(0, inversify_1$2.inject)(model_source_1.ComputedBoundsApplicator), __metadata$1("design:type", model_source_1.ComputedBoundsApplicator)], LocalModelSource.prototype, "computedBoundsApplicator", void 0);
__decorate$2([(0, inversify_1$2.inject)(types_1$1.TYPES.IPopupModelProvider), (0, inversify_1$2.optional)(), __metadata$1("design:type", Object)], LocalModelSource.prototype, "popupModelProvider", void 0);
__decorate$2([(0, inversify_1$2.inject)(types_1$1.TYPES.IModelLayoutEngine), (0, inversify_1$2.optional)(), __metadata$1("design:type", Object)], LocalModelSource.prototype, "layoutEngine", void 0);
localModelSource.LocalModelSource = LocalModelSource = __decorate$2([(0, inversify_1$2.injectable)()], LocalModelSource);
var logging = {};
var __decorate$1 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = commonjsGlobal && commonjsGlobal.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(logging, "__esModule", {
  value: true
});
logging.ForwardingLogger = void 0;
const inversify_1$1 = require$$0$1;
const actions_1 = actions;
const logging_1 = logging$1;
const types_1 = types;
let ForwardingLogger = class ForwardingLogger2 {
  error(thisArg, message, ...params) {
    if (this.logLevel >= logging_1.LogLevel.error)
      this.forward(thisArg, message, logging_1.LogLevel.error, params);
  }
  warn(thisArg, message, ...params) {
    if (this.logLevel >= logging_1.LogLevel.warn)
      this.forward(thisArg, message, logging_1.LogLevel.warn, params);
  }
  info(thisArg, message, ...params) {
    if (this.logLevel >= logging_1.LogLevel.info)
      this.forward(thisArg, message, logging_1.LogLevel.info, params);
  }
  log(thisArg, message, ...params) {
    if (this.logLevel >= logging_1.LogLevel.log) {
      try {
        const caller = typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg);
        console.log.apply(thisArg, [caller + ": " + message, ...params]);
      } catch (error) {
      }
    }
  }
  forward(thisArg, message, logLevel, params) {
    const date = /* @__PURE__ */ new Date();
    const action2 = actions_1.LoggingAction.create({
      message,
      severity: logging_1.LogLevel[logLevel],
      time: date.toLocaleTimeString(),
      caller: typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg),
      params: params.map((p2) => JSON.stringify(p2))
    });
    this.modelSourceProvider().then((modelSource2) => {
      try {
        modelSource2.handle(action2);
      } catch (error) {
        try {
          console.log.apply(thisArg, [message, action2, error]);
        } catch (e) {
        }
      }
    });
  }
};
logging.ForwardingLogger = ForwardingLogger;
__decorate$1([(0, inversify_1$1.inject)(types_1.TYPES.ModelSourceProvider), __metadata("design:type", Function)], ForwardingLogger.prototype, "modelSourceProvider", void 0);
__decorate$1([(0, inversify_1$1.inject)(types_1.TYPES.LogLevel), __metadata("design:type", Number)], ForwardingLogger.prototype, "logLevel", void 0);
logging.ForwardingLogger = ForwardingLogger = __decorate$1([(0, inversify_1$1.injectable)()], ForwardingLogger);
var websocket = {};
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(websocket, "__esModule", {
  value: true
});
websocket.WebSocketDiagramServerProxy = void 0;
const inversify_1 = require$$0$1;
const diagram_server_1 = diagramServer;
let WebSocketDiagramServerProxy = class WebSocketDiagramServerProxy2 extends diagram_server_1.DiagramServerProxy {
  listen(webSocket) {
    webSocket.addEventListener("message", (event) => {
      this.messageReceived(event.data);
    });
    webSocket.addEventListener("error", (event) => {
      this.logger.error(this, "error event received", event);
    });
    this.webSocket = webSocket;
  }
  disconnect() {
    if (this.webSocket) {
      this.webSocket.close();
      this.webSocket = void 0;
    }
  }
  sendMessage(message) {
    if (this.webSocket) {
      this.webSocket.send(JSON.stringify(message));
    } else {
      throw new Error("WebSocket is not connected");
    }
  }
};
websocket.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy;
websocket.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy = __decorate([(0, inversify_1.injectable)()], WebSocketDiagramServerProxy);
var color = {};
Object.defineProperty(color, "__esModule", {
  value: true
});
color.ColorMap = color.toSVG = color.rgb = void 0;
function rgb(red, green, blue) {
  return {
    red,
    green,
    blue
  };
}
color.rgb = rgb;
function toSVG(c) {
  return "rgb(" + c.red + "," + c.green + "," + c.blue + ")";
}
color.toSVG = toSVG;
class ColorMap {
  constructor(stops) {
    this.stops = stops;
  }
  getColor(t) {
    t = Math.max(0, Math.min(0.99999999, t));
    const i = Math.floor(t * this.stops.length);
    return this.stops[i];
  }
}
color.ColorMap = ColorMap;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m, p2);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.modelSourceModule = exports.zorderModule = exports.viewportModule = exports.updateModule = exports.undoRedoModule = exports.selectModule = exports.routingModule = exports.openModule = exports.moveModule = exports.hoverModule = exports.fadeModule = exports.exportModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeJunctionModule = exports.edgeIntersectionModule = exports.decorationModule = exports.contextMenuModule = exports.commandPaletteModule = exports.buttonModule = exports.boundsModule = exports.defaultModule = void 0;
  __exportStar(action, exports);
  __exportStar(actionDispatcher, exports);
  __exportStar(actionHandler$1, exports);
  __exportStar(diagramLocker, exports);
  __exportStar(animationFrameSyncer, exports);
  __exportStar(animation, exports);
  __exportStar(easing, exports);
  __exportStar(command, exports);
  __exportStar(commandRegistration, exports);
  __exportStar(commandStackOptions, exports);
  __exportStar(commandStack, exports);
  __exportStar(initializeCanvas, exports);
  __exportStar(setModel, exports);
  __exportStar(smodelFactory, exports);
  __exportStar(smodelUtils, exports);
  __exportStar(smodel, exports);
  __exportStar(uiExtensionRegistry, exports);
  __exportStar(uiExtension, exports);
  __exportStar(keyTool, exports);
  __exportStar(mouseTool, exports);
  __exportStar(thunkView, exports);
  __exportStar(view, exports);
  __exportStar(viewerCache, exports);
  __exportStar(viewerOptions, exports);
  __exportStar(viewer, exports);
  __exportStar(vnodePostprocessor, exports);
  __exportStar(vnodeUtils, exports);
  __exportStar(types, exports);
  const di_config_110 = __importDefault2(di_config$m);
  exports.defaultModule = di_config_110.default;
  __exportStar(boundsManipulation, exports);
  __exportStar(hiddenBoundsUpdater, exports);
  __exportStar(layout, exports);
  __exportStar(model$g, exports);
  __exportStar(vboxLayout, exports);
  __exportStar(hboxLayout, exports);
  __exportStar(stackLayout, exports);
  __exportStar(views$5, exports);
  __exportStar(buttonHandler, exports);
  __exportStar(model$f, exports);
  __exportStar(actionProviders, exports);
  __exportStar(commandPalette, exports);
  __exportStar(contextMenuService, exports);
  __exportStar(menuProviders, exports);
  __exportStar(mouseListener, exports);
  __exportStar(di_config$l, exports);
  __exportStar(edgeLayout, exports);
  __exportStar(model$b, exports);
  __exportStar(create, exports);
  __exportStar(createOnDrag, exports);
  __exportStar(di_config$k, exports);
  __exportStar(_delete, exports);
  __exportStar(editLabel, exports);
  __exportStar(editLabelUi, exports);
  __exportStar(editRouting, exports);
  __exportStar(model$7, exports);
  __exportStar(reconnect, exports);
  __exportStar(expand, exports);
  __exportStar(model$4, exports);
  __exportStar(views$4, exports);
  __exportStar(_export, exports);
  __exportStar(model$5, exports);
  __exportStar(svgExporter, exports);
  __exportStar(fade, exports);
  __exportStar(model$e, exports);
  __exportStar(hover, exports);
  __exportStar(model$9, exports);
  __exportStar(model$3, exports);
  __exportStar(views$3, exports);
  __exportStar(decorationPlacer, exports);
  __exportStar(intersectionFinder, exports);
  __exportStar(sweepline, exports);
  __exportStar(junctionFinder, exports);
  __exportStar(model$8, exports);
  __exportStar(move, exports);
  __exportStar(snap, exports);
  __exportStar(model$d, exports);
  __exportStar(open$1, exports);
  __exportStar(model$2, exports);
  __exportStar(model$1, exports);
  __exportStar(views$2, exports);
  __exportStar(anchor, exports);
  __exportStar(abstractEdgeRouter, exports);
  __exportStar(bezierAnchors, exports);
  __exportStar(bezierEdgeRouter, exports);
  __exportStar(manhattanAnchors, exports);
  __exportStar(manhattanEdgeRouter, exports);
  __exportStar(model$a, exports);
  __exportStar(polylineAnchors, exports);
  __exportStar(polylineEdgeRouter, exports);
  __exportStar(routing, exports);
  __exportStar(views$1, exports);
  __exportStar(model$c, exports);
  __exportStar(select, exports);
  __exportStar(undoRedo, exports);
  __exportStar(modelMatching, exports);
  __exportStar(updateModel, exports);
  __exportStar(centerFit, exports);
  __exportStar(model$6, exports);
  __exportStar(scroll, exports);
  __exportStar(viewportRoot, exports);
  __exportStar(viewport, exports);
  __exportStar(zoom, exports);
  __exportStar(zorder, exports);
  const di_config_22 = __importDefault2(di_config$j);
  exports.boundsModule = di_config_22.default;
  const di_config_32 = __importDefault2(di_config$i);
  exports.buttonModule = di_config_32.default;
  const di_config_42 = __importDefault2(di_config$h);
  exports.commandPaletteModule = di_config_42.default;
  const di_config_52 = __importDefault2(di_config$g);
  exports.contextMenuModule = di_config_52.default;
  const di_config_62 = __importDefault2(di_config$f);
  exports.decorationModule = di_config_62.default;
  const di_config_72 = __importDefault2(di_config$e);
  exports.edgeIntersectionModule = di_config_72.default;
  const di_config_82 = __importDefault2(di_config$d);
  exports.edgeJunctionModule = di_config_82.default;
  const di_config_92 = __importDefault2(di_config$l);
  exports.edgeLayoutModule = di_config_92.default;
  const di_config_102 = __importDefault2(di_config$c);
  exports.expandModule = di_config_102.default;
  const di_config_112 = __importDefault2(di_config$b);
  exports.exportModule = di_config_112.default;
  const di_config_122 = __importDefault2(di_config$a);
  exports.fadeModule = di_config_122.default;
  const di_config_132 = __importDefault2(di_config$9);
  exports.hoverModule = di_config_132.default;
  const di_config_142 = __importDefault2(di_config$8);
  exports.moveModule = di_config_142.default;
  const di_config_152 = __importDefault2(di_config$7);
  exports.openModule = di_config_152.default;
  const di_config_162 = __importDefault2(di_config$6);
  exports.routingModule = di_config_162.default;
  const di_config_172 = __importDefault2(di_config$5);
  exports.selectModule = di_config_172.default;
  const di_config_182 = __importDefault2(di_config$4);
  exports.undoRedoModule = di_config_182.default;
  const di_config_192 = __importDefault2(di_config$3);
  exports.updateModule = di_config_192.default;
  const di_config_202 = __importDefault2(di_config$2);
  exports.viewportModule = di_config_202.default;
  const di_config_212 = __importDefault2(di_config$1);
  exports.zorderModule = di_config_212.default;
  __exportStar(sgraph, exports);
  __exportStar(views, exports);
  __exportStar(modules, exports);
  __exportStar(genericViews, exports);
  __exportStar(htmlViews, exports);
  __exportStar(jsx, exports);
  __exportStar(model, exports);
  __exportStar(svgViews, exports);
  __exportStar(commitModel, exports);
  __exportStar(diagramServer, exports);
  __exportStar(localModelSource, exports);
  __exportStar(logging, exports);
  __exportStar(modelSource, exports);
  __exportStar(websocket, exports);
  const di_config_222 = __importDefault2(di_config);
  exports.modelSourceModule = di_config_222.default;
  __exportStar(browser, exports);
  __exportStar(codicon, exports);
  __exportStar(color, exports);
  __exportStar(geometry, exports);
  __exportStar(inversify, exports);
  __exportStar(logging$1, exports);
  __exportStar(registry, exports);
})(lib$1);
var mt = (he) => ({
  avoidLib: void 0,
  async load(ie = void 0) {
    if (this.avoidLib)
      console.log("Avoid library is already initialized");
    else {
      let t = function(de, re) {
        return ie !== void 0 && de.endsWith(".wasm") ? ie : re + de;
      };
      this.avoidLib = await he({
        locateFile: t
      });
    }
  },
  getInstance() {
    if (!this.avoidLib)
      throw new Error("Avoid library should be initialized before using");
    return this.avoidLib;
  }
});
var Ti = (() => {
  var he = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(ie = {}) {
    var t;
    t || (t = typeof ie < "u" ? ie : {});
    var de, re;
    t.ready = new Promise(function(e, n) {
      de = e, re = n;
    }), "_malloc getExceptionMessage ___get_exception_message _free ___cpp_exception ___cxa_increment_exception_refcount ___cxa_decrement_exception_refcount ___thrown_object_from_unwind_exception _fflush _emscripten_bind_VoidPtr___destroy___0 _emscripten_bind_HyperedgeImprover_HyperedgeImprover_0 _emscripten_bind_HyperedgeImprover_clear_0 _emscripten_bind_HyperedgeImprover_setRouter_1 _emscripten_bind_HyperedgeImprover___destroy___0 _emscripten_bind_Box_Box_0 _emscripten_bind_Box_length_1 _emscripten_bind_Box_width_0 _emscripten_bind_Box_height_0 _emscripten_bind_Box_get_min_0 _emscripten_bind_Box_set_min_1 _emscripten_bind_Box_get_max_0 _emscripten_bind_Box_set_max_1 _emscripten_bind_Box___destroy___0 _emscripten_bind_PolygonInterface_clear_0 _emscripten_bind_PolygonInterface_empty_0 _emscripten_bind_PolygonInterface_size_0 _emscripten_bind_PolygonInterface_id_0 _emscripten_bind_PolygonInterface_at_1 _emscripten_bind_PolygonInterface_boundingRectPolygon_0 _emscripten_bind_PolygonInterface_offsetBoundingBox_1 _emscripten_bind_PolygonInterface_offsetPolygon_1 _emscripten_bind_PolygonInterface___destroy___0 _emscripten_bind_Polygon_Polygon_0 _emscripten_bind_Polygon_Polygon_1 _emscripten_bind_Polygon_setPoint_2 _emscripten_bind_Polygon_size_0 _emscripten_bind_Polygon_get_ps_1 _emscripten_bind_Polygon_set_ps_2 _emscripten_bind_Polygon___destroy___0 _emscripten_bind_Point_Point_0 _emscripten_bind_Point_Point_2 _emscripten_bind_Point_equal_1 _emscripten_bind_Point_get_x_0 _emscripten_bind_Point_set_x_1 _emscripten_bind_Point_get_y_0 _emscripten_bind_Point_set_y_1 _emscripten_bind_Point_get_id_0 _emscripten_bind_Point_set_id_1 _emscripten_bind_Point_get_vn_0 _emscripten_bind_Point_set_vn_1 _emscripten_bind_Point___destroy___0 _emscripten_bind_Rectangle_Rectangle_2 _emscripten_bind_Rectangle_Rectangle_3 _emscripten_bind_Rectangle___destroy___0 _emscripten_bind_HyperedgeTreeNode_HyperedgeTreeNode_0 _emscripten_bind_HyperedgeTreeNode_writeEdgesToConns_2 _emscripten_bind_HyperedgeTreeNode___destroy___0 _emscripten_bind_HyperedgeTreeEdge_HyperedgeTreeEdge_3 _emscripten_bind_HyperedgeTreeEdge___destroy___0 _emscripten_bind_AStarPath_AStarPath_0 _emscripten_bind_AStarPath_search_4 _emscripten_bind_AStarPath___destroy___0 _emscripten_bind_ConnEnd_ConnEnd_1 _emscripten_bind_ConnEnd_ConnEnd_2 _emscripten_bind_ConnEnd_createConnEndFromJunctionRef_1 _emscripten_bind_ConnEnd___destroy___0 _emscripten_bind_ActionInfo_ActionInfo_2 _emscripten_bind_ActionInfo_ActionInfo_3 _emscripten_bind_ActionInfo_ActionInfo_4 _emscripten_bind_ActionInfo_obstacle_0 _emscripten_bind_ActionInfo_shape_0 _emscripten_bind_ActionInfo_conn_0 _emscripten_bind_ActionInfo_junction_0 _emscripten_bind_ActionInfo_addConnEndUpdate_3 _emscripten_bind_ActionInfo_get_type_0 _emscripten_bind_ActionInfo_set_type_1 _emscripten_bind_ActionInfo_get_objPtr_0 _emscripten_bind_ActionInfo_set_objPtr_1 _emscripten_bind_ActionInfo_get_newPoly_0 _emscripten_bind_ActionInfo_set_newPoly_1 _emscripten_bind_ActionInfo_get_newPosition_0 _emscripten_bind_ActionInfo_set_newPosition_1 _emscripten_bind_ActionInfo_get_firstMove_0 _emscripten_bind_ActionInfo_set_firstMove_1 _emscripten_bind_ActionInfo___destroy___0 _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_2 _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_3 _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_6 _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_7 _emscripten_bind_ShapeConnectionPin_setConnectionCost_1 _emscripten_bind_ShapeConnectionPin_position_0 _emscripten_bind_ShapeConnectionPin_position_1 _emscripten_bind_ShapeConnectionPin_directions_0 _emscripten_bind_ShapeConnectionPin_setExclusive_1 _emscripten_bind_ShapeConnectionPin_isExclusive_0 _emscripten_bind_ShapeConnectionPin_updatePosition_1 _emscripten_bind_ShapeConnectionPin___destroy___0 _emscripten_bind_Obstacle_id_0 _emscripten_bind_Obstacle_polygon_0 _emscripten_bind_Obstacle_router_0 _emscripten_bind_Obstacle_position_0 _emscripten_bind_Obstacle_setNewPoly_1 _emscripten_bind_Obstacle___destroy___0 _emscripten_bind_JunctionRef_JunctionRef_2 _emscripten_bind_JunctionRef_JunctionRef_3 _emscripten_bind_JunctionRef_position_0 _emscripten_bind_JunctionRef_setPositionFixed_1 _emscripten_bind_JunctionRef_positionFixed_0 _emscripten_bind_JunctionRef_recommendedPosition_0 _emscripten_bind_JunctionRef___destroy___0 _emscripten_bind_ShapeRef_ShapeRef_2 _emscripten_bind_ShapeRef_ShapeRef_3 _emscripten_bind_ShapeRef_polygon_0 _emscripten_bind_ShapeRef_position_0 _emscripten_bind_ShapeRef_setNewPoly_1 _emscripten_bind_ShapeRef___destroy___0 _emscripten_bind_HyperedgeNewAndDeletedObjectLists___destroy___0 _emscripten_bind_HyperedgeRerouter_HyperedgeRerouter_0 _emscripten_bind_HyperedgeRerouter_registerHyperedgeForRerouting_1 _emscripten_bind_HyperedgeRerouter___destroy___0 _emscripten_bind_VertInf___destroy___0 _emscripten_bind_VertID_VertID_0 _emscripten_bind_VertID_VertID_2 _emscripten_bind_VertID_VertID_3 _emscripten_bind_VertID_get_objID_0 _emscripten_bind_VertID_set_objID_1 _emscripten_bind_VertID_get_vn_0 _emscripten_bind_VertID_set_vn_1 _emscripten_bind_VertID_get_props_0 _emscripten_bind_VertID_set_props_1 _emscripten_bind_VertID_get_src_0 _emscripten_bind_VertID_get_tar_0 _emscripten_bind_VertID_get_PROP_ConnPoint_0 _emscripten_bind_VertID_get_PROP_OrthShapeEdge_0 _emscripten_bind_VertID_get_PROP_ConnectionPin_0 _emscripten_bind_VertID_get_PROP_ConnCheckpoint_0 _emscripten_bind_VertID_get_PROP_DummyPinHelper_0 _emscripten_bind_VertID___destroy___0 _emscripten_bind_MinimumTerminalSpanningTree___destroy___0 _emscripten_bind_Checkpoint_Checkpoint_1 _emscripten_bind_Checkpoint___destroy___0 _emscripten_bind_ConnRef_ConnRef_3 _emscripten_bind_ConnRef_ConnRef_4 _emscripten_bind_ConnRef_id_0 _emscripten_bind_ConnRef_setCallback_2 _emscripten_bind_ConnRef_setSourceEndpoint_1 _emscripten_bind_ConnRef_setDestEndpoint_1 _emscripten_bind_ConnRef_routingType_0 _emscripten_bind_ConnRef_setRoutingType_1 _emscripten_bind_ConnRef_displayRoute_0 _emscripten_bind_ConnRef_setHateCrossings_1 _emscripten_bind_ConnRef_doesHateCrossings_0 _emscripten_bind_ConnRef___destroy___0 _emscripten_bind_EdgeInf_EdgeInf_2 _emscripten_bind_EdgeInf_EdgeInf_3 _emscripten_bind_EdgeInf___destroy___0 _emscripten_bind_LineRep_get_begin_0 _emscripten_bind_LineRep_set_begin_1 _emscripten_bind_LineRep_get_end_0 _emscripten_bind_LineRep_set_end_1 _emscripten_bind_LineRep___destroy___0 _emscripten_bind_Router_Router_1 _emscripten_bind_Router_processTransaction_0 _emscripten_bind_Router_printInfo_0 _emscripten_bind_Router_deleteConnector_1 _emscripten_bind_Router_moveShape_2 _emscripten_bind_Router_moveShape_3 _emscripten_bind_Router_deleteShape_1 _emscripten_bind_Router_moveJunction_2 _emscripten_bind_Router_moveJunction_3 _emscripten_bind_Router_setRoutingParameter_2 _emscripten_bind_Router_setRoutingOption_2 _emscripten_bind_Router___destroy___0 _emscripten_enum_Avoid_ConnDirFlag_ConnDirNone _emscripten_enum_Avoid_ConnDirFlag_ConnDirUp _emscripten_enum_Avoid_ConnDirFlag_ConnDirDown _emscripten_enum_Avoid_ConnDirFlag_ConnDirLeft _emscripten_enum_Avoid_ConnDirFlag_ConnDirRight _emscripten_enum_Avoid_ConnDirFlag_ConnDirAll _emscripten_enum_Avoid_ConnEndType_ConnEndPoint _emscripten_enum_Avoid_ConnEndType_ConnEndShapePin _emscripten_enum_Avoid_ConnEndType_ConnEndJunction _emscripten_enum_Avoid_ConnEndType_ConnEndEmpty _emscripten_enum_Avoid_ActionType_ShapeMove _emscripten_enum_Avoid_ActionType_ShapeAdd _emscripten_enum_Avoid_ActionType_ShapeRemove _emscripten_enum_Avoid_ActionType_JunctionMove _emscripten_enum_Avoid_ActionType_JunctionAdd _emscripten_enum_Avoid_ActionType_JunctionRemove _emscripten_enum_Avoid_ActionType_ConnChange _emscripten_enum_Avoid_ActionType_ConnectionPinChange _emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW90 _emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW180 _emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW270 _emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipX _emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipY _emscripten_enum_Avoid_ConnType_ConnType_None _emscripten_enum_Avoid_ConnType_ConnType_PolyLine _emscripten_enum_Avoid_ConnType_ConnType_Orthogonal _emscripten_enum_Avoid_RouterFlag_PolyLineRouting _emscripten_enum_Avoid_RouterFlag_OrthogonalRouting _emscripten_enum_Avoid_RoutingParameter_segmentPenalty _emscripten_enum_Avoid_RoutingParameter_anglePenalty _emscripten_enum_Avoid_RoutingParameter_crossingPenalty _emscripten_enum_Avoid_RoutingParameter_clusterCrossingPenalty _emscripten_enum_Avoid_RoutingParameter_fixedSharedPathPenalty _emscripten_enum_Avoid_RoutingParameter_portDirectionPenalty _emscripten_enum_Avoid_RoutingParameter_shapeBufferDistance _emscripten_enum_Avoid_RoutingParameter_idealNudgingDistance _emscripten_enum_Avoid_RoutingParameter_reverseDirectionPenalty _emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalSegmentsConnectedToShapes _emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingJunctions _emscripten_enum_Avoid_RoutingOption_penaliseOrthogonalSharedPathsAtConnEnds _emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalTouchingColinearSegments _emscripten_enum_Avoid_RoutingOption_performUnifyingNudgingPreprocessingStep _emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingAddingAndDeletingJunctions _emscripten_enum_Avoid_RoutingOption_nudgeSharedPathsWithCommonEndPoint onRuntimeInitialized".split(" ").forEach((e) => {
      Object.getOwnPropertyDescriptor(t.ready, e) || Object.defineProperty(t.ready, e, {
        get: () => T("You are getting " + e + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
        set: () => T("You are setting " + e + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
      });
    });
    var xe = Object.assign({}, t), Le = "./this.program";
    if (t.ENVIRONMENT)
      throw Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
    var W = "";
    if (typeof document < "u" && document.currentScript && (W = document.currentScript.src), he && (W = he), W.indexOf("blob:") !== 0 ? W = W.substr(0, W.replace(/[?#].*/, "").lastIndexOf("/") + 1) : W = "", typeof window != "object" && typeof importScripts != "function")
      throw Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
    var yt = t.print || console.log.bind(console), D = t.printErr || console.warn.bind(console);
    Object.assign(t, xe), xe = null, Object.getOwnPropertyDescriptor(t, "fetchSettings") && T("`Module.fetchSettings` was supplied but `fetchSettings` not included in INCOMING_MODULE_JS_API"), k("arguments", "arguments_"), t.thisProgram && (Le = t.thisProgram), k("thisProgram", "thisProgram"), k("quit", "quit_"), m(typeof t.memoryInitializerPrefixURL > "u", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"), m(typeof t.pthreadMainPrefixURL > "u", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"), m(typeof t.cdInitializerPrefixURL > "u", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"), m(typeof t.filePackagePrefixURL > "u", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"), m(typeof t.read > "u", "Module.read option was removed (modify read_ in JS)"), m(typeof t.readAsync > "u", "Module.readAsync option was removed (modify readAsync in JS)"), m(typeof t.readBinary > "u", "Module.readBinary option was removed (modify readBinary in JS)"), m(typeof t.setWindowTitle > "u", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)"), m(typeof t.TOTAL_MEMORY > "u", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"), k("read", "read_"), k("readAsync", "readAsync"), k("readBinary", "readBinary"), k("setWindowTitle", "setWindowTitle"), m(true, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable."), m(true, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable."), m(true, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
    var ae;
    t.wasmBinary && (ae = t.wasmBinary), k("wasmBinary", "wasmBinary");
    t.noExitRuntime || true;
    k("noExitRuntime", "noExitRuntime"), typeof WebAssembly != "object" && T("no native wasm support detected");
    var me, pe = false;
    function m(e, n) {
      e || T("Assertion failed" + (n ? ": " + n : ""));
    }
    var ve, ue, x, E;
    function He() {
      var e = me.buffer;
      t.HEAP8 = ve = new Int8Array(e), t.HEAP16 = new Int16Array(e), t.HEAP32 = x = new Int32Array(e), t.HEAPU8 = ue = new Uint8Array(e), t.HEAPU16 = new Uint16Array(e), t.HEAPU32 = E = new Uint32Array(e), t.HEAPF32 = new Float32Array(e), t.HEAPF64 = new Float64Array(e);
    }
    m(!t.STACK_SIZE, "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"), m(typeof Int32Array < "u" && typeof Float64Array < "u" && Int32Array.prototype.subarray != null && Int32Array.prototype.set != null, "JS engine does not provide full typed array support"), m(!t.wasmMemory, "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"), m(!t.INITIAL_MEMORY, "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
    var w;
    function gt() {
      var e = we();
      m((e & 3) == 0), e == 0 && (e += 4), E[e >> 2] = 34821223, E[e + 4 >> 2] = 2310721022, E[0] = 1668509029;
    }
    function Te() {
      if (!pe) {
        var e = we();
        e == 0 && (e += 4);
        var n = E[e >> 2], _ = E[e + 4 >> 2];
        n == 34821223 && _ == 2310721022 || T("Stack overflow! Stack cookie has been overwritten at " + be(e) + ", expected hex dwords 0x89BACDFE and 0x2135467, but received " + be(_) + " " + be(n)), E[0] !== 1668509029 && T("Runtime error: The application has corrupted its heap memory area (address zero)!");
      }
    }
    var Ne = new Int16Array(1), Ue = new Int8Array(Ne.buffer);
    if (Ne[0] = 25459, Ue[0] !== 115 || Ue[1] !== 99)
      throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
    var Ve = [], Se = [], Je = [], ye = false;
    function ft() {
      var e = t.preRun.shift();
      Ve.unshift(e);
    }
    m(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), m(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), m(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), m(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    var ee = 0, te = null, ge = null, fe = {};
    function bt() {
      ee++, t.monitorRunDependencies && t.monitorRunDependencies(ee), m(!fe["wasm-instantiate"]), fe["wasm-instantiate"] = 1, te === null && typeof setInterval < "u" && (te = setInterval(function() {
        if (pe)
          clearInterval(te), te = null;
        else {
          var e = false, n;
          for (n in fe)
            e || (e = true, D("still waiting on run dependencies:")), D("dependency: " + n);
          e && D("(end of list)");
        }
      }, 1e4));
    }
    function T(e) {
      throw t.onAbort && t.onAbort(e), e = "Aborted(" + e + ")", D(e), pe = true, ye && rt(), e = new WebAssembly.RuntimeError(e), re(e), e;
    }
    function Be() {
      T("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");
    }
    t.FS_createDataFile = function() {
      Be();
    }, t.FS_createPreloadedFile = function() {
      Be();
    };
    function We(e) {
      return e.startsWith("data:application/octet-stream;base64,");
    }
    function o(e) {
      return function() {
        var n = t.asm;
        return m(ye, "native function `" + e + "` called before runtime initialization"), n[e] || m(n[e], "exported native function `" + e + "` not found"), n[e].apply(null, arguments);
      };
    }
    var Ie = 0;
    function ke(e) {
      return function() {
        if (pe)
          throw "program has already aborted!";
        Ie += 1;
        try {
          return e.apply(null, arguments);
        } catch (n) {
          if (pe || 1 < Ie || n === "unwind")
            throw n;
          T("unhandled exception: " + [n, n.stack]);
        } finally {
          --Ie;
        }
      };
    }
    function lt() {
      var e = w.get, n = {};
      w.get = (_) => {
        var i = e.call(w, _), p2 = n[_];
        return p2 && p2.D === i || (p2 = n[_] = {
          D: i,
          ua: ke(i)
        }), p2.ua;
      };
    }
    var K;
    if (K = "libavoid.wasm", !We(K)) {
      var Ye = K;
      K = t.locateFile ? t.locateFile(Ye, W) : W + Ye;
    }
    function Ge(e) {
      try {
        if (e == K && ae)
          return new Uint8Array(ae);
        throw "both async and sync fetching of the wasm failed";
      } catch (n) {
        T(n);
      }
    }
    function ht(e) {
      return ae || typeof fetch != "function" ? Promise.resolve().then(function() {
        return Ge(e);
      }) : fetch(e, {
        credentials: "same-origin"
      }).then(function(n) {
        if (!n.ok)
          throw "failed to load wasm binary file at '" + e + "'";
        return n.arrayBuffer();
      }).catch(function() {
        return Ge(e);
      });
    }
    function ze(e, n, _) {
      return ht(e).then(function(i) {
        return WebAssembly.instantiate(i, n);
      }).then(function(i) {
        return i;
      }).then(_, function(i) {
        D("failed to asynchronously prepare wasm: " + i), K.startsWith("file://") && D("warning: Loading from a file URI (" + K + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing"), T(i);
      });
    }
    function vt(e, n) {
      var _ = K;
      return ae || typeof WebAssembly.instantiateStreaming != "function" || We(_) || typeof fetch != "function" ? ze(_, e, n) : fetch(_, {
        credentials: "same-origin"
      }).then(function(i) {
        return WebAssembly.instantiateStreaming(i, e).then(n, function(p2) {
          return D("wasm streaming compile failed: " + p2), D("falling back to ArrayBuffer instantiation"), ze(_, e, n);
        });
      });
    }
    function k(e, n) {
      Object.getOwnPropertyDescriptor(t, e) || Object.defineProperty(t, e, {
        configurable: true,
        get: function() {
          T("Module." + e + " has been replaced with plain " + n + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
        }
      });
    }
    function Ze(e) {
      return e === "FS_createPath" || e === "FS_createDataFile" || e === "FS_createPreloadedFile" || e === "FS_unlink" || e === "addRunDependency" || e === "FS_createLazyFile" || e === "FS_createDevice" || e === "removeRunDependency";
    }
    (function(e, n) {
      typeof globalThis < "u" && Object.defineProperty(globalThis, e, {
        configurable: true,
        get: function() {
          Pe("`" + e + "` is not longer defined by emscripten. " + n);
        }
      });
    })("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
    function Xe(e) {
      Object.getOwnPropertyDescriptor(t, e) || Object.defineProperty(t, e, {
        configurable: true,
        get: function() {
          var n = "'" + e + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
          Ze(e) && (n += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), T(n);
        }
      });
    }
    function Ke(e, n) {
      m(16384 > e), 128 > e ? n.push(e) : n.push(e % 128 | 128, e >> 7);
    }
    var se = [], ce = void 0, Qe = [];
    function Ee(e) {
      for (; 0 < e.length; )
        e.shift()(t);
    }
    function Pt(e) {
      var n = Pi();
      return e = e(), Ci(n), e;
    }
    var $e = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function qe(e, n) {
      for (var _ = n + NaN, i = n; e[i] && !(i >= _); )
        ++i;
      if (16 < i - n && e.buffer && $e)
        return $e.decode(e.subarray(n, i));
      for (_ = ""; n < i; ) {
        var p2 = e[n++];
        if (p2 & 128) {
          var s = e[n++] & 63;
          if ((p2 & 224) == 192)
            _ += String.fromCharCode((p2 & 31) << 6 | s);
          else {
            var u = e[n++] & 63;
            (p2 & 240) == 224 ? p2 = (p2 & 15) << 12 | s << 6 | u : ((p2 & 248) != 240 && Pe("Invalid UTF-8 leading byte " + be(p2) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"), p2 = (p2 & 7) << 18 | s << 12 | u << 6 | e[n++] & 63), 65536 > p2 ? _ += String.fromCharCode(p2) : (p2 -= 65536, _ += String.fromCharCode(55296 | p2 >> 10, 56320 | p2 & 1023));
          }
        } else
          _ += String.fromCharCode(p2);
      }
      return _;
    }
    function ne(e) {
      return m(typeof e == "number"), e ? qe(ue, e) : "";
    }
    function Ct(e) {
      return Pt(function() {
        var n = st(4), _ = st(4);
        Ai(e, n, _), n = E[n >> 2], _ = E[_ >> 2];
        var i = ne(n);
        if (it(n), _) {
          var p2 = ne(_);
          it(_);
        }
        return [i, p2];
      });
    }
    function et(e) {
      return e = e.getArg(t.asm.__cpp_exception, 0), e = Ri(e), Ct(e);
    }
    t.getExceptionMessage = et;
    function be(e) {
      return m(typeof e == "number"), "0x" + e.toString(16).padStart(8, "0");
    }
    function Pe(e) {
      Ce || (Ce = {}), Ce[e] || (Ce[e] = 1, D(e));
    }
    var Ce, Oe = {};
    function tt() {
      if (!De) {
        var e = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
          _: Le || "./this.program"
        }, n;
        for (n in Oe)
          Oe[n] === void 0 ? delete e[n] : e[n] = Oe[n];
        var _ = [];
        for (n in e)
          _.push(n + "=" + e[n]);
        De = _;
      }
      return De;
    }
    var De, Rt = [null, [], []];
    function Re(e) {
      return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
    }
    var nt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ot = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function At(e) {
      for (var n = 0, _ = 0; _ < e.length; ++_) {
        var i = e.charCodeAt(_);
        127 >= i ? n++ : 2047 >= i ? n += 2 : 55296 <= i && 57343 >= i ? (n += 4, ++_) : n += 3;
      }
      if (n = Array(n + 1), i = n.length, _ = 0, m(typeof e == "string"), 0 < i) {
        i = _ + i - 1;
        for (var p2 = 0; p2 < e.length; ++p2) {
          var s = e.charCodeAt(p2);
          if (55296 <= s && 57343 >= s) {
            var u = e.charCodeAt(++p2);
            s = 65536 + ((s & 1023) << 10) | u & 1023;
          }
          if (127 >= s) {
            if (_ >= i)
              break;
            n[_++] = s;
          } else {
            if (2047 >= s) {
              if (_ + 1 >= i)
                break;
              n[_++] = 192 | s >> 6;
            } else {
              if (65535 >= s) {
                if (_ + 2 >= i)
                  break;
                n[_++] = 224 | s >> 12;
              } else {
                if (_ + 3 >= i)
                  break;
                1114111 < s && Pe("Invalid Unicode code point " + be(s) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."), n[_++] = 240 | s >> 18, n[_++] = 128 | s >> 12 & 63;
              }
              n[_++] = 128 | s >> 6 & 63;
            }
            n[_++] = 128 | s & 63;
          }
        }
        n[_] = 0;
      }
      return n;
    }
    function Tt(e, n) {
      m(0 <= e.length, "writeArrayToMemory array must have a length (should be an array or typed array)"), ve.set(e, n);
    }
    function St(e, n, _, i) {
      function p2(r, b, P) {
        for (r = typeof r == "number" ? r.toString() : r || ""; r.length < b; )
          r = P[0] + r;
        return r;
      }
      function s(r, b) {
        return p2(r, b, "0");
      }
      function u(r, b) {
        function P(at) {
          return 0 > at ? -1 : 0 < at ? 1 : 0;
        }
        var _e;
        return (_e = P(r.getFullYear() - b.getFullYear())) === 0 && (_e = P(r.getMonth() - b.getMonth())) === 0 && (_e = P(r.getDate() - b.getDate())), _e;
      }
      function F(r) {
        switch (r.getDay()) {
          case 0:
            return new Date(r.getFullYear() - 1, 11, 29);
          case 1:
            return r;
          case 2:
            return new Date(r.getFullYear(), 0, 3);
          case 3:
            return new Date(r.getFullYear(), 0, 2);
          case 4:
            return new Date(r.getFullYear(), 0, 1);
          case 5:
            return new Date(r.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(r.getFullYear() - 1, 11, 30);
        }
      }
      function H(r) {
        var b = r.o;
        for (r = new Date(new Date(r.s + 1900, 0, 1).getTime()); 0 < b; ) {
          var P = r.getMonth(), _e = (Re(r.getFullYear()) ? nt : ot)[P];
          if (b > _e - r.getDate())
            b -= _e - r.getDate() + 1, r.setDate(1), 11 > P ? r.setMonth(P + 1) : (r.setMonth(0), r.setFullYear(r.getFullYear() + 1));
          else {
            r.setDate(r.getDate() + b);
            break;
          }
        }
        return P = new Date(r.getFullYear() + 1, 0, 4), b = F(new Date(r.getFullYear(), 0, 4)), P = F(P), 0 >= u(b, r) ? 0 >= u(P, r) ? r.getFullYear() + 1 : r.getFullYear() : r.getFullYear() - 1;
      }
      var V = x[i + 40 >> 2];
      i = {
        sa: x[i >> 2],
        ra: x[i + 4 >> 2],
        u: x[i + 8 >> 2],
        C: x[i + 12 >> 2],
        v: x[i + 16 >> 2],
        s: x[i + 20 >> 2],
        m: x[i + 24 >> 2],
        o: x[i + 28 >> 2],
        va: x[i + 32 >> 2],
        qa: x[i + 36 >> 2],
        ta: V ? ne(V) : ""
      }, _ = ne(_), V = {
        "%c": "%a %b %d %H:%M:%S %Y",
        "%D": "%m/%d/%y",
        "%F": "%Y-%m-%d",
        "%h": "%b",
        "%r": "%I:%M:%S %p",
        "%R": "%H:%M",
        "%T": "%H:%M:%S",
        "%x": "%m/%d/%y",
        "%X": "%H:%M:%S",
        "%Ec": "%c",
        "%EC": "%C",
        "%Ex": "%m/%d/%y",
        "%EX": "%H:%M:%S",
        "%Ey": "%y",
        "%EY": "%Y",
        "%Od": "%d",
        "%Oe": "%e",
        "%OH": "%H",
        "%OI": "%I",
        "%Om": "%m",
        "%OM": "%M",
        "%OS": "%S",
        "%Ou": "%u",
        "%OU": "%U",
        "%OV": "%V",
        "%Ow": "%w",
        "%OW": "%W",
        "%Oy": "%y"
      };
      for (var M in V)
        _ = _.replace(new RegExp(M, "g"), V[M]);
      var oe = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), dt = "January February March April May June July August September October November December".split(" ");
      V = {
        "%a": function(r) {
          return oe[r.m].substring(0, 3);
        },
        "%A": function(r) {
          return oe[r.m];
        },
        "%b": function(r) {
          return dt[r.v].substring(0, 3);
        },
        "%B": function(r) {
          return dt[r.v];
        },
        "%C": function(r) {
          return s((r.s + 1900) / 100 | 0, 2);
        },
        "%d": function(r) {
          return s(r.C, 2);
        },
        "%e": function(r) {
          return p2(r.C, 2, " ");
        },
        "%g": function(r) {
          return H(r).toString().substring(2);
        },
        "%G": function(r) {
          return H(r);
        },
        "%H": function(r) {
          return s(r.u, 2);
        },
        "%I": function(r) {
          return r = r.u, r == 0 ? r = 12 : 12 < r && (r -= 12), s(r, 2);
        },
        "%j": function(r) {
          for (var b = 0, P = 0; P <= r.v - 1; b += (Re(r.s + 1900) ? nt : ot)[P++])
            ;
          return s(r.C + b, 3);
        },
        "%m": function(r) {
          return s(r.v + 1, 2);
        },
        "%M": function(r) {
          return s(r.ra, 2);
        },
        "%n": function() {
          return `
`;
        },
        "%p": function(r) {
          return 0 <= r.u && 12 > r.u ? "AM" : "PM";
        },
        "%S": function(r) {
          return s(r.sa, 2);
        },
        "%t": function() {
          return "	";
        },
        "%u": function(r) {
          return r.m || 7;
        },
        "%U": function(r) {
          return s(Math.floor((r.o + 7 - r.m) / 7), 2);
        },
        "%V": function(r) {
          var b = Math.floor((r.o + 7 - (r.m + 6) % 7) / 7);
          if (2 >= (r.m + 371 - r.o - 2) % 7 && b++, b)
            b == 53 && (P = (r.m + 371 - r.o) % 7, P == 4 || P == 3 && Re(r.s) || (b = 1));
          else {
            b = 52;
            var P = (r.m + 7 - r.o - 1) % 7;
            (P == 4 || P == 5 && Re(r.s % 400 - 1)) && b++;
          }
          return s(b, 2);
        },
        "%w": function(r) {
          return r.m;
        },
        "%W": function(r) {
          return s(Math.floor((r.o + 7 - (r.m + 6) % 7) / 7), 2);
        },
        "%y": function(r) {
          return (r.s + 1900).toString().substring(2);
        },
        "%Y": function(r) {
          return r.s + 1900;
        },
        "%z": function(r) {
          r = r.qa;
          var b = 0 <= r;
          return r = Math.abs(r) / 60, (b ? "+" : "-") + ("0000" + (r / 60 * 100 + r % 60)).slice(-4);
        },
        "%Z": function(r) {
          return r.ta;
        },
        "%%": function() {
          return "%";
        }
      }, _ = _.replace(/%%/g, "\0\0");
      for (M in V)
        _.includes(M) && (_ = _.replace(new RegExp(M, "g"), V[M](i)));
      return _ = _.replace(/\0\0/g, "%"), M = At(_), M.length > n ? 0 : (Tt(M, e), M.length - 1);
    }
    var _t = {
      __assert_fail: function(e, n, _, i) {
        T("Assertion failed: " + ne(e) + ", at: " + [n ? ne(n) : "unknown filename", _, i ? ne(i) : "unknown function"]);
      },
      __throw_exception_with_stack_trace: function(e) {
        if (e = new WebAssembly.Exception(t.asm.__cpp_exception, [e], {
          wa: true
        }), e.message = et(e), e.stack) {
          var n = e.stack.split(`
`);
          n.splice(1, 1), e.stack = n.join(`
`);
        }
        throw e;
      },
      abort: function() {
        T("native code called abort()");
      },
      emscripten_date_now: function() {
        return Date.now();
      },
      emscripten_memcpy_big: function(e, n, _) {
        ue.copyWithin(e, n, n + _);
      },
      emscripten_resize_heap: function(e) {
        var n = ue.length;
        if (e >>>= 0, m(e > n), 2147483648 < e)
          return D("Cannot enlarge memory, asked to go up to " + e + " bytes, but the limit is 2147483648 bytes!"), false;
        for (var _ = 1; 4 >= _; _ *= 2) {
          var i = n * (1 + 0.2 / _);
          i = Math.min(i, e + 100663296);
          var p2 = Math;
          i = Math.max(e, i), p2 = p2.min.call(p2, 2147483648, i + (65536 - i % 65536) % 65536);
          e: {
            i = p2;
            var s = me.buffer;
            try {
              me.grow(i - s.byteLength + 65535 >>> 16), He();
              var u = 1;
              break e;
            } catch (F) {
              D("emscripten_realloc_buffer: Attempted to grow heap from " + s.byteLength + " bytes to " + i + " bytes, but got error: " + F);
            }
            u = void 0;
          }
          if (u)
            return true;
        }
        return D("Failed to grow the heap from " + n + " bytes to " + p2 + " bytes, not enough memory!"), false;
      },
      environ_get: function(e, n) {
        var _ = 0;
        return tt().forEach(function(i, p2) {
          var s = n + _;
          for (p2 = E[e + 4 * p2 >> 2] = s, s = 0; s < i.length; ++s)
            m(i.charCodeAt(s) === (i.charCodeAt(s) & 255)), ve[p2++ >> 0] = i.charCodeAt(s);
          ve[p2 >> 0] = 0, _ += i.length + 1;
        }), 0;
      },
      environ_sizes_get: function(e, n) {
        var _ = tt();
        E[e >> 2] = _.length;
        var i = 0;
        return _.forEach(function(p2) {
          i += p2.length + 1;
        }), E[n >> 2] = i, 0;
      },
      fd_close: function() {
        T("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
      },
      fd_seek: function() {
        return 70;
      },
      fd_write: function(e, n, _, i) {
        for (var p2 = 0, s = 0; s < _; s++) {
          var u = E[n >> 2], F = E[n + 4 >> 2];
          n += 8;
          for (var H = 0; H < F; H++) {
            var V = e, M = ue[u + H], oe = Rt[V];
            m(oe), M === 0 || M === 10 ? ((V === 1 ? yt : D)(qe(oe, 0)), oe.length = 0) : oe.push(M);
          }
          p2 += F;
        }
        return E[i >> 2] = p2, 0;
      },
      strftime_l: function(e, n, _, i) {
        return St(e, n, _, i);
      }
    };
    (function() {
      function e(i) {
        i = i.exports;
        var p2 = {};
        for (u in i) {
          var s = i[u];
          p2[u] = typeof s == "function" ? ke(s) : s;
        }
        if (i = p2, t.asm = i, me = t.asm.memory, m(me, "memory not found in wasm exports"), He(), w = t.asm.__indirect_function_table, m(w, "table not found in wasm exports"), Se.unshift(t.asm.__wasm_call_ctors), lt(), ee--, t.monitorRunDependencies && t.monitorRunDependencies(ee), m(fe["wasm-instantiate"]), delete fe["wasm-instantiate"], ee == 0 && (te !== null && (clearInterval(te), te = null), ge)) {
          var u = ge;
          ge = null, u();
        }
        return i;
      }
      var n = {
        env: _t,
        wasi_snapshot_preview1: _t
      };
      bt();
      var _ = t;
      if (t.instantiateWasm)
        try {
          return t.instantiateWasm(n, e);
        } catch (i) {
          D("Module.instantiateWasm callback failed with error: " + i), re(i);
        }
      return vt(n, function(i) {
        m(t === _, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"), _ = null, e(i.instance);
      }).catch(re), {};
    })(), t._malloc = o("malloc");
    var it = t._free = o("free");
    t._fflush = o("fflush");
    var It = t._emscripten_bind_VoidPtr___destroy___0 = o("emscripten_bind_VoidPtr___destroy___0"), Et = t._emscripten_bind_HyperedgeImprover_HyperedgeImprover_0 = o("emscripten_bind_HyperedgeImprover_HyperedgeImprover_0"), Ot = t._emscripten_bind_HyperedgeImprover_clear_0 = o("emscripten_bind_HyperedgeImprover_clear_0"), Dt = t._emscripten_bind_HyperedgeImprover_setRouter_1 = o("emscripten_bind_HyperedgeImprover_setRouter_1"), wt = t._emscripten_bind_HyperedgeImprover___destroy___0 = o("emscripten_bind_HyperedgeImprover___destroy___0"), jt = t._emscripten_bind_Box_Box_0 = o("emscripten_bind_Box_Box_0"), Ft = t._emscripten_bind_Box_length_1 = o("emscripten_bind_Box_length_1"), Mt = t._emscripten_bind_Box_width_0 = o("emscripten_bind_Box_width_0"), xt = t._emscripten_bind_Box_height_0 = o("emscripten_bind_Box_height_0"), Lt = t._emscripten_bind_Box_get_min_0 = o("emscripten_bind_Box_get_min_0"), Ht = t._emscripten_bind_Box_set_min_1 = o("emscripten_bind_Box_set_min_1"), Nt = t._emscripten_bind_Box_get_max_0 = o("emscripten_bind_Box_get_max_0"), Ut = t._emscripten_bind_Box_set_max_1 = o("emscripten_bind_Box_set_max_1"), Vt = t._emscripten_bind_Box___destroy___0 = o("emscripten_bind_Box___destroy___0"), Jt = t._emscripten_bind_PolygonInterface_clear_0 = o("emscripten_bind_PolygonInterface_clear_0"), Bt = t._emscripten_bind_PolygonInterface_empty_0 = o("emscripten_bind_PolygonInterface_empty_0"), Wt = t._emscripten_bind_PolygonInterface_size_0 = o("emscripten_bind_PolygonInterface_size_0"), kt = t._emscripten_bind_PolygonInterface_id_0 = o("emscripten_bind_PolygonInterface_id_0"), Yt = t._emscripten_bind_PolygonInterface_at_1 = o("emscripten_bind_PolygonInterface_at_1"), Gt = t._emscripten_bind_PolygonInterface_boundingRectPolygon_0 = o("emscripten_bind_PolygonInterface_boundingRectPolygon_0"), zt = t._emscripten_bind_PolygonInterface_offsetBoundingBox_1 = o("emscripten_bind_PolygonInterface_offsetBoundingBox_1"), Zt = t._emscripten_bind_PolygonInterface_offsetPolygon_1 = o("emscripten_bind_PolygonInterface_offsetPolygon_1"), Xt = t._emscripten_bind_PolygonInterface___destroy___0 = o("emscripten_bind_PolygonInterface___destroy___0"), Kt = t._emscripten_bind_Polygon_Polygon_0 = o("emscripten_bind_Polygon_Polygon_0"), Qt = t._emscripten_bind_Polygon_Polygon_1 = o("emscripten_bind_Polygon_Polygon_1"), $t = t._emscripten_bind_Polygon_setPoint_2 = o("emscripten_bind_Polygon_setPoint_2"), qt = t._emscripten_bind_Polygon_size_0 = o("emscripten_bind_Polygon_size_0"), en = t._emscripten_bind_Polygon_get_ps_1 = o("emscripten_bind_Polygon_get_ps_1"), tn = t._emscripten_bind_Polygon_set_ps_2 = o("emscripten_bind_Polygon_set_ps_2"), nn = t._emscripten_bind_Polygon___destroy___0 = o("emscripten_bind_Polygon___destroy___0"), on2 = t._emscripten_bind_Point_Point_0 = o("emscripten_bind_Point_Point_0"), _n = t._emscripten_bind_Point_Point_2 = o("emscripten_bind_Point_Point_2"), rn = t._emscripten_bind_Point_equal_1 = o("emscripten_bind_Point_equal_1"), pn = t._emscripten_bind_Point_get_x_0 = o("emscripten_bind_Point_get_x_0"), sn = t._emscripten_bind_Point_set_x_1 = o("emscripten_bind_Point_set_x_1"), cn = t._emscripten_bind_Point_get_y_0 = o("emscripten_bind_Point_get_y_0"), dn = t._emscripten_bind_Point_set_y_1 = o("emscripten_bind_Point_set_y_1"), an = t._emscripten_bind_Point_get_id_0 = o("emscripten_bind_Point_get_id_0"), mn = t._emscripten_bind_Point_set_id_1 = o("emscripten_bind_Point_set_id_1"), un = t._emscripten_bind_Point_get_vn_0 = o("emscripten_bind_Point_get_vn_0"), yn = t._emscripten_bind_Point_set_vn_1 = o("emscripten_bind_Point_set_vn_1"), gn = t._emscripten_bind_Point___destroy___0 = o("emscripten_bind_Point___destroy___0"), fn = t._emscripten_bind_Rectangle_Rectangle_2 = o("emscripten_bind_Rectangle_Rectangle_2"), bn = t._emscripten_bind_Rectangle_Rectangle_3 = o("emscripten_bind_Rectangle_Rectangle_3"), ln = t._emscripten_bind_Rectangle___destroy___0 = o("emscripten_bind_Rectangle___destroy___0"), hn = t._emscripten_bind_HyperedgeTreeNode_HyperedgeTreeNode_0 = o("emscripten_bind_HyperedgeTreeNode_HyperedgeTreeNode_0"), vn = t._emscripten_bind_HyperedgeTreeNode_writeEdgesToConns_2 = o("emscripten_bind_HyperedgeTreeNode_writeEdgesToConns_2"), Pn = t._emscripten_bind_HyperedgeTreeNode___destroy___0 = o("emscripten_bind_HyperedgeTreeNode___destroy___0"), Cn = t._emscripten_bind_HyperedgeTreeEdge_HyperedgeTreeEdge_3 = o("emscripten_bind_HyperedgeTreeEdge_HyperedgeTreeEdge_3"), Rn = t._emscripten_bind_HyperedgeTreeEdge___destroy___0 = o("emscripten_bind_HyperedgeTreeEdge___destroy___0"), An = t._emscripten_bind_AStarPath_AStarPath_0 = o("emscripten_bind_AStarPath_AStarPath_0"), Tn = t._emscripten_bind_AStarPath_search_4 = o("emscripten_bind_AStarPath_search_4"), Sn = t._emscripten_bind_AStarPath___destroy___0 = o("emscripten_bind_AStarPath___destroy___0"), In = t._emscripten_bind_ConnEnd_ConnEnd_1 = o("emscripten_bind_ConnEnd_ConnEnd_1"), En = t._emscripten_bind_ConnEnd_ConnEnd_2 = o("emscripten_bind_ConnEnd_ConnEnd_2"), On = t._emscripten_bind_ConnEnd_createConnEndFromJunctionRef_1 = o("emscripten_bind_ConnEnd_createConnEndFromJunctionRef_1"), Dn = t._emscripten_bind_ConnEnd___destroy___0 = o("emscripten_bind_ConnEnd___destroy___0"), wn = t._emscripten_bind_ActionInfo_ActionInfo_2 = o("emscripten_bind_ActionInfo_ActionInfo_2"), jn = t._emscripten_bind_ActionInfo_ActionInfo_3 = o("emscripten_bind_ActionInfo_ActionInfo_3"), Fn = t._emscripten_bind_ActionInfo_ActionInfo_4 = o("emscripten_bind_ActionInfo_ActionInfo_4"), Mn = t._emscripten_bind_ActionInfo_obstacle_0 = o("emscripten_bind_ActionInfo_obstacle_0"), xn = t._emscripten_bind_ActionInfo_shape_0 = o("emscripten_bind_ActionInfo_shape_0"), Ln = t._emscripten_bind_ActionInfo_conn_0 = o("emscripten_bind_ActionInfo_conn_0"), Hn = t._emscripten_bind_ActionInfo_junction_0 = o("emscripten_bind_ActionInfo_junction_0"), Nn = t._emscripten_bind_ActionInfo_addConnEndUpdate_3 = o("emscripten_bind_ActionInfo_addConnEndUpdate_3"), Un = t._emscripten_bind_ActionInfo_get_type_0 = o("emscripten_bind_ActionInfo_get_type_0"), Vn = t._emscripten_bind_ActionInfo_set_type_1 = o("emscripten_bind_ActionInfo_set_type_1"), Jn = t._emscripten_bind_ActionInfo_get_objPtr_0 = o("emscripten_bind_ActionInfo_get_objPtr_0"), Bn = t._emscripten_bind_ActionInfo_set_objPtr_1 = o("emscripten_bind_ActionInfo_set_objPtr_1"), Wn = t._emscripten_bind_ActionInfo_get_newPoly_0 = o("emscripten_bind_ActionInfo_get_newPoly_0"), kn = t._emscripten_bind_ActionInfo_set_newPoly_1 = o("emscripten_bind_ActionInfo_set_newPoly_1"), Yn = t._emscripten_bind_ActionInfo_get_newPosition_0 = o("emscripten_bind_ActionInfo_get_newPosition_0"), Gn = t._emscripten_bind_ActionInfo_set_newPosition_1 = o("emscripten_bind_ActionInfo_set_newPosition_1"), zn = t._emscripten_bind_ActionInfo_get_firstMove_0 = o("emscripten_bind_ActionInfo_get_firstMove_0"), Zn = t._emscripten_bind_ActionInfo_set_firstMove_1 = o("emscripten_bind_ActionInfo_set_firstMove_1"), Xn = t._emscripten_bind_ActionInfo___destroy___0 = o("emscripten_bind_ActionInfo___destroy___0"), Kn = t._emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_2 = o("emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_2"), Qn = t._emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_3 = o("emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_3"), $n = t._emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_6 = o("emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_6"), qn = t._emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_7 = o("emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_7"), eo = t._emscripten_bind_ShapeConnectionPin_setConnectionCost_1 = o("emscripten_bind_ShapeConnectionPin_setConnectionCost_1"), to = t._emscripten_bind_ShapeConnectionPin_position_0 = o("emscripten_bind_ShapeConnectionPin_position_0"), no = t._emscripten_bind_ShapeConnectionPin_position_1 = o("emscripten_bind_ShapeConnectionPin_position_1"), oo = t._emscripten_bind_ShapeConnectionPin_directions_0 = o("emscripten_bind_ShapeConnectionPin_directions_0"), _o = t._emscripten_bind_ShapeConnectionPin_setExclusive_1 = o("emscripten_bind_ShapeConnectionPin_setExclusive_1"), io = t._emscripten_bind_ShapeConnectionPin_isExclusive_0 = o("emscripten_bind_ShapeConnectionPin_isExclusive_0"), ro = t._emscripten_bind_ShapeConnectionPin_updatePosition_1 = o("emscripten_bind_ShapeConnectionPin_updatePosition_1"), po = t._emscripten_bind_ShapeConnectionPin___destroy___0 = o("emscripten_bind_ShapeConnectionPin___destroy___0"), so = t._emscripten_bind_Obstacle_id_0 = o("emscripten_bind_Obstacle_id_0"), co = t._emscripten_bind_Obstacle_polygon_0 = o("emscripten_bind_Obstacle_polygon_0"), ao = t._emscripten_bind_Obstacle_router_0 = o("emscripten_bind_Obstacle_router_0"), mo = t._emscripten_bind_Obstacle_position_0 = o("emscripten_bind_Obstacle_position_0"), uo = t._emscripten_bind_Obstacle_setNewPoly_1 = o("emscripten_bind_Obstacle_setNewPoly_1"), yo = t._emscripten_bind_Obstacle___destroy___0 = o("emscripten_bind_Obstacle___destroy___0"), go = t._emscripten_bind_JunctionRef_JunctionRef_2 = o("emscripten_bind_JunctionRef_JunctionRef_2"), fo = t._emscripten_bind_JunctionRef_JunctionRef_3 = o("emscripten_bind_JunctionRef_JunctionRef_3"), bo = t._emscripten_bind_JunctionRef_position_0 = o("emscripten_bind_JunctionRef_position_0"), lo = t._emscripten_bind_JunctionRef_setPositionFixed_1 = o("emscripten_bind_JunctionRef_setPositionFixed_1"), ho = t._emscripten_bind_JunctionRef_positionFixed_0 = o("emscripten_bind_JunctionRef_positionFixed_0"), vo = t._emscripten_bind_JunctionRef_recommendedPosition_0 = o("emscripten_bind_JunctionRef_recommendedPosition_0"), Po = t._emscripten_bind_JunctionRef___destroy___0 = o("emscripten_bind_JunctionRef___destroy___0"), Co = t._emscripten_bind_ShapeRef_ShapeRef_2 = o("emscripten_bind_ShapeRef_ShapeRef_2"), Ro = t._emscripten_bind_ShapeRef_ShapeRef_3 = o("emscripten_bind_ShapeRef_ShapeRef_3"), Ao = t._emscripten_bind_ShapeRef_polygon_0 = o("emscripten_bind_ShapeRef_polygon_0"), To = t._emscripten_bind_ShapeRef_position_0 = o("emscripten_bind_ShapeRef_position_0"), So = t._emscripten_bind_ShapeRef_setNewPoly_1 = o("emscripten_bind_ShapeRef_setNewPoly_1"), Io = t._emscripten_bind_ShapeRef___destroy___0 = o("emscripten_bind_ShapeRef___destroy___0"), Eo = t._emscripten_bind_HyperedgeNewAndDeletedObjectLists___destroy___0 = o("emscripten_bind_HyperedgeNewAndDeletedObjectLists___destroy___0"), Oo = t._emscripten_bind_HyperedgeRerouter_HyperedgeRerouter_0 = o("emscripten_bind_HyperedgeRerouter_HyperedgeRerouter_0"), Do = t._emscripten_bind_HyperedgeRerouter_registerHyperedgeForRerouting_1 = o("emscripten_bind_HyperedgeRerouter_registerHyperedgeForRerouting_1"), wo = t._emscripten_bind_HyperedgeRerouter___destroy___0 = o("emscripten_bind_HyperedgeRerouter___destroy___0"), jo = t._emscripten_bind_VertInf___destroy___0 = o("emscripten_bind_VertInf___destroy___0"), Fo = t._emscripten_bind_VertID_VertID_0 = o("emscripten_bind_VertID_VertID_0"), Mo = t._emscripten_bind_VertID_VertID_2 = o("emscripten_bind_VertID_VertID_2"), xo = t._emscripten_bind_VertID_VertID_3 = o("emscripten_bind_VertID_VertID_3"), Lo = t._emscripten_bind_VertID_get_objID_0 = o("emscripten_bind_VertID_get_objID_0"), Ho = t._emscripten_bind_VertID_set_objID_1 = o("emscripten_bind_VertID_set_objID_1"), No = t._emscripten_bind_VertID_get_vn_0 = o("emscripten_bind_VertID_get_vn_0"), Uo = t._emscripten_bind_VertID_set_vn_1 = o("emscripten_bind_VertID_set_vn_1"), Vo = t._emscripten_bind_VertID_get_props_0 = o("emscripten_bind_VertID_get_props_0"), Jo = t._emscripten_bind_VertID_set_props_1 = o("emscripten_bind_VertID_set_props_1"), Bo = t._emscripten_bind_VertID_get_src_0 = o("emscripten_bind_VertID_get_src_0"), Wo = t._emscripten_bind_VertID_get_tar_0 = o("emscripten_bind_VertID_get_tar_0"), ko = t._emscripten_bind_VertID_get_PROP_ConnPoint_0 = o("emscripten_bind_VertID_get_PROP_ConnPoint_0"), Yo = t._emscripten_bind_VertID_get_PROP_OrthShapeEdge_0 = o("emscripten_bind_VertID_get_PROP_OrthShapeEdge_0"), Go = t._emscripten_bind_VertID_get_PROP_ConnectionPin_0 = o("emscripten_bind_VertID_get_PROP_ConnectionPin_0"), zo = t._emscripten_bind_VertID_get_PROP_ConnCheckpoint_0 = o("emscripten_bind_VertID_get_PROP_ConnCheckpoint_0"), Zo = t._emscripten_bind_VertID_get_PROP_DummyPinHelper_0 = o("emscripten_bind_VertID_get_PROP_DummyPinHelper_0"), Xo = t._emscripten_bind_VertID___destroy___0 = o("emscripten_bind_VertID___destroy___0"), Ko = t._emscripten_bind_MinimumTerminalSpanningTree___destroy___0 = o("emscripten_bind_MinimumTerminalSpanningTree___destroy___0"), Qo = t._emscripten_bind_Checkpoint_Checkpoint_1 = o("emscripten_bind_Checkpoint_Checkpoint_1"), $o = t._emscripten_bind_Checkpoint___destroy___0 = o("emscripten_bind_Checkpoint___destroy___0"), qo = t._emscripten_bind_ConnRef_ConnRef_3 = o("emscripten_bind_ConnRef_ConnRef_3"), e_ = t._emscripten_bind_ConnRef_ConnRef_4 = o("emscripten_bind_ConnRef_ConnRef_4"), t_ = t._emscripten_bind_ConnRef_id_0 = o("emscripten_bind_ConnRef_id_0"), n_ = t._emscripten_bind_ConnRef_setCallback_2 = o("emscripten_bind_ConnRef_setCallback_2"), o_ = t._emscripten_bind_ConnRef_setSourceEndpoint_1 = o("emscripten_bind_ConnRef_setSourceEndpoint_1"), __ = t._emscripten_bind_ConnRef_setDestEndpoint_1 = o("emscripten_bind_ConnRef_setDestEndpoint_1"), i_ = t._emscripten_bind_ConnRef_routingType_0 = o("emscripten_bind_ConnRef_routingType_0"), r_ = t._emscripten_bind_ConnRef_setRoutingType_1 = o("emscripten_bind_ConnRef_setRoutingType_1"), p_ = t._emscripten_bind_ConnRef_displayRoute_0 = o("emscripten_bind_ConnRef_displayRoute_0"), s_ = t._emscripten_bind_ConnRef_setHateCrossings_1 = o("emscripten_bind_ConnRef_setHateCrossings_1"), c_ = t._emscripten_bind_ConnRef_doesHateCrossings_0 = o("emscripten_bind_ConnRef_doesHateCrossings_0"), d_ = t._emscripten_bind_ConnRef___destroy___0 = o("emscripten_bind_ConnRef___destroy___0"), a_ = t._emscripten_bind_EdgeInf_EdgeInf_2 = o("emscripten_bind_EdgeInf_EdgeInf_2"), m_ = t._emscripten_bind_EdgeInf_EdgeInf_3 = o("emscripten_bind_EdgeInf_EdgeInf_3"), u_ = t._emscripten_bind_EdgeInf___destroy___0 = o("emscripten_bind_EdgeInf___destroy___0"), y_ = t._emscripten_bind_LineRep_get_begin_0 = o("emscripten_bind_LineRep_get_begin_0"), g_ = t._emscripten_bind_LineRep_set_begin_1 = o("emscripten_bind_LineRep_set_begin_1"), f_ = t._emscripten_bind_LineRep_get_end_0 = o("emscripten_bind_LineRep_get_end_0"), b_ = t._emscripten_bind_LineRep_set_end_1 = o("emscripten_bind_LineRep_set_end_1"), l_ = t._emscripten_bind_LineRep___destroy___0 = o("emscripten_bind_LineRep___destroy___0"), h_ = t._emscripten_bind_Router_Router_1 = o("emscripten_bind_Router_Router_1"), v_ = t._emscripten_bind_Router_processTransaction_0 = o("emscripten_bind_Router_processTransaction_0"), P_ = t._emscripten_bind_Router_printInfo_0 = o("emscripten_bind_Router_printInfo_0"), C_ = t._emscripten_bind_Router_deleteConnector_1 = o("emscripten_bind_Router_deleteConnector_1"), R_ = t._emscripten_bind_Router_moveShape_2 = o("emscripten_bind_Router_moveShape_2"), A_ = t._emscripten_bind_Router_moveShape_3 = o("emscripten_bind_Router_moveShape_3"), T_ = t._emscripten_bind_Router_deleteShape_1 = o("emscripten_bind_Router_deleteShape_1"), S_ = t._emscripten_bind_Router_moveJunction_2 = o("emscripten_bind_Router_moveJunction_2"), I_ = t._emscripten_bind_Router_moveJunction_3 = o("emscripten_bind_Router_moveJunction_3"), E_ = t._emscripten_bind_Router_setRoutingParameter_2 = o("emscripten_bind_Router_setRoutingParameter_2"), O_ = t._emscripten_bind_Router_setRoutingOption_2 = o("emscripten_bind_Router_setRoutingOption_2"), D_ = t._emscripten_bind_Router___destroy___0 = o("emscripten_bind_Router___destroy___0"), w_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirNone = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirNone"), j_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirUp = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirUp"), F_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirDown = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirDown"), M_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirLeft = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirLeft"), x_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirRight = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirRight"), L_ = t._emscripten_enum_Avoid_ConnDirFlag_ConnDirAll = o("emscripten_enum_Avoid_ConnDirFlag_ConnDirAll"), H_ = t._emscripten_enum_Avoid_ConnEndType_ConnEndPoint = o("emscripten_enum_Avoid_ConnEndType_ConnEndPoint"), N_ = t._emscripten_enum_Avoid_ConnEndType_ConnEndShapePin = o("emscripten_enum_Avoid_ConnEndType_ConnEndShapePin"), U_ = t._emscripten_enum_Avoid_ConnEndType_ConnEndJunction = o("emscripten_enum_Avoid_ConnEndType_ConnEndJunction"), V_ = t._emscripten_enum_Avoid_ConnEndType_ConnEndEmpty = o("emscripten_enum_Avoid_ConnEndType_ConnEndEmpty"), J_ = t._emscripten_enum_Avoid_ActionType_ShapeMove = o("emscripten_enum_Avoid_ActionType_ShapeMove"), B_ = t._emscripten_enum_Avoid_ActionType_ShapeAdd = o("emscripten_enum_Avoid_ActionType_ShapeAdd"), W_ = t._emscripten_enum_Avoid_ActionType_ShapeRemove = o("emscripten_enum_Avoid_ActionType_ShapeRemove"), k_ = t._emscripten_enum_Avoid_ActionType_JunctionMove = o("emscripten_enum_Avoid_ActionType_JunctionMove"), Y_ = t._emscripten_enum_Avoid_ActionType_JunctionAdd = o("emscripten_enum_Avoid_ActionType_JunctionAdd"), G_ = t._emscripten_enum_Avoid_ActionType_JunctionRemove = o("emscripten_enum_Avoid_ActionType_JunctionRemove"), z_ = t._emscripten_enum_Avoid_ActionType_ConnChange = o("emscripten_enum_Avoid_ActionType_ConnChange"), Z_ = t._emscripten_enum_Avoid_ActionType_ConnectionPinChange = o("emscripten_enum_Avoid_ActionType_ConnectionPinChange"), X_ = t._emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW90 = o("emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW90"), K_ = t._emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW180 = o("emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW180"), Q_ = t._emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW270 = o("emscripten_enum_Avoid_ShapeTransformationType_TransformationType_CW270"), $_ = t._emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipX = o("emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipX"), q_ = t._emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipY = o("emscripten_enum_Avoid_ShapeTransformationType_TransformationType_FlipY"), ei = t._emscripten_enum_Avoid_ConnType_ConnType_None = o("emscripten_enum_Avoid_ConnType_ConnType_None"), ti = t._emscripten_enum_Avoid_ConnType_ConnType_PolyLine = o("emscripten_enum_Avoid_ConnType_ConnType_PolyLine"), ni = t._emscripten_enum_Avoid_ConnType_ConnType_Orthogonal = o("emscripten_enum_Avoid_ConnType_ConnType_Orthogonal"), oi = t._emscripten_enum_Avoid_RouterFlag_PolyLineRouting = o("emscripten_enum_Avoid_RouterFlag_PolyLineRouting"), _i = t._emscripten_enum_Avoid_RouterFlag_OrthogonalRouting = o("emscripten_enum_Avoid_RouterFlag_OrthogonalRouting"), ii = t._emscripten_enum_Avoid_RoutingParameter_segmentPenalty = o("emscripten_enum_Avoid_RoutingParameter_segmentPenalty"), ri = t._emscripten_enum_Avoid_RoutingParameter_anglePenalty = o("emscripten_enum_Avoid_RoutingParameter_anglePenalty"), pi = t._emscripten_enum_Avoid_RoutingParameter_crossingPenalty = o("emscripten_enum_Avoid_RoutingParameter_crossingPenalty"), si = t._emscripten_enum_Avoid_RoutingParameter_clusterCrossingPenalty = o("emscripten_enum_Avoid_RoutingParameter_clusterCrossingPenalty"), ci = t._emscripten_enum_Avoid_RoutingParameter_fixedSharedPathPenalty = o("emscripten_enum_Avoid_RoutingParameter_fixedSharedPathPenalty"), di = t._emscripten_enum_Avoid_RoutingParameter_portDirectionPenalty = o("emscripten_enum_Avoid_RoutingParameter_portDirectionPenalty"), ai = t._emscripten_enum_Avoid_RoutingParameter_shapeBufferDistance = o("emscripten_enum_Avoid_RoutingParameter_shapeBufferDistance"), mi = t._emscripten_enum_Avoid_RoutingParameter_idealNudgingDistance = o("emscripten_enum_Avoid_RoutingParameter_idealNudgingDistance"), ui = t._emscripten_enum_Avoid_RoutingParameter_reverseDirectionPenalty = o("emscripten_enum_Avoid_RoutingParameter_reverseDirectionPenalty"), yi = t._emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalSegmentsConnectedToShapes = o("emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalSegmentsConnectedToShapes"), gi = t._emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingJunctions = o("emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingJunctions"), fi = t._emscripten_enum_Avoid_RoutingOption_penaliseOrthogonalSharedPathsAtConnEnds = o("emscripten_enum_Avoid_RoutingOption_penaliseOrthogonalSharedPathsAtConnEnds"), bi = t._emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalTouchingColinearSegments = o("emscripten_enum_Avoid_RoutingOption_nudgeOrthogonalTouchingColinearSegments"), li = t._emscripten_enum_Avoid_RoutingOption_performUnifyingNudgingPreprocessingStep = o("emscripten_enum_Avoid_RoutingOption_performUnifyingNudgingPreprocessingStep"), hi = t._emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingAddingAndDeletingJunctions = o("emscripten_enum_Avoid_RoutingOption_improveHyperedgeRoutesMovingAddingAndDeletingJunctions"), vi = t._emscripten_enum_Avoid_RoutingOption_nudgeSharedPathsWithCommonEndPoint = o("emscripten_enum_Avoid_RoutingOption_nudgeSharedPathsWithCommonEndPoint");
    function rt() {
      return (rt = t.asm.__trap).apply(null, arguments);
    }
    function pt() {
      return (pt = t.asm.emscripten_stack_init).apply(null, arguments);
    }
    function we() {
      return (we = t.asm.emscripten_stack_get_end).apply(null, arguments);
    }
    var Pi = o("stackSave"), Ci = o("stackRestore"), st = o("stackAlloc");
    t.___cxa_decrement_exception_refcount = o("__cxa_decrement_exception_refcount"), t.___cxa_increment_exception_refcount = o("__cxa_increment_exception_refcount");
    var Ri = t.___thrown_object_from_unwind_exception = o("__thrown_object_from_unwind_exception"), Ai = t.___get_exception_message = o("__get_exception_message");
    t.dynCall_jiji = o("dynCall_jiji"), t.dynCall_viijii = o("dynCall_viijii"), t.dynCall_iiiiij = o("dynCall_iiiiij"), t.dynCall_iiiiijj = o("dynCall_iiiiijj"), t.dynCall_iiiiiijj = o("dynCall_iiiiiijj"), t.___start_em_js = 44484, t.___stop_em_js = 44582, "zeroMemory exitJS ydayFromDate setErrNo inetPton4 inetNtop4 inetPton6 inetNtop6 readSockaddr writeSockaddr getHostByName initRandomFill randomFill traverseStack getCallstack emscriptenLog convertPCtoSourceLocation readEmAsmArgs jstoi_q jstoi_s listenOnce autoResumeAudioContext dynCallLegacy getDynCaller dynCall handleException runtimeKeepalivePush runtimeKeepalivePop callUserCallback maybeExit safeSetTimeout asmjsMangle asyncLoad alignMemory mmapAlloc HandleAllocator getNativeTypeSize STACK_SIZE STACK_ALIGN POINTER_SIZE ASSERTIONS writeI53ToI64 writeI53ToI64Clamped writeI53ToI64Signaling writeI53ToU64Clamped writeI53ToU64Signaling readI53FromI64 readI53FromU64 convertI32PairToI53 convertU32PairToI53 getCFunc ccall cwrap removeFunction reallyNegative unSign strLen reSign formatString stringToUTF8 intArrayToString AsciiToString UTF16ToString stringToUTF16 lengthBytesUTF16 UTF32ToString stringToUTF32 lengthBytesUTF32 stringToNewUTF8 stringToUTF8OnStack getSocketFromFD getSocketAddress registerKeyEventCallback maybeCStringToJsString findEventTarget findCanvasEventTarget getBoundingClientRect fillMouseEventData registerMouseEventCallback registerWheelEventCallback registerUiEventCallback registerFocusEventCallback fillDeviceOrientationEventData registerDeviceOrientationEventCallback fillDeviceMotionEventData registerDeviceMotionEventCallback screenOrientation fillOrientationChangeEventData registerOrientationChangeEventCallback fillFullscreenChangeEventData registerFullscreenChangeEventCallback JSEvents_requestFullscreen JSEvents_resizeCanvasForFullscreen registerRestoreOldStyle hideEverythingExceptGivenElement restoreHiddenElements setLetterbox softFullscreenResizeWebGLRenderTarget doRequestFullscreen fillPointerlockChangeEventData registerPointerlockChangeEventCallback registerPointerlockErrorEventCallback requestPointerLock fillVisibilityChangeEventData registerVisibilityChangeEventCallback registerTouchEventCallback fillGamepadEventData registerGamepadEventCallback registerBeforeUnloadEventCallback fillBatteryEventData battery registerBatteryEventCallback setCanvasElementSize getCanvasElementSize demangle demangleAll jsStackTrace stackTrace checkWasiClock wasiRightsToMuslOFlags wasiOFlagsToMuslOFlags createDyncallWrapper setImmediateWrapped clearImmediateWrapped polyfillSetImmediate getPromise makePromise idsToPromises makePromiseCallback setMainLoop heapObjectForWebGLType heapAccessShiftForWebGLHeap webgl_enable_ANGLE_instanced_arrays webgl_enable_OES_vertex_array_object webgl_enable_WEBGL_draw_buffers webgl_enable_WEBGL_multi_draw emscriptenWebGLGet computeUnpackAlignedImageSize colorChannelsInGlTextureFormat emscriptenWebGLGetTexPixelData __glGenObject emscriptenWebGLGetUniform webglGetUniformLocation webglPrepareUniformLocationsBeforeFirstUse webglGetLeftBracePos emscriptenWebGLGetVertexAttrib __glGetActiveAttribOrUniform writeGLArray registerWebGlEventCallback runAndAbortIfError SDL_unicode SDL_ttfContext SDL_audio GLFW_Window ALLOC_NORMAL ALLOC_STACK allocate writeStringToMemory writeAsciiToMemory".split(" ").forEach(function(e) {
      typeof globalThis > "u" || Object.getOwnPropertyDescriptor(globalThis, e) || Object.defineProperty(globalThis, e, {
        configurable: true,
        get: function() {
          var n = "`" + e + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line", _ = e;
          _.startsWith("_") || (_ = "$" + e), n += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + _ + ")", Ze(e) && (n += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), Pe(n);
        }
      }), Xe(e);
    }), "run addOnPreRun addOnInit addOnPreMain addOnExit addOnPostRun addRunDependency removeRunDependency FS_createFolder FS_createPath FS_createDataFile FS_createPreloadedFile FS_createLazyFile FS_createLink FS_createDevice FS_unlink out err callMain abort keepRuntimeAlive wasmMemory stackAlloc stackSave stackRestore getTempRet0 setTempRet0 writeStackCookie checkStackCookie ptrToString getHeapMax emscripten_realloc_buffer ENV MONTH_DAYS_REGULAR MONTH_DAYS_LEAP MONTH_DAYS_REGULAR_CUMULATIVE MONTH_DAYS_LEAP_CUMULATIVE isLeapYear arraySum addDays ERRNO_CODES ERRNO_MESSAGES DNS Protocols Sockets timers warnOnce UNWIND_CACHE readEmAsmArgsArray getExecutableName convertI32PairToI53Checked uleb128Encode sigToWasmTypes generateFuncType convertJsFunctionToWasm freeTableIndexes functionsInTableMap getEmptyTableSlot updateTableMap getFunctionAddress addFunction setValue getValue PATH PATH_FS UTF8Decoder UTF8ArrayToString UTF8ToString stringToUTF8Array lengthBytesUTF8 intArrayFromString stringToAscii UTF16Decoder writeArrayToMemory SYSCALLS JSEvents specialHTMLTargets currentFullscreenStrategy restoreOldWindowedStyle ExitStatus getEnvStrings flush_NO_FILESYSTEM dlopenMissingError promiseMap getExceptionMessageCommon getCppExceptionTag getCppExceptionThrownObjectFromWebAssemblyException incrementExceptionRefcount decrementExceptionRefcount getExceptionMessage Browser wget tempFixedLengthArray miniTempWebGLFloatBuffers miniTempWebGLIntBuffers GL emscripten_webgl_power_preferences AL GLUT EGL GLEW IDBStore SDL SDL_gfx GLFW allocateUTF8 allocateUTF8OnStack".split(" ").forEach(Xe);
    var Ae;
    ge = function e() {
      Ae || ct(), Ae || (ge = e);
    };
    function ct() {
      function e() {
        if (!Ae && (Ae = true, t.calledRun = true, !pe)) {
          if (m(!ye), ye = true, Te(), Ee(Se), de(t), t.onRuntimeInitialized && t.onRuntimeInitialized(), m(!t._main, 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'), Te(), t.postRun)
            for (typeof t.postRun == "function" && (t.postRun = [t.postRun]); t.postRun.length; ) {
              var n = t.postRun.shift();
              Je.unshift(n);
            }
          Ee(Je);
        }
      }
      if (!(0 < ee)) {
        if (pt(), gt(), t.preRun)
          for (typeof t.preRun == "function" && (t.preRun = [t.preRun]); t.preRun.length; )
            ft();
        Ee(Ve), 0 < ee || (t.setStatus ? (t.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            t.setStatus("");
          }, 1), e();
        }, 1)) : e(), Te());
      }
    }
    if (t.preInit)
      for (typeof t.preInit == "function" && (t.preInit = [t.preInit]); 0 < t.preInit.length; )
        t.preInit.pop()();
    ct();
    function y() {
    }
    y.prototype = Object.create(y.prototype), y.prototype.constructor = y, y.prototype.h = y, y.l = {}, t.WrapperObject = y;
    function h2(e) {
      return (e || y).l;
    }
    t.getCache = h2;
    function g(e, n) {
      var _ = h2(n), i = _[e];
      return i || (i = Object.create((n || y).prototype), i.g = e, _[e] = i);
    }
    t.wrapPointer = g, t.castObject = function(e, n) {
      return g(e.g, n);
    }, t.NULL = g(0), t.destroy = function(e) {
      if (!e.__destroy__)
        throw "Error: Cannot destroy object. (Did you create it yourself?)";
      e.__destroy__(), delete h2(e.h)[e.g];
    }, t.compare = function(e, n) {
      return e.g === n.g;
    }, t.getPointer = function(e) {
      return e.g;
    }, t.getClass = function(e) {
      return e.h;
    };
    var le = 0, je = 0;
    function Y() {
      throw "cannot construct a VoidPtr, no constructor in IDL";
    }
    Y.prototype = Object.create(y.prototype), Y.prototype.constructor = Y, Y.prototype.h = Y, Y.l = {}, t.VoidPtr = Y, Y.prototype.__destroy__ = function() {
      It(this.g);
    };
    function L() {
      this.g = Et(), h2(L)[this.g] = this;
    }
    L.prototype = Object.create(y.prototype), L.prototype.constructor = L, L.prototype.h = L, L.l = {}, t.HyperedgeImprover = L, L.prototype.clear = L.prototype.clear = function() {
      Ot(this.g);
    }, L.prototype.setRouter = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Dt(n, e);
    }, L.prototype.__destroy__ = function() {
      wt(this.g);
    };
    function f() {
      this.g = jt(), h2(f)[this.g] = this;
    }
    f.prototype = Object.create(y.prototype), f.prototype.constructor = f, f.prototype.h = f, f.l = {}, t.Box = f, f.prototype.length = f.prototype.length = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), Ft(n, e);
    }, f.prototype.width = f.prototype.width = function() {
      return Mt(this.g);
    }, f.prototype.height = f.prototype.height = function() {
      return xt(this.g);
    }, f.prototype.get_min = f.prototype.P = function() {
      return g(Lt(this.g), d);
    }, f.prototype.set_min = f.prototype.ga = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Ht(n, e);
    }, Object.defineProperty(f.prototype, "min", {
      get: f.prototype.P,
      set: f.prototype.ga
    }), f.prototype.get_max = f.prototype.O = function() {
      return g(Nt(this.g), d);
    }, f.prototype.set_max = f.prototype.fa = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Ut(n, e);
    }, Object.defineProperty(f.prototype, "max", {
      get: f.prototype.O,
      set: f.prototype.fa
    }), f.prototype.__destroy__ = function() {
      Vt(this.g);
    };
    function C() {
      throw "cannot construct a PolygonInterface, no constructor in IDL";
    }
    C.prototype = Object.create(y.prototype), C.prototype.constructor = C, C.prototype.h = C, C.l = {}, t.PolygonInterface = C, C.prototype.clear = C.prototype.clear = function() {
      Jt(this.g);
    }, C.prototype.empty = C.prototype.empty = function() {
      return !!Bt(this.g);
    }, C.prototype.size = C.prototype.size = function() {
      return Wt(this.g);
    }, C.prototype.id = C.prototype.id = function() {
      return kt(this.g);
    }, C.prototype.at = C.prototype.at = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(Yt(n, e), d);
    }, C.prototype.boundingRectPolygon = function() {
      return g(Gt(this.g), l);
    }, C.prototype.offsetBoundingBox = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(zt(n, e), f);
    }, C.prototype.offsetPolygon = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(Zt(n, e), l);
    }, C.prototype.__destroy__ = function() {
      Xt(this.g);
    };
    function l(e) {
      e && typeof e == "object" && (e = e.g), this.g = e === void 0 ? Kt() : Qt(e), h2(l)[this.g] = this;
    }
    l.prototype = Object.create(y.prototype), l.prototype.constructor = l, l.prototype.h = l, l.l = {}, t.Polygon = l, l.prototype.setPoint = function(e, n) {
      var _ = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), $t(_, e, n);
    }, l.prototype.size = l.prototype.size = function() {
      return qt(this.g);
    }, l.prototype.get_ps = l.prototype.W = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(en(n, e), d);
    }, l.prototype.set_ps = l.prototype.ma = function(e, n) {
      var _ = this.g;
      le || (je += 128, le = t._malloc(je), m(le)), e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), tn(_, e, n);
    }, Object.defineProperty(l.prototype, "ps", {
      get: l.prototype.W,
      set: l.prototype.ma
    }), l.prototype.__destroy__ = function() {
      nn(this.g);
    };
    function d(e, n) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), this.g = e === void 0 ? on2() : n === void 0 ? _emscripten_bind_Point_Point_1(e) : _n(e, n), h2(d)[this.g] = this;
    }
    d.prototype = Object.create(y.prototype), d.prototype.constructor = d, d.prototype.h = d, d.l = {}, t.Point = d, d.prototype.equal = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), !!rn(n, e);
    }, d.prototype.get_x = d.prototype.$ = function() {
      return pn(this.g);
    }, d.prototype.set_x = d.prototype.oa = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), sn(n, e);
    }, Object.defineProperty(d.prototype, "x", {
      get: d.prototype.$,
      set: d.prototype.oa
    }), d.prototype.get_y = d.prototype.aa = function() {
      return cn(this.g);
    }, d.prototype.set_y = d.prototype.pa = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), dn(n, e);
    }, Object.defineProperty(d.prototype, "y", {
      get: d.prototype.aa,
      set: d.prototype.pa
    }), d.prototype.get_id = d.prototype.N = function() {
      return an(this.g);
    }, d.prototype.set_id = d.prototype.ea = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), mn(n, e);
    }, Object.defineProperty(d.prototype, "id", {
      get: d.prototype.N,
      set: d.prototype.ea
    }), d.prototype.get_vn = d.prototype.A = function() {
      return un(this.g);
    }, d.prototype.set_vn = d.prototype.B = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), yn(n, e);
    }, Object.defineProperty(d.prototype, "vn", {
      get: d.prototype.A,
      set: d.prototype.B
    }), d.prototype.__destroy__ = function() {
      gn(this.g);
    };
    function G(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = _ === void 0 ? fn(e, n) : bn(e, n, _), h2(G)[this.g] = this;
    }
    G.prototype = Object.create(y.prototype), G.prototype.constructor = G, G.prototype.h = G, G.l = {}, t.Rectangle = G, G.prototype.__destroy__ = function() {
      ln(this.g);
    };
    function J() {
      this.g = hn(), h2(J)[this.g] = this;
    }
    J.prototype = Object.create(y.prototype), J.prototype.constructor = J, J.prototype.h = J, J.l = {}, t.HyperedgeTreeNode = J, J.prototype.writeEdgesToConns = function(e, n) {
      var _ = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), vn(_, e, n);
    }, J.prototype.__destroy__ = function() {
      Pn(this.g);
    };
    function z(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = Cn(e, n, _), h2(z)[this.g] = this;
    }
    z.prototype = Object.create(y.prototype), z.prototype.constructor = z, z.prototype.h = z, z.l = {}, t.HyperedgeTreeEdge = z, z.prototype.__destroy__ = function() {
      Rn(this.g);
    };
    function N() {
      this.g = An(), h2(N)[this.g] = this;
    }
    N.prototype = Object.create(y.prototype), N.prototype.constructor = N, N.prototype.h = N, N.l = {}, t.AStarPath = N, N.prototype.search = N.prototype.search = function(e, n, _, i) {
      var p2 = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), i && typeof i == "object" && (i = i.g), Tn(p2, e, n, _, i);
    }, N.prototype.__destroy__ = function() {
      Sn(this.g);
    };
    function U(e, n) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), this.g = n === void 0 ? In(e) : En(e, n), h2(U)[this.g] = this;
    }
    U.prototype = Object.create(y.prototype), U.prototype.constructor = U, U.prototype.h = U, U.l = {}, t.ConnEnd = U, U.prototype.createConnEndFromJunctionRef = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(On(n, e), U);
    }, U.prototype.__destroy__ = function() {
      Dn(this.g);
    };
    function a(e, n, _, i) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), i && typeof i == "object" && (i = i.g), this.g = _ === void 0 ? wn(e, n) : i === void 0 ? jn(e, n, _) : Fn(e, n, _, i), h2(a)[this.g] = this;
    }
    a.prototype = Object.create(y.prototype), a.prototype.constructor = a, a.prototype.h = a, a.l = {}, t.ActionInfo = a, a.prototype.obstacle = function() {
      return g(Mn(this.g), I);
    }, a.prototype.shape = a.prototype.shape = function() {
      return g(xn(this.g), j);
    }, a.prototype.conn = function() {
      return g(Ln(this.g), R);
    }, a.prototype.junction = function() {
      return g(Hn(this.g), O);
    }, a.prototype.addConnEndUpdate = function(e, n, _) {
      var i = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), Nn(i, e, n, _);
    }, a.prototype.get_type = a.prototype.Z = function() {
      return Un(this.g);
    }, a.prototype.set_type = a.prototype.na = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Vn(n, e);
    }, Object.defineProperty(a.prototype, "type", {
      get: a.prototype.Z,
      set: a.prototype.na
    }), a.prototype.get_objPtr = a.prototype.U = function() {
      return g(Jn(this.g), Y);
    }, a.prototype.set_objPtr = a.prototype.ka = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Bn(n, e);
    }, Object.defineProperty(a.prototype, "objPtr", {
      get: a.prototype.U,
      set: a.prototype.ka
    }), a.prototype.get_newPoly = a.prototype.R = function() {
      return g(Wn(this.g), l);
    }, a.prototype.set_newPoly = a.prototype.ha = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), kn(n, e);
    }, Object.defineProperty(a.prototype, "newPoly", {
      get: a.prototype.R,
      set: a.prototype.ha
    }), a.prototype.get_newPosition = a.prototype.S = function() {
      return g(Yn(this.g), d);
    }, a.prototype.set_newPosition = a.prototype.ia = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Gn(n, e);
    }, Object.defineProperty(a.prototype, "newPosition", {
      get: a.prototype.S,
      set: a.prototype.ia
    }), a.prototype.get_firstMove = a.prototype.M = function() {
      return !!zn(this.g);
    }, a.prototype.set_firstMove = a.prototype.da = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Zn(n, e);
    }, Object.defineProperty(a.prototype, "firstMove", {
      get: a.prototype.M,
      set: a.prototype.da
    }), a.prototype.__destroy__ = function() {
      Xn(this.g);
    };
    function S(e, n, _, i, p2, s, u) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), i && typeof i == "object" && (i = i.g), p2 && typeof p2 == "object" && (p2 = p2.g), s && typeof s == "object" && (s = s.g), u && typeof u == "object" && (u = u.g), this.g = _ === void 0 ? Kn(e, n) : i === void 0 ? Qn(e, n, _) : p2 === void 0 ? _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_4(e, n, _, i) : s === void 0 ? _emscripten_bind_ShapeConnectionPin_ShapeConnectionPin_5(e, n, _, i, p2) : u === void 0 ? $n(e, n, _, i, p2, s) : qn(e, n, _, i, p2, s, u), h2(S)[this.g] = this;
    }
    S.prototype = Object.create(y.prototype), S.prototype.constructor = S, S.prototype.h = S, S.l = {}, t.ShapeConnectionPin = S, S.prototype.setConnectionCost = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), eo(n, e);
    }, S.prototype.position = S.prototype.position = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), g(e === void 0 ? to(n) : no(n, e), d);
    }, S.prototype.directions = function() {
      return oo(this.g);
    }, S.prototype.setExclusive = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), _o(n, e);
    }, S.prototype.isExclusive = function() {
      return !!io(this.g);
    }, S.prototype.updatePosition = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), ro(n, e);
    }, S.prototype.__destroy__ = function() {
      po(this.g);
    };
    function I() {
      throw "cannot construct a Obstacle, no constructor in IDL";
    }
    I.prototype = Object.create(y.prototype), I.prototype.constructor = I, I.prototype.h = I, I.l = {}, t.Obstacle = I, I.prototype.id = I.prototype.id = function() {
      return so(this.g);
    }, I.prototype.polygon = function() {
      return g(co(this.g), l);
    }, I.prototype.router = function() {
      return g(ao(this.g), A);
    }, I.prototype.position = I.prototype.position = function() {
      return g(mo(this.g), d);
    }, I.prototype.setNewPoly = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), uo(n, e);
    }, I.prototype.__destroy__ = function() {
      yo(this.g);
    };
    function O(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = _ === void 0 ? go(e, n) : fo(e, n, _), h2(O)[this.g] = this;
    }
    O.prototype = Object.create(y.prototype), O.prototype.constructor = O, O.prototype.h = O, O.l = {}, t.JunctionRef = O, O.prototype.position = O.prototype.position = function() {
      return g(bo(this.g), d);
    }, O.prototype.setPositionFixed = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), lo(n, e);
    }, O.prototype.positionFixed = function() {
      return !!ho(this.g);
    }, O.prototype.recommendedPosition = function() {
      return g(vo(this.g), d);
    }, O.prototype.__destroy__ = function() {
      Po(this.g);
    };
    function j(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = _ === void 0 ? Co(e, n) : Ro(e, n, _), h2(j)[this.g] = this;
    }
    j.prototype = Object.create(y.prototype), j.prototype.constructor = j, j.prototype.h = j, j.l = {}, t.ShapeRef = j, j.prototype.polygon = function() {
      return g(Ao(this.g), l);
    }, j.prototype.position = j.prototype.position = function() {
      return g(To(this.g), d);
    }, j.prototype.setNewPoly = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), So(n, e);
    }, j.prototype.__destroy__ = function() {
      Io(this.g);
    };
    function Q() {
      throw "cannot construct a HyperedgeNewAndDeletedObjectLists, no constructor in IDL";
    }
    Q.prototype = Object.create(y.prototype), Q.prototype.constructor = Q, Q.prototype.h = Q, Q.l = {}, t.HyperedgeNewAndDeletedObjectLists = Q, Q.prototype.__destroy__ = function() {
      Eo(this.g);
    };
    function B() {
      this.g = Oo(), h2(B)[this.g] = this;
    }
    B.prototype = Object.create(y.prototype), B.prototype.constructor = B, B.prototype.h = B, B.l = {}, t.HyperedgeRerouter = B, B.prototype.registerHyperedgeForRerouting = function(e) {
      var n = this.g;
      return e && typeof e == "object" && (e = e.g), Do(n, e);
    }, B.prototype.__destroy__ = function() {
      wo(this.g);
    };
    function $() {
      throw "cannot construct a VertInf, no constructor in IDL";
    }
    $.prototype = Object.create(y.prototype), $.prototype.constructor = $, $.prototype.h = $, $.l = {}, t.VertInf = $, $.prototype.__destroy__ = function() {
      jo(this.g);
    };
    function c(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = e === void 0 ? Fo() : n === void 0 ? _emscripten_bind_VertID_VertID_1(e) : _ === void 0 ? Mo(e, n) : xo(e, n, _), h2(c)[this.g] = this;
    }
    c.prototype = Object.create(y.prototype), c.prototype.constructor = c, c.prototype.h = c, c.l = {}, t.VertID = c, c.prototype.get_objID = c.prototype.T = function() {
      return Lo(this.g);
    }, c.prototype.set_objID = c.prototype.ja = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Ho(n, e);
    }, Object.defineProperty(c.prototype, "objID", {
      get: c.prototype.T,
      set: c.prototype.ja
    }), c.prototype.get_vn = c.prototype.A = function() {
      return No(this.g);
    }, c.prototype.set_vn = c.prototype.B = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Uo(n, e);
    }, Object.defineProperty(c.prototype, "vn", {
      get: c.prototype.A,
      set: c.prototype.B
    }), c.prototype.get_props = c.prototype.V = function() {
      return Vo(this.g);
    }, c.prototype.set_props = c.prototype.la = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), Jo(n, e);
    }, Object.defineProperty(c.prototype, "props", {
      get: c.prototype.V,
      set: c.prototype.la
    }), c.prototype.get_src = c.prototype.X = function() {
      return Bo(this.g);
    }, Object.defineProperty(c.prototype, "src", {
      get: c.prototype.X
    }), c.prototype.get_tar = c.prototype.Y = function() {
      return Wo(this.g);
    }, Object.defineProperty(c.prototype, "tar", {
      get: c.prototype.Y
    }), c.prototype.get_PROP_ConnPoint = c.prototype.G = function() {
      return ko(this.g);
    }, Object.defineProperty(c.prototype, "PROP_ConnPoint", {
      get: c.prototype.G
    }), c.prototype.get_PROP_OrthShapeEdge = c.prototype.J = function() {
      return Yo(this.g);
    }, Object.defineProperty(c.prototype, "PROP_OrthShapeEdge", {
      get: c.prototype.J
    }), c.prototype.get_PROP_ConnectionPin = c.prototype.H = function() {
      return Go(this.g);
    }, Object.defineProperty(c.prototype, "PROP_ConnectionPin", {
      get: c.prototype.H
    }), c.prototype.get_PROP_ConnCheckpoint = c.prototype.F = function() {
      return zo(this.g);
    }, Object.defineProperty(c.prototype, "PROP_ConnCheckpoint", {
      get: c.prototype.F
    }), c.prototype.get_PROP_DummyPinHelper = c.prototype.I = function() {
      return Zo(this.g);
    }, Object.defineProperty(c.prototype, "PROP_DummyPinHelper", {
      get: c.prototype.I
    }), c.prototype.__destroy__ = function() {
      Xo(this.g);
    };
    function q() {
      throw "cannot construct a MinimumTerminalSpanningTree, no constructor in IDL";
    }
    q.prototype = Object.create(y.prototype), q.prototype.constructor = q, q.prototype.h = q, q.l = {}, t.MinimumTerminalSpanningTree = q, q.prototype.__destroy__ = function() {
      Ko(this.g);
    };
    function Z(e) {
      e && typeof e == "object" && (e = e.g), this.g = Qo(e), h2(Z)[this.g] = this;
    }
    Z.prototype = Object.create(y.prototype), Z.prototype.constructor = Z, Z.prototype.h = Z, Z.l = {}, t.Checkpoint = Z, Z.prototype.__destroy__ = function() {
      $o(this.g);
    };
    function R(e, n, _, i) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), i && typeof i == "object" && (i = i.g), this.g = i === void 0 ? qo(e, n, _) : e_(e, n, _, i), h2(R)[this.g] = this;
    }
    R.prototype = Object.create(y.prototype), R.prototype.constructor = R, R.prototype.h = R, R.l = {}, t.ConnRef = R, R.prototype.id = R.prototype.id = function() {
      return t_(this.g);
    }, R.prototype.setCallback = function(e, n) {
      var _ = this.g;
      if (m(e instanceof Function, "Expecting function"), m(typeof e < "u"), !ce) {
        ce = /* @__PURE__ */ new WeakMap();
        var i = w.length;
        if (ce)
          for (var p2 = 0; p2 < 0 + i; p2++) {
            var s = p2, u = se[s];
            u || (s >= se.length && (se.length = s + 1), se[s] = u = w.get(s)), m(w.get(s) == u, "JavaScript-side Wasm function table mirror is out of date!"), (s = u) && ce.set(s, p2);
          }
      }
      if (i = ce.get(e) || 0)
        e = i;
      else {
        if (Qe.length)
          i = Qe.pop();
        else {
          try {
            w.grow(1);
          } catch (H) {
            throw H instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : H;
          }
          i = w.length - 1;
        }
        try {
          p2 = i, w.set(p2, e), se[p2] = w.get(p2);
        } catch (H) {
          if (!(H instanceof TypeError))
            throw H;
          if (m(true, "Missing signature argument to addFunction: " + e), typeof WebAssembly.Function == "function") {
            p2 = WebAssembly.Function, s = {
              i: "i32",
              j: "i32",
              f: "f32",
              d: "f64",
              p: "i32"
            }, u = {
              parameters: [],
              results: []
            };
            for (var F = 1; 2 > F; ++F)
              m("vi"[F] in s, "invalid signature char: " + "vi"[F]), u.parameters.push(s["vi"[F]]), "vi"[F] === "j" && u.parameters.push("i32");
            p2 = new p2(u, e);
          } else {
            for (p2 = [1], s = {
              i: 127,
              p: 127,
              j: 126,
              f: 125,
              d: 124
            }, p2.push(96), Ke(1, p2), u = 0; 1 > u; ++u)
              m("i"[u] in s, "invalid signature char: " + "i"[u]), p2.push(s["i"[u]]);
            p2.push(0), s = [0, 97, 115, 109, 1, 0, 0, 0, 1], Ke(p2.length, s), s.push.apply(s, p2), s.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0), p2 = new WebAssembly.Module(new Uint8Array(s)), p2 = new WebAssembly.Instance(p2, {
              e: {
                f: e
              }
            }).exports.f;
          }
          s = i, w.set(s, p2), se[s] = w.get(s);
        }
        ce.set(e, i), e = i;
      }
      n && typeof n == "object" && (n = n.g), n_(_, e, n);
    }, R.prototype.setSourceEndpoint = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), o_(n, e);
    }, R.prototype.setDestEndpoint = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), __(n, e);
    }, R.prototype.routingType = function() {
      return i_(this.g);
    }, R.prototype.setRoutingType = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), r_(n, e);
    }, R.prototype.displayRoute = function() {
      return g(p_(this.g), l);
    }, R.prototype.setHateCrossings = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), s_(n, e);
    }, R.prototype.doesHateCrossings = function() {
      return !!c_(this.g);
    }, R.prototype.__destroy__ = function() {
      d_(this.g);
    };
    function X(e, n, _) {
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), this.g = _ === void 0 ? a_(e, n) : m_(e, n, _), h2(X)[this.g] = this;
    }
    X.prototype = Object.create(y.prototype), X.prototype.constructor = X, X.prototype.h = X, X.l = {}, t.EdgeInf = X, X.prototype.__destroy__ = function() {
      u_(this.g);
    };
    function v() {
      throw "cannot construct a LineRep, no constructor in IDL";
    }
    v.prototype = Object.create(y.prototype), v.prototype.constructor = v, v.prototype.h = v, v.l = {}, t.LineRep = v, v.prototype.get_begin = v.prototype.K = function() {
      return g(y_(this.g), d);
    }, v.prototype.set_begin = v.prototype.ba = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), g_(n, e);
    }, Object.defineProperty(v.prototype, "begin", {
      get: v.prototype.K,
      set: v.prototype.ba
    }), v.prototype.get_end = v.prototype.L = function() {
      return g(f_(this.g), d);
    }, v.prototype.set_end = v.prototype.ca = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), b_(n, e);
    }, Object.defineProperty(v.prototype, "end", {
      get: v.prototype.L,
      set: v.prototype.ca
    }), v.prototype.__destroy__ = function() {
      l_(this.g);
    };
    function A(e) {
      e && typeof e == "object" && (e = e.g), this.g = h_(e), h2(A)[this.g] = this;
    }
    return A.prototype = Object.create(y.prototype), A.prototype.constructor = A, A.prototype.h = A, A.l = {}, t.Router = A, A.prototype.processTransaction = function() {
      return !!v_(this.g);
    }, A.prototype.printInfo = function() {
      P_(this.g);
    }, A.prototype.deleteConnector = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), C_(n, e);
    }, A.prototype.moveShape = function(e, n, _) {
      var i = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), _ === void 0 ? R_(i, e, n) : A_(i, e, n, _);
    }, A.prototype.deleteShape = function(e) {
      var n = this.g;
      e && typeof e == "object" && (e = e.g), T_(n, e);
    }, A.prototype.moveJunction = function(e, n, _) {
      var i = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), _ && typeof _ == "object" && (_ = _.g), _ === void 0 ? S_(i, e, n) : I_(i, e, n, _);
    }, A.prototype.setRoutingParameter = function(e, n) {
      var _ = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), E_(_, e, n);
    }, A.prototype.setRoutingOption = function(e, n) {
      var _ = this.g;
      e && typeof e == "object" && (e = e.g), n && typeof n == "object" && (n = n.g), O_(_, e, n);
    }, A.prototype.__destroy__ = function() {
      D_(this.g);
    }, function() {
      function e() {
        t.ConnDirNone = w_(), t.ConnDirUp = j_(), t.ConnDirDown = F_(), t.ConnDirLeft = M_(), t.ConnDirRight = x_(), t.ConnDirAll = L_(), t.ConnEndPoint = H_(), t.ConnEndShapePin = N_(), t.ConnEndJunction = U_(), t.ConnEndEmpty = V_(), t.ShapeMove = J_(), t.ShapeAdd = B_(), t.ShapeRemove = W_(), t.JunctionMove = k_(), t.JunctionAdd = Y_(), t.JunctionRemove = G_(), t.ConnChange = z_(), t.ConnectionPinChange = Z_(), t.TransformationType_CW90 = X_(), t.TransformationType_CW180 = K_(), t.TransformationType_CW270 = Q_(), t.TransformationType_FlipX = $_(), t.TransformationType_FlipY = q_(), t.ConnType_None = ei(), t.ConnType_PolyLine = ti(), t.ConnType_Orthogonal = ni(), t.PolyLineRouting = oi(), t.OrthogonalRouting = _i(), t.segmentPenalty = ii(), t.anglePenalty = ri(), t.crossingPenalty = pi(), t.clusterCrossingPenalty = si(), t.fixedSharedPathPenalty = ci(), t.portDirectionPenalty = di(), t.shapeBufferDistance = ai(), t.idealNudgingDistance = mi(), t.reverseDirectionPenalty = ui(), t.nudgeOrthogonalSegmentsConnectedToShapes = yi(), t.improveHyperedgeRoutesMovingJunctions = gi(), t.penaliseOrthogonalSharedPathsAtConnEnds = fi(), t.nudgeOrthogonalTouchingColinearSegments = bi(), t.performUnifyingNudgingPreprocessingStep = li(), t.improveHyperedgeRoutesMovingAddingAndDeletingJunctions = hi(), t.nudgeSharedPathsWithCommonEndPoint = vi();
      }
      ye ? e() : Se.unshift(e);
    }(), ie.ready;
  };
})(), ut = Ti;
var wi = mt(ut);
var RouteType;
(function(RouteType2) {
  RouteType2[RouteType2["PolyLine"] = 1] = "PolyLine";
  RouteType2[RouteType2["Orthogonal"] = 2] = "Orthogonal";
})(RouteType || (RouteType = {}));
var Directions;
(function(Directions2) {
  Directions2[Directions2["None"] = 0] = "None";
  Directions2[Directions2["Up"] = 1] = "Up";
  Directions2[Directions2["Down"] = 2] = "Down";
  Directions2[Directions2["Left"] = 4] = "Left";
  Directions2[Directions2["Right"] = 8] = "Right";
  Directions2[Directions2["All"] = 15] = "All";
})(Directions || (Directions = {}));
const libavoidRouterKind = "libavoid";
class LibavoidEdge extends lib$1.SEdgeImpl {
  constructor() {
    super(...arguments);
    this.routerKind = libavoidRouterKind;
    this.routeType = 0;
    this.sourceVisibleDirections = void 0;
    this.targetVisibleDirections = void 0;
    this.hateCrossings = false;
  }
}
function getRelativeAnchor(connectable, refPoint, refContainer, anchorComputer, anchorCorrection = 0) {
  const translatedRefPoint = lib$1.translatePoint(refPoint, refContainer, connectable.parent);
  const strokeCorrection = 0.5 * connectable.strokeWidth;
  const anchor2 = anchorComputer.getAnchor(connectable, translatedRefPoint, anchorCorrection + strokeCorrection);
  return {
    x: anchor2.x - connectable.bounds.x,
    y: anchor2.y - connectable.bounds.y
  };
}
function addConnectionPinsToShape(shapeRef, child, centerPoint, anchorComputer, Avoid) {
  let leftAnchor = getRelativeAnchor(child, {
    x: centerPoint.x - child.bounds.width,
    y: centerPoint.y
  }, child.parent, anchorComputer);
  const leftIsOnSide = Math.abs(leftAnchor.x) < 0.01;
  const shapeLeftPin = new Avoid.ShapeConnectionPin(shapeRef, 1, leftIsOnSide ? 0 : leftAnchor.x, leftIsOnSide ? 0.5 : leftAnchor.y, leftIsOnSide, 0, Directions.Left);
  shapeLeftPin.setExclusive(false);
  let rightAnchor = getRelativeAnchor(child, {
    x: centerPoint.x + child.bounds.width,
    y: centerPoint.y
  }, child.parent, anchorComputer);
  const rightIsOnSide = Math.abs(rightAnchor.x - child.bounds.width) < 0.01;
  const shapeRightPin = new Avoid.ShapeConnectionPin(shapeRef, 1, rightIsOnSide ? 1 : rightAnchor.x, rightIsOnSide ? 0.5 : rightAnchor.y, rightIsOnSide, 0, Directions.Right);
  shapeRightPin.setExclusive(false);
  let topAnchor = getRelativeAnchor(child, {
    x: centerPoint.x,
    y: centerPoint.y - child.bounds.height
  }, child.parent, anchorComputer);
  const topIsOnSide = Math.abs(topAnchor.y) < 0.01;
  const shapeTopPin = new Avoid.ShapeConnectionPin(shapeRef, 1, topIsOnSide ? 0.5 : topAnchor.x, topIsOnSide ? 0 : topAnchor.y, topIsOnSide, 0, Directions.Up);
  shapeTopPin.setExclusive(false);
  let bottomAnchor = getRelativeAnchor(child, {
    x: centerPoint.x,
    y: centerPoint.y + child.bounds.height
  }, child.parent, anchorComputer);
  const bottomIsOnSide = Math.abs(bottomAnchor.y - child.bounds.height) < 0.01;
  const shapeBottomPin = new Avoid.ShapeConnectionPin(shapeRef, 1, bottomIsOnSide ? 0.5 : bottomAnchor.x, bottomIsOnSide ? 1 : bottomAnchor.y, bottomIsOnSide, 0, Directions.Down);
  shapeBottomPin.setExclusive(false);
  const shapeCenterPin = new Avoid.ShapeConnectionPin(shapeRef, 2, 0.5, 0.5, true, 0, Directions.All);
  shapeCenterPin.setExclusive(false);
  console.log(child.id, leftAnchor, rightAnchor, bottomAnchor, topAnchor);
  if (!leftIsOnSide || !rightIsOnSide || !bottomIsOnSide || !topIsOnSide) {
    console.log("ERROR !");
  }
  return {
    left: shapeLeftPin,
    leftIsOnSide,
    right: shapeRightPin,
    rightIsOnSide,
    top: shapeTopPin,
    topIsOnSide,
    bottom: shapeBottomPin,
    bottomIsOnSide,
    center: shapeCenterPin
  };
}
function getCenterPoint(element) {
  let x = element.bounds.width / 2, y = element.bounds.height / 2;
  let currentElement = element;
  while (currentElement) {
    if (currentElement.position) {
      x += currentElement.position.x;
      y += currentElement.position.y;
    }
    if (!(currentElement.parent && currentElement.parent.id === "graph")) {
      currentElement = currentElement.parent;
    } else {
      break;
    }
  }
  return {
    x,
    y
  };
}
function updateConnPinsOnShapeResize(child, shapeInfo, anchorComputer, Avoid) {
  const centerPoint = getCenterPoint(child);
  if (!shapeInfo.connPins.leftIsOnSide) {
    const leftAnchor = getRelativeAnchor(child, {
      x: centerPoint.x - child.bounds.width,
      y: centerPoint.y
    }, child.parent, anchorComputer);
    shapeInfo.connPins.left.updatePosition(new Avoid.Point(leftAnchor.x, leftAnchor.y));
  }
  if (!shapeInfo.connPins.rightIsOnSide) {
    let rightAnchor = getRelativeAnchor(child, {
      x: centerPoint.x + child.bounds.width,
      y: centerPoint.y
    }, child.parent, anchorComputer);
    shapeInfo.connPins.right.updatePosition(new Avoid.Point(rightAnchor.x, rightAnchor.y));
  }
  if (!shapeInfo.connPins.topIsOnSide) {
    let topAnchor = getRelativeAnchor(child, {
      x: centerPoint.x,
      y: centerPoint.y - child.bounds.height
    }, child.parent, anchorComputer);
    shapeInfo.connPins.top.updatePosition(new Avoid.Point(topAnchor.x, topAnchor.y));
  }
  if (!shapeInfo.connPins.bottomIsOnSide) {
    let bottomAnchor = getRelativeAnchor(child, {
      x: centerPoint.x,
      y: centerPoint.y + child.bounds.height
    }, child.parent, anchorComputer);
    shapeInfo.connPins.bottom.updatePosition(new Avoid.Point(bottomAnchor.x, bottomAnchor.y));
  }
}
const routerOptionType = {
  // routingType is a custom option, not inherited from libavoid
  routingType: "custom",
  segmentPenalty: "parameter",
  anglePenalty: "parameter",
  crossingPenalty: "parameter",
  clusterCrossingPenalty: "parameter",
  fixedSharedPathPenalty: "parameter",
  portDirectionPenalty: "parameter",
  shapeBufferDistance: "parameter",
  idealNudgingDistance: "parameter",
  reverseDirectionPenalty: "parameter",
  nudgeOrthogonalSegmentsConnectedToShapes: "option",
  improveHyperedgeRoutesMovingJunctions: "option",
  penaliseOrthogonalSharedPathsAtConnEnds: "option",
  nudgeOrthogonalTouchingColinearSegments: "option",
  performUnifyingNudgingPreprocessingStep: "option",
  improveHyperedgeRoutesMovingAddingAndDeletingJunctions: "option",
  nudgeSharedPathsWithCommonEndPoint: "option"
};
const sizeIsEqual = (bounds1, bounds2) => {
  return bounds1.width === bounds2.width && bounds1.height === bounds2.height;
};
const positionIsEqual = (bounds1, bounds2) => {
  return bounds1.x === bounds2.x && bounds1.y === bounds2.y;
};
class LibavoidRouter extends lib$1.AbstractEdgeRouter {
  constructor() {
    super();
    this.renderedTimes = 0;
    this.avoidConnRefsByEdgeId = {};
    this.avoidShapes = {};
    this.options = {};
    this.edgeRouting = new lib$1.EdgeRouting();
    this.changedEdgeIds = [];
    const Avoid = wi.getInstance();
    this.avoidRouter = new Avoid.Router(Avoid.PolyLineRouting);
  }
  get kind() {
    return LibavoidRouter.KIND;
  }
  setOptions(options) {
    const Avoid = wi.getInstance();
    if ("routingType" in options && options.routingType) {
      Avoid.destroy(this.avoidRouter);
      this.avoidRouter = new Avoid.Router(options.routingType);
    }
    this.options = Object.assign(Object.assign({}, this.options), options);
    Object.entries(this.options).forEach(([key, value]) => {
      if (routerOptionType[key] === "parameter") {
        this.avoidRouter.setRoutingParameter(Avoid[key], value);
      } else if (routerOptionType[key] === "option") {
        this.avoidRouter.setRoutingOption(Avoid[key], value);
      }
    });
  }
  getAllBoundsAwareChildren(parent) {
    const result = [];
    for (const child of parent.children) {
      if (lib$1.isBoundsAware(child)) {
        result.push(child);
      }
      if (child instanceof lib$1.SParentElementImpl) {
        result.push(...this.getAllBoundsAwareChildren(child));
      }
    }
    return result;
  }
  getFixedTranslatedAnchor(connectable, sourcePoint, refPoint, refContainer, edge, anchorCorrection = 0) {
    let anchor2 = this.getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection);
    if (sourcePoint.x === refPoint.x) {
      anchor2 = {
        x: sourcePoint.x,
        y: anchor2.y
      };
    } else if (sourcePoint.y === refPoint.y) {
      anchor2 = {
        x: anchor2.x,
        y: sourcePoint.y
      };
    }
    return anchor2;
  }
  updateConnRefInEdgeRouting(connRef, edge) {
    if (!edge.source || !edge.target) {
      return;
    }
    const sprottyRoute = [];
    const route = connRef.displayRoute();
    const avoidRoute = [];
    for (let i = 0; i < route.size(); i++) {
      avoidRoute.push({
        x: route.get_ps(i).x,
        y: route.get_ps(i).y
      });
    }
    let sourceAnchor;
    if (edge.routeType == RouteType.PolyLine) {
      const sourcePointForSourceAnchor = {
        x: avoidRoute[0].x,
        y: avoidRoute[0].y
      };
      const targetPointForSourceAnchor = {
        x: avoidRoute[1].x,
        y: avoidRoute[1].y
      };
      sourceAnchor = this.getFixedTranslatedAnchor(edge.source, sourcePointForSourceAnchor, targetPointForSourceAnchor, edge.parent, edge, edge.sourceAnchorCorrection);
    } else {
      sourceAnchor = {
        x: avoidRoute[0].x,
        y: avoidRoute[0].y
      };
    }
    sprottyRoute.push(Object.assign({
      kind: "source"
    }, sourceAnchor));
    for (let i = 0; i < avoidRoute.length; i++) {
      if (i === 0 || i === avoidRoute.length - 1) {
        continue;
      }
      const point = {
        x: avoidRoute[i].x,
        y: avoidRoute[i].y,
        kind: "linear",
        pointIndex: i
      };
      sprottyRoute.push(point);
    }
    let targetAnchor;
    if (edge.routeType == RouteType.PolyLine) {
      const sourcePointForTargetAnchor = {
        x: avoidRoute[avoidRoute.length - 1].x,
        y: avoidRoute[avoidRoute.length - 1].y
      };
      const targetPointForTargetAnchor = {
        x: avoidRoute[avoidRoute.length - 2].x,
        y: avoidRoute[avoidRoute.length - 2].y
      };
      targetAnchor = this.getFixedTranslatedAnchor(edge.target, sourcePointForTargetAnchor, targetPointForTargetAnchor, edge.parent, edge, edge.targetAnchorCorrection);
    } else {
      targetAnchor = {
        x: avoidRoute[avoidRoute.length - 1].x,
        y: avoidRoute[avoidRoute.length - 1].y
      };
    }
    sprottyRoute.push(Object.assign({
      kind: "target"
    }, targetAnchor));
    this.edgeRouting.set(edge.id, sprottyRoute);
  }
  routeAll(edges, parent) {
    const Avoid = wi.getInstance();
    let routesChanged = false;
    const connectables = this.getAllBoundsAwareChildren(parent);
    for (const child of connectables) {
      if (!(child instanceof lib$1.SConnectableElementImpl) || !child.hasFeature(lib$1.connectableFeature)) {
        continue;
      }
      if (child.bounds.width === -1) {
        return this.edgeRouting;
      }
      if (child.id in this.avoidShapes) {
        routesChanged = routesChanged || this.handleModifiedShape(child, Avoid);
      } else {
        this.handleNewShape(child, Avoid);
        if (!routesChanged) {
          routesChanged = true;
        }
      }
    }
    const connectableIds = connectables.map((c) => c.id);
    for (const shapeId of Object.keys(this.avoidShapes)) {
      if (!connectableIds.includes(shapeId)) {
        this.avoidRouter.deleteShape(this.avoidShapes[shapeId].ref);
        delete this.avoidShapes[shapeId];
        if (!routesChanged) {
          routesChanged = true;
        }
      }
    }
    const edgeById = {};
    for (const edge of edges) {
      edgeById[edge.id] = edge;
      if (edge.id in this.avoidConnRefsByEdgeId) {
        continue;
      }
      let classId = 1;
      if (edge.routeType == RouteType.PolyLine) {
        classId = 2;
      }
      const sourceShape = this.avoidShapes[edge.sourceId];
      if (!sourceShape) {
        continue;
      }
      const sourceConnEnd = new Avoid.ConnEnd(sourceShape.ref, classId);
      const targetShape = this.avoidShapes[edge.targetId];
      if (!targetShape) {
        continue;
      }
      const targetConnEnd = new Avoid.ConnEnd(targetShape.ref, classId);
      const connRef = new Avoid.ConnRef(this.avoidRouter, sourceConnEnd, targetConnEnd);
      connRef.setCallback(() => {
        this.changedEdgeIds.push(edge.id);
      }, connRef);
      if (edge.routeType) {
        connRef.setRoutingType(edge.routeType);
      }
      if (edge.hateCrossings) {
        connRef.setHateCrossings(edge.hateCrossings);
      }
      this.avoidConnRefsByEdgeId[edge.id] = connRef;
      if (!routesChanged) {
        routesChanged = true;
      }
    }
    const edgesIds = edges.map((e) => e.id);
    for (const oldEdgeId of Object.keys(this.avoidConnRefsByEdgeId)) {
      if (!edgesIds.includes(oldEdgeId)) {
        this.avoidRouter.deleteConnector(this.avoidConnRefsByEdgeId[oldEdgeId]);
        delete this.avoidConnRefsByEdgeId[oldEdgeId];
        if (!routesChanged) {
          routesChanged = true;
        }
      }
    }
    if (routesChanged) {
      this.avoidRouter.processTransaction();
    }
    this.changedEdgeIds.forEach((edgeId) => {
      this.updateConnRefInEdgeRouting(this.avoidConnRefsByEdgeId[edgeId], edgeById[edgeId]);
    });
    this.changedEdgeIds = [];
    return this.edgeRouting;
  }
  handleModifiedShape(child, Avoid) {
    let routesChanged = false;
    if (!positionIsEqual(child.bounds, this.avoidShapes[child.id].bounds)) {
      this.avoidRouter.moveShape(this.avoidShapes[child.id].ref, child.bounds.x - this.avoidShapes[child.id].bounds.x, child.bounds.y - this.avoidShapes[child.id].bounds.y);
      this.avoidShapes[child.id].bounds = Object.assign(Object.assign({}, this.avoidShapes[child.id].bounds), {
        x: child.bounds.x,
        y: child.bounds.y
      });
      if (!routesChanged) {
        routesChanged = true;
      }
    }
    if (!sizeIsEqual(child.bounds, this.avoidShapes[child.id].bounds)) {
      const centerPoint = getCenterPoint(child);
      const newRectangle = new Avoid.Rectangle(new Avoid.Point(centerPoint.x, centerPoint.y), child.bounds.width, child.bounds.height);
      this.avoidRouter.moveShape(this.avoidShapes[child.id].ref, newRectangle);
      this.avoidShapes[child.id].bounds = Object.assign(Object.assign({}, this.avoidShapes[child.id].bounds), {
        width: child.bounds.width,
        height: child.bounds.height
      });
      updateConnPinsOnShapeResize(child, this.avoidShapes[child.id], this.getAnchorComputer(child), Avoid);
      if (!routesChanged) {
        routesChanged = true;
      }
    }
    return routesChanged;
  }
  handleNewShape(child, Avoid) {
    const centerPoint = getCenterPoint(child);
    const rectangle = new Avoid.Rectangle(new Avoid.Point(centerPoint.x, centerPoint.y), child.bounds.width, child.bounds.height);
    const shapeRef = new Avoid.ShapeRef(this.avoidRouter, rectangle);
    const connPins = addConnectionPinsToShape(shapeRef, child, centerPoint, this.getAnchorComputer(child), Avoid);
    this.avoidShapes[child.id] = {
      ref: shapeRef,
      bounds: Object.assign({}, child.bounds),
      connPins
    };
  }
  destroy() {
    const Avoid = wi.getInstance();
    Avoid.destroy(this.avoidRouter);
  }
  route(edge, args) {
    var _a, _b, _c, _d;
    let route = this.edgeRouting.get(edge.id);
    if (route === void 0) {
      route = [{
        x: ((_a = edge.source) === null || _a === void 0 ? void 0 : _a.position.x) || 0,
        y: ((_b = edge.source) === null || _b === void 0 ? void 0 : _b.position.y) || 0,
        kind: "source"
      }, {
        x: ((_c = edge.target) === null || _c === void 0 ? void 0 : _c.position.x) || 0,
        y: ((_d = edge.target) === null || _d === void 0 ? void 0 : _d.position.y) || 0,
        kind: "target"
      }];
    }
    return route;
  }
  createRoutingHandles(edge) {
    const rpCount = edge.routingPoints.length;
    this.addHandle(edge, "source", "routing-point", -2);
    this.addHandle(edge, "line", "volatile-routing-point", -1);
    for (let i = 0; i < rpCount; i++) {
      this.addHandle(edge, "junction", "routing-point", i);
      this.addHandle(edge, "line", "volatile-routing-point", i);
    }
    this.addHandle(edge, "target", "routing-point", rpCount);
  }
  applyInnerHandleMoves(edge, moves) {
    moves.forEach((move2) => {
      const handle = move2.handle;
      const points = edge.routingPoints;
      let index = handle.pointIndex;
      if (handle.kind === "line") {
        handle.kind = "junction";
        handle.type = "routing-point";
        points.splice(index + 1, 0, move2.fromPosition || points[Math.max(index, 0)]);
        edge.children.forEach((child) => {
          if (child instanceof lib$1.SRoutingHandleImpl && (child === handle || child.pointIndex > index))
            child.pointIndex++;
        });
        this.addHandle(edge, "line", "volatile-routing-point", index);
        this.addHandle(edge, "line", "volatile-routing-point", index + 1);
        index++;
      }
      if (index >= 0 && index < points.length) {
        points[index] = move2.toPosition;
      }
    });
  }
  getInnerHandlePosition(edge, route, handle) {
    if (handle.kind === "line") {
      const {
        start,
        end
      } = this.findRouteSegment(edge, route, handle.pointIndex);
      if (start !== void 0 && end !== void 0)
        return lib.centerOfLine(start, end);
    }
    return void 0;
  }
  getOptions(edge) {
    return {
      minimalPointDistance: 2,
      standardDistance: 20,
      selfEdgeOffset: 0.25
    };
  }
  /**
   * Calculation is similar as in original method, but `minimalSegmentLengthForChildPosition`
   * parameter is introduced(see LibavoidRouterOptions.minimalSegmentLengthForChildPosition for
   * more details) to avoid getting very small segments, that has negative impact for example on
   * placing edge children such as labels.
   */
  calculateSegment(edge, t) {
    const segments = super.calculateSegment(edge, t);
    if (!segments)
      return void 0;
    let {
      segmentStart,
      segmentEnd,
      lambda
    } = segments;
    const segmentLength = lib.Point.euclideanDistance(segmentStart, segmentEnd);
    const minSegmentSize = this.options.minimalSegmentLengthForChildPosition === void 0 ? 20 : this.options.minimalSegmentLengthForChildPosition;
    if (segmentLength < minSegmentSize) {
      const routedPoints = this.route(edge);
      if (routedPoints.length < 2)
        return void 0;
      let found = false;
      const segmentStartIndex = routedPoints.findIndex((point) => lib.Point.equals(point, segmentStart));
      for (let i = segmentStartIndex - 1; i >= 0; i--) {
        const currentSegmentLength = lib.Point.euclideanDistance(routedPoints[i], routedPoints[i + 1]);
        if (currentSegmentLength > minSegmentSize) {
          segmentStart = routedPoints[i];
          segmentEnd = routedPoints[i + 1];
          lambda = 0.8;
          found = true;
          break;
        }
      }
      if (!found) {
        const segmentEndIndex = segmentStartIndex + 1;
        if (segmentEndIndex < routedPoints.length - 1) {
          for (let i = segmentEndIndex; i < routedPoints.length - 1; i++) {
            const currentSegmentLength = lib.Point.euclideanDistance(routedPoints[i], routedPoints[i + 1]);
            if (currentSegmentLength > minSegmentSize) {
              segmentStart = routedPoints[i];
              segmentEnd = routedPoints[i + 1];
              lambda = 0.2;
              found = true;
              break;
            }
          }
        }
      }
    }
    return {
      segmentStart,
      segmentEnd,
      lambda
    };
  }
}
LibavoidRouter.KIND = libavoidRouterKind;
class LibavoidEllipseAnchor extends lib$1.EllipseAnchor {
  get kind() {
    return LibavoidRouter.KIND + ":" + lib$1.ELLIPTIC_ANCHOR_KIND;
  }
}
class LibavoidRectangleAnchor extends lib$1.RectangleAnchor {
  get kind() {
    return LibavoidRouter.KIND + ":" + lib$1.RECTANGULAR_ANCHOR_KIND;
  }
}
class LibavoidDiamondAnchor extends lib$1.ManhattanDiamondAnchor {
  get kind() {
    return LibavoidRouter.KIND + ":" + lib$1.DIAMOND_ANCHOR_KIND;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function load() {
  return __awaiter(this, arguments, void 0, function* (filePath = void 0) {
    yield wi.load(filePath);
  });
}
var _dec, _class;
let MainNodeView = (_dec = injectable(), _dec(_class = class MainNodeView2 extends lib$1.ShapeView {
  render(node, context) {
    if (!this.isVisible(node, context)) {
      return void 0;
    }
    const size2 = this.getSize(node);
    return h("g", {}, [h("rect", {
      attrs: {
        "class-sprotty-node": true,
        "class-selected": node.selected,
        "class-mouseover": node.hoverFeedback,
        width: node.size.width,
        height: node.size.height,
        rx: 8,
        ry: 8
      }
    }), h("text", {
      attrs: {
        x: size2,
        y: size2 + 7,
        "class-sprotty-text": true
      }
    }, node.id.substr(4))]);
  }
  getSize(node) {
    const d = Math.min(node.size.width, node.size.height);
    return d > 0 ? d / 2 : 0;
  }
}) || _class);
const exampleGraphModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  bind(lib$1.TYPES.ModelSource).to(lib$1.LocalModelSource).inSingletonScope();
  rebind(lib$1.TYPES.ILogger).to(lib$1.ConsoleLogger).inSingletonScope();
  rebind(lib$1.TYPES.LogLevel).toConstantValue(lib$1.LogLevel.log);
  bind(LibavoidRouter).toSelf().inSingletonScope();
  bind(lib$1.TYPES.IEdgeRouter).toService(LibavoidRouter);
  bind(lib$1.TYPES.IAnchorComputer).to(LibavoidDiamondAnchor).inSingletonScope();
  bind(lib$1.TYPES.IAnchorComputer).to(LibavoidEllipseAnchor).inSingletonScope();
  bind(lib$1.TYPES.IAnchorComputer).to(LibavoidRectangleAnchor).inSingletonScope();
  const context = {
    bind,
    unbind,
    isBound,
    rebind
  };
  lib$1.configureModelElement(context, "graph", lib$1.SGraph, lib$1.SGraphView);
  lib$1.configureModelElement(context, "node:square", lib$1.RectangularNode, MainNodeView);
  lib$1.configureModelElement(context, "edge:straight", LibavoidEdge, lib$1.PolylineEdgeView, {});
  lib$1.configureViewerOptions(context, {
    needsClientLayout: false
  });
});
const createDiagramContainer = () => {
  const container = new Container();
  lib$1.loadDefaultModules(container);
  container.load(exampleGraphModule);
  const router = container.get(LibavoidRouter);
  router.setOptions({
    routingType: RouteType.Orthogonal,
    segmentPenalty: 50,
    idealNudgingDistance: 4,
    nudgeOrthogonalSegmentsConnectedToShapes: true,
    nudgeOrthogonalTouchingColinearSegments: true
  });
  return container;
};
const destroyDiagramContainer = (container) => {
  container.unbindAll();
  container.unload(exampleGraphModule);
};
const NODE_SIZE = 60;
const createDiagram = async (nodesNumber, random) => {
  await load();
  let count = 2;
  function addNode(bounds, index) {
    const factor = random ? Math.random() : 0.15 + 0.09 * index;
    const newNode = {
      id: "node" + count,
      type: "node:square",
      position: {
        x: bounds.x + factor * (bounds.width - NODE_SIZE),
        y: bounds.y + factor * (bounds.height - NODE_SIZE)
      },
      size: {
        width: NODE_SIZE,
        height: NODE_SIZE
      }
    };
    const newEdge = {
      id: "edge" + count,
      type: "edge:straight",
      sourceId: "node0",
      targetId: "node" + count,
      routerKind: LibavoidRouter.KIND
    };
    count++;
    return [newNode, newEdge];
  }
  function getVisibleBounds({
    canvasBounds,
    scroll: scroll2,
    zoom: zoom2
  }) {
    return {
      ...scroll2,
      width: canvasBounds.width / zoom2,
      height: canvasBounds.height / zoom2
    };
  }
  const container = createDiagramContainer();
  const modelSource2 = container.get(lib$1.TYPES.ModelSource);
  const node0 = {
    id: "node0",
    type: "node:square",
    position: {
      x: 100,
      y: 100
    },
    size: {
      width: NODE_SIZE,
      height: NODE_SIZE
    }
  };
  const graph = {
    id: "graph",
    type: "graph",
    children: [node0]
  };
  const initialViewport = await modelSource2.getViewport();
  for (let i = 0; i < nodesNumber; ++i) {
    const newElements = addNode(getVisibleBounds(initialViewport), i);
    graph.children.push(...newElements);
  }
  modelSource2.setModel(graph);
  return container;
};
const destroyDiagram = destroyDiagramContainer;
const DiagramView_vue_vue_type_style_index_0_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = defineComponent({
  name: "DiagramView",
  data() {
    return {
      container: null,
      nodes: 25,
      randomNodes: false
    };
  },
  watch: {
    nodes(newValue) {
      try {
        localStorage.setItem("nodes", JSON.stringify(newValue));
      } catch (e) {
        console.log(e);
        console.log("LS is unavailable");
      }
      this.updateDiagram();
    },
    randomNodes(newValue) {
      try {
        localStorage.setItem("randomNodes", JSON.stringify(newValue));
      } catch (e) {
        console.log(e);
        console.log("LS is unavailable");
      }
      this.updateDiagram();
    }
  },
  mounted() {
    try {
      const randomNodesRawValue = localStorage.getItem("randomNodes");
      this.randomNodes = randomNodesRawValue !== null ? JSON.parse(randomNodesRawValue) : false;
      const nodesRawValue = localStorage.getItem("nodes");
      this.nodes = nodesRawValue !== null ? JSON.parse(nodesRawValue) : 25;
    } catch (e) {
      console.log(e);
      console.log("LS is unavailable");
    }
    this.updateDiagram();
  },
  beforeUnmount() {
    if (this.container) {
      destroyDiagram(this.container);
    }
  },
  methods: {
    async updateDiagram() {
      console.log("update");
      if (this.container) {
        console.log("destroy");
        destroyDiagram(this.container);
      }
      this.container = await createDiagram(this.nodes, this.randomNodes);
    }
  }
});
const _hoisted_1 = { class: "sprotty-diagram" };
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", {
  id: "sprotty",
  class: "sprotty"
}, null, -1);
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.nodes = $event),
      type: "number"
    }, null, 512), [
      [vModelText, _ctx.nodes]
    ]),
    createTextVNode(" Nodes "),
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.randomNodes = $event),
      type: "checkbox"
    }, null, 512), [
      [vModelCheckbox, _ctx.randomNodes]
    ]),
    createTextVNode(" Random "),
    createBaseVNode("button", {
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.updateDiagram && _ctx.updateDiagram(...args))
    }, "Update"),
    _hoisted_2
  ]);
}
const DiagramView = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const App_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  components: {
    DiagramView
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DiagramView = resolveComponent("DiagramView");
  return openBlock(), createBlock(_component_DiagramView);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
createApp(App).mount("#app");
